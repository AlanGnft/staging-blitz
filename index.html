<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Endless Runner</title>

<!-- Firebase Scripts -->
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>

<script>
// Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyDr_qv6W6AxuXGWG49bTdr0j2DvmMZObnA",
  authDomain: "running-blitz.firebaseapp.com",
  databaseURL: "https://running-blitz-default-rtdb.firebaseio.com",
  projectId: "running-blitz",
  storageBucket: "running-blitz.firebasestorage.app",
  messagingSenderId: "511589639020",
  appId: "1:511589639020:web:a0c3cbc26e293a00834949"
};

// Initialize Firebase
firebase.initializeApp(firebaseConfig);
</script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #000;
            touch-action: none; /* Disable browser's default touch actions */
        }
        #score {
    position: absolute;
    top: 20px;
    right: 20px;
    color: white;
    font-size: 24px;
    z-index: 100;
    text-align: right;
}
        #totalCoins {
    position: absolute;
    top: 55px;
    right: 20px;
    color: gold;
    font-size: 20px;
    z-index: 100;
    text-align: right;
}
        #pauseBtn {
    position: absolute;
    top: 95px;
    right: 20px;
    width: 40px;
    height: 40px;
    background-color: rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 24px;
    color: white;
    cursor: pointer;
    z-index: 100;
    border: none;
}
        
        #speedIndicator {
    position: absolute;
    top: 20px;
    left: 20px;
    padding: 12px 20px;
    background-color: rgba(255, 255, 255, 0.3);
    border-radius: 25px;
    color: white;
    font-size: 18px;
    font-weight: bold;
    z-index: 100;
    border: 2px solid rgba(255, 255, 255, 0.5);
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
    transition: all 0.5s ease;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    min-width: 200px;
    white-space: nowrap;
    text-align: center;
}


    
    /* Mobile responsive adjustments */
@media screen and (max-width: 768px) {
    #score {
        font-size: 20px;
        top: 15px;
        right: 15px;
    }
    
    #totalCoins {
        font-size: 18px;
        top: 45px;
        right: 15px;
    }
    
    #pauseBtn {
        width: 35px;
        height: 35px;
        font-size: 20px;
        top: 80px;
        right: 15px;
    }
    
    #speedIndicator {
    top: 15px;
    left: 15px;
    font-size: 12px;
    padding: 6px 12px;
    min-width: 180px;
    max-width: none;
}
}

/* Speed level animations */
.speed-level-1 {
    background: linear-gradient(45deg, rgba(135, 206, 235, 0.8), rgba(100, 149, 237, 0.8));
    border-color: rgba(135, 206, 235, 0.8);
    box-shadow: 0 0 15px rgba(135, 206, 235, 0.5);
}

.speed-level-2 {
    background: linear-gradient(45deg, rgba(255, 215, 0, 0.8), rgba(255, 165, 0, 0.8));
    border-color: rgba(255, 215, 0, 0.8);
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
    animation: pulse-yellow 1s infinite alternate;
}

.speed-level-3 {
    background: linear-gradient(45deg, rgba(255, 69, 0, 0.8), rgba(255, 140, 0, 0.8));
    border-color: rgba(255, 69, 0, 0.8);
    box-shadow: 0 0 25px rgba(255, 69, 0, 0.7);
    animation: pulse-orange 0.8s infinite alternate;
    border-radius: 15px;
}

.speed-level-4 {
    background: linear-gradient(45deg, rgba(220, 20, 60, 0.9), rgba(255, 0, 0, 0.9));
    border-color: rgba(220, 20, 60, 0.9);
    box-shadow: 0 0 30px rgba(220, 20, 60, 0.8), inset 0 0 10px rgba(255, 0, 0, 0.3);
    animation: intense-flame 0.6s infinite alternate;
    border-radius: 10px;
}

.speed-level-5 {
    background: linear-gradient(45deg, rgba(139, 0, 139, 0.9), rgba(75, 0, 130, 0.9));
    border-color: rgba(139, 0, 139, 0.9);
    box-shadow: 0 0 35px rgba(139, 0, 139, 0.9), inset 0 0 15px rgba(75, 0, 130, 0.4);
    animation: chaos-mode 0.4s infinite;
    border-radius: 5px;
}

@keyframes pulse-yellow {
    0% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.6); }
    100% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.8); }
}

@keyframes pulse-orange {
    0% { box-shadow: 0 0 25px rgba(255, 69, 0, 0.7); }
    100% { box-shadow: 0 0 35px rgba(255, 69, 0, 0.9); }
}

@keyframes intense-flame {
    0% { 
        box-shadow: 0 0 30px rgba(220, 20, 60, 0.8), inset 0 0 10px rgba(255, 0, 0, 0.3);
    }
    100% { 
        box-shadow: 0 0 40px rgba(220, 20, 60, 1.0), inset 0 0 20px rgba(255, 0, 0, 0.5);
    }
}

@keyframes chaos-mode {
    0% { 
        box-shadow: 0 0 35px rgba(139, 0, 139, 0.9), inset 0 0 15px rgba(75, 0, 130, 0.4);
    }
    25% { 
        box-shadow: 0 0 45px rgba(255, 0, 255, 1.0), inset 0 0 25px rgba(138, 43, 226, 0.6);
    }
    50% { 
        box-shadow: 0 0 40px rgba(75, 0, 130, 1.0), inset 0 0 20px rgba(139, 0, 139, 0.5);
    }
    100% { 
        box-shadow: 0 0 50px rgba(139, 0, 139, 1.0), inset 0 0 30px rgba(75, 0, 130, 0.7);
    }
}
        #pauseScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 150;
        }
        #pauseScreen h2 {
            color: white;
            font-size: 48px;
            margin-bottom: 20px;
        }
        #pauseScreen p {
            color: white;
            font-size: 24px;
            margin-bottom: 20px;
        }
        #resumeButton {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 10px;
        }
        #gameOver {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 150;
    text-align: center;
    color: white;
    font-size: 24px;
    padding: 20px;
    box-sizing: border-box;
}
        
        #startScreen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 200;
}
        #startScreen h1 {
            color: white;
            font-size: 48px;
            margin-bottom: 20px;
        }
        #startButton {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .game-button {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
        }
        #settingsScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            background-color: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 150;
            border-radius: 10px;
            padding: 20px;
            overflow-y: auto;
        }
        #settingsScreen h2 {
            color: white;
            font-size: 36px;
            margin-bottom: 20px;
        }
        .settings-section {
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            width: 100%;
            margin-bottom: 20px;
            padding: 15px;
            box-sizing: border-box;
        }
        .settings-section h3 {
            color: white;
            margin-top: 0;
            text-align: center;
        }
        .character-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            width: 100%;
        }
        .character-option {
            display: flex;
            align-items: center;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
        }
        .character-option.selected {
            background-color: rgba(76, 175, 80, 0.3);
        }
        .character-preview {
            width: 60px;
            height: 60px;
            margin-right: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
        }
        .character-info {
            flex-grow: 1;
            color: white;
        }
        .character-action {
            padding: 5px 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .character-action.disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        .mod-option {
            display: flex;
            align-items: center;
            margin: 15px 0;
        }
        .mod-option.enabled {
            background-color: rgba(76, 175, 80, 0.3);
        }
        .mod-info {
            flex-grow: 1;
            color: white;
        }
        .mod-action {
            padding: 8px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .mod-password {
            padding: 10px;
            margin: 10px 0;
            border: none;
            border-radius: 5px;
            width: 100%;
        }
        #closeSettingsButton {
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #333;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #touchArea {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 80%; /* Increased touch area height */
            z-index: 50;
            display: none;
        }
        #swipeInstructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 16px;
            text-align: center;
            z-index: 100;
            display: none;
        }
        /* Modal overlay for clicking outside to close */
        #modalOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 140;
            display: none;
        }
        /* Leaderboard styles */
        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            color: white;
        }
        .leaderboard-table th, 
        .leaderboard-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        .leaderboard-table th {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .leaderboard-table tr:nth-child(even) {
            background-color: rgba(255, 255, 255, 0.05);
        }
        .leaderboard-table tr:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .tab-buttons {
            display: flex;
            margin-bottom: 15px;
            width: 100%;
        }
        .tab-button {
            flex: 1;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .tab-button:first-child {
            border-top-left-radius: 5px;
            border-bottom-left-radius: 5px;
        }
        .tab-button:last-child {
            border-top-right-radius: 5px;
            border-bottom-right-radius: 5px;
        }
        .tab-button.active {
            background-color: rgba(76, 175, 80, 0.5);
        }
        .tab-content {
            display: none;
            width: 100%;
        }
        .tab-content.active {
            display: block;
        }

        /* Jukebox Styles */
.track-option {
    display: flex;
    align-items: center;
    padding: 12px;
    margin-bottom: 8px;
    background-color: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 2px solid transparent;
}

.track-option:hover {
    background-color: rgba(255, 255, 255, 0.1);
    transform: translateX(5px);
}

.track-option.selected {
    background-color: rgba(76, 175, 80, 0.2);
    border-color: rgba(76, 175, 80, 0.6);
    box-shadow: 0 0 15px rgba(76, 175, 80, 0.3);
}

.track-info {
    flex-grow: 1;
    color: white;
}

.track-name {
    font-size: 18px;
    font-weight: bold;
    margin-bottom: 4px;
}

.track-description {
    font-size: 14px;
    opacity: 0.8;
    font-style: italic;
}

.track-icon {
    font-size: 24px;
    margin-right: 15px;
    filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.3));
}

.track-status {
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: bold;
    text-transform: uppercase;
}

.track-playing {
    background: linear-gradient(45deg, #4CAF50, #8BC34A);
    color: white;
    animation: pulse-playing 1.5s infinite;
}

.track-selected {
    background: linear-gradient(45deg, #FF9800, #FFC107);
    color: white;
}

@keyframes pulse-playing {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.05); opacity: 0.8; }
    100% { transform: scale(1); opacity: 1; }
}

        #playerNameInput {
            padding: 10px;
            margin: 10px 0;
            width: 100%;
            border: none;
            border-radius: 5px;
            box-sizing: border-box;
            background-color: rgba(255, 255, 255, 0.8);
        }
        #saveScoreButton {
            padding: 10px 20px;
            margin-top: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

/* Audio control checkboxes */
.audio-checkbox {
    position: relative;
    display: inline-block;
    cursor: pointer;
    font-size: 18px;
    user-select: none;
}

/* Compact audio setting rows */
.audio-setting-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    max-width: 100%;
}

.audio-setting-row:last-child {
    border-bottom: none;
}

.audio-label {
    color: white;
    font-size: 16px;
    font-weight: normal;
    flex-grow: 1;
}

/* Adjust checkbox size for compact layout and keep it contained */
.audio-setting-row .audio-checkbox {
    margin-left: 10px;
    flex-shrink: 0;
}

.audio-setting-row .audio-checkbox .checkmark {
    height: 20px;
    width: 20px;
}

.audio-setting-row .audio-checkbox .checkmark:after {
    left: 6px;
    top: 2px;
    width: 5px;
    height: 10px;
}

.audio-setting-row .audio-checkbox .checkmark:after {
    left: 6px;
    top: 2px;
    width: 5px;
    height: 10px;
}

.audio-checkbox input {
    position: absolute;
    opacity: 0;
    cursor: pointer;
    height: 0;
    width: 0;
}

.checkmark {
    position: absolute;
    top: 0;
    left: 0;
    height: 25px;
    width: 25px;
    background-color: rgba(255, 255, 255, 0.2);
    border: 2px solid rgba(255, 255, 255, 0.5);
    border-radius: 5px;
    transition: all 0.3s ease;
}

.audio-checkbox:hover input ~ .checkmark {
    background-color: rgba(255, 255, 255, 0.3);
}

.audio-checkbox input:checked ~ .checkmark {
    background-color: #4CAF50;
    border-color: #4CAF50;
}

.checkmark:after {
    content: "";
    position: absolute;
    display: none;
}

.audio-checkbox input:checked ~ .checkmark:after {
    display: block;
}

.audio-checkbox .checkmark:after {
    left: 8px;
    top: 4px;
    width: 6px;
    height: 12px;
    border: solid white;
    border-width: 0 3px 3px 0;
    transform: rotate(45deg);
}

/* Power-up Status Bar */
#powerUpStatusBar {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 20px;
    z-index: 100;
    background: rgba(0, 0, 0, 0.5);
    padding: 10px 20px;
    border-radius: 25px;
    backdrop-filter: blur(10px);
}

.powerup-icon {
    position: relative;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.3);
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    transition: all 0.3s ease;
}

.powerup-icon.inactive {
    opacity: 0.3;
    transform: scale(0.9);
}

.powerup-icon.active {
    opacity: 1;
    transform: scale(1.1);
    box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
}

.powerup-symbol {
    font-size: 24px;
    z-index: 2;
    position: relative;
    filter: drop-shadow(0 0 5px rgba(0, 0, 0, 0.8));
}

.powerup-fill {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 0%;
    background: linear-gradient(to top, 
        rgba(76, 175, 80, 0.8) 0%,
        rgba(76, 175, 80, 0.6) 50%,
        rgba(76, 175, 80, 0.4) 100%
    );
    transition: height 0.1s ease-out;
    border-radius: 50%;
}

/* Specific colors for each power-up */
#shieldIcon .powerup-fill {
    background: linear-gradient(to top, 
        rgba(0, 170, 255, 0.8) 0%,
        rgba(0, 170, 255, 0.6) 50%,
        rgba(0, 170, 255, 0.4) 100%
    );
}

#shieldIcon.active {
    border-color: rgba(0, 170, 255, 0.8);
    box-shadow: 0 0 20px rgba(0, 170, 255, 0.6);
}

#multiplierIcon .powerup-fill {
    background: linear-gradient(to top, 
        rgba(255, 215, 0, 0.8) 0%,
        rgba(255, 215, 0, 0.6) 50%,
        rgba(255, 215, 0, 0.4) 100%
    );
}

#multiplierIcon.active {
    border-color: rgba(255, 215, 0, 0.8);
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
}

#magnetIcon .powerup-fill {
    background: linear-gradient(to top, 
        rgba(255, 100, 100, 0.8) 0%,
        rgba(100, 100, 255, 0.6) 50%,
        rgba(255, 100, 100, 0.4) 100%
    );
}

#magnetIcon.active {
    border-color: rgba(255, 100, 100, 0.8);
    box-shadow: 0 0 20px rgba(255, 100, 100, 0.6);
}

/* Character Ability Status */
.ability-icon {
    position: relative;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.3);
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    transition: all 0.3s ease;
}

.ability-icon.ready {
    opacity: 1;
    transform: scale(1.1);
    border-color: rgba(255, 69, 0, 0.8);
    box-shadow: 0 0 20px rgba(255, 69, 0, 0.6);
}

.ability-icon.cooldown {
    opacity: 0.3;
    transform: scale(0.9);
}

.ability-symbol {
    font-size: 24px;
    z-index: 2;
    position: relative;
    filter: drop-shadow(0 0 5px rgba(0, 0, 0, 0.8));
}

.ability-fill {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 0%;
    background: linear-gradient(to top, 
        rgba(255, 69, 0, 0.8) 0%,
        rgba(255, 140, 0, 0.6) 50%,
        rgba(255, 215, 0, 0.4) 100%
    );
    transition: height 0.1s ease-out;
    border-radius: 50%;
}

/* ==================== TITLE SCREEN PARTICLES ==================== */
/* Beautiful floating particle animation for the title screen */

.particle-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    pointer-events: none;
    z-index: 1;
}

.particle {
    position: absolute;
    border-radius: 50%;
    background: linear-gradient(45deg, #00a2ff, #0070f3);
    opacity: 0.6;
    animation: float-up 8s infinite linear;
    box-shadow: 0 0 20px rgba(0, 162, 255, 0.5);
}

.particle:nth-child(odd) {
    background: linear-gradient(45deg, #ff6b6b, #ff8e53);
    box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
    animation-duration: 12s;
}

.particle:nth-child(3n) {
    background: linear-gradient(45deg, #4ecdc4, #44a08d);
    box-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
    animation-duration: 10s;
}

.particle:nth-child(4n) {
    background: linear-gradient(45deg, #ffd93d, #ff8f00);
    box-shadow: 0 0 20px rgba(255, 217, 61, 0.5);
    animation-duration: 14s;
}

.particle:nth-child(5n) {
    background: linear-gradient(45deg, #a8edea, #fed6e3);
    box-shadow: 0 0 20px rgba(168, 237, 234, 0.5);
    animation-duration: 9s;
}

@keyframes float-up {
    0% {
        transform: translateY(100vh) scale(0);
        opacity: 0;
    }
    10% {
        opacity: 0.6;
    }
    90% {
        opacity: 0.6;
    }
    100% {
        transform: translateY(-100vh) scale(1);
        opacity: 0;
    }
}

/* Pulsing title enhancement */
.title-logo {
    animation: title-pulse 3s ease-in-out infinite;
    text-shadow: 0 0 30px rgba(0, 162, 255, 0.8);
}

@keyframes title-pulse {
    0%, 100% {
        transform: scale(1);
        text-shadow: 0 0 30px rgba(0, 162, 255, 0.8);
    }
    50% {
        transform: scale(1.05);
        text-shadow: 0 0 40px rgba(0, 162, 255, 1);
    }
}

/* Enhanced start button */
.start-button {
    transition: all 0.3s ease;
    box-shadow: 0 0 20px rgba(0, 162, 255, 0.3);
}

.start-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 30px rgba(0, 162, 255, 0.5);
}

    </style>
</head>
<body>

<div id="titleScreen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 300; background: linear-gradient(to bottom, #000428, #004e92); overflow: hidden;">
    <!-- Particle Animation Background -->
    <div class="particle-container" id="particleContainer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; pointer-events: none; z-index: 1;"></div>
    
    <!-- Title Canvas for 3D Character Orbits -->
    <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" id="titleCanvas"></div>
    
    <!-- Enhanced title with pulsing animation -->
    <h1 class="title-logo" style="color: white; font-size: 72px; margin-bottom: 20px; text-shadow: 0 0 10px #00a2ff, 0 0 20px #00a2ff; position: relative; z-index: 10; animation: title-pulse 3s ease-in-out infinite;">Running BlitZ</h1>
    

    <!-- Enhanced start button with hover effects -->
    <button id="titleStartButton" class="game-button start-button" style="font-size: 28px; padding: 15px 40px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; position: relative; z-index: 10; animation: pulse 1.5s infinite; transition: all 0.3s ease; box-shadow: 0 0 20px rgba(0, 162, 255, 0.3); width: 240px;">START</button>
    
<!-- Add this AFTER your START button -->
<div id="titleScreenAuth" style="text-align: center; margin: 20px 0; position: relative; z-index: 1000;">
    <!-- Google Sign-In Button (matches START button width) -->
    <button onclick="signInWithGoogle()" id="googleSignInBtn" 
        style="
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 12px auto;
            background: white;
            color: #757575;
            border: 1px solid #dadce0;
            border-radius: 8px;
            padding: 14px 20px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            min-width: 240px;
            width: 240px;
            position: relative;
            z-index: 1001;
        "
        onmouseover="this.style.boxShadow='0 4px 12px rgba(0,0,0,0.2)'; this.style.backgroundColor='#f8f9fa'; this.style.transform='translateY(-1px)';"
        onmouseout="this.style.boxShadow='0 2px 8px rgba(0,0,0,0.15)'; this.style.backgroundColor='white'; this.style.transform='translateY(0)';">
        
        <!-- Google Logo SVG (slightly larger) -->
        <svg width="20" height="20" viewBox="0 0 18 18" style="margin-right: 12px;">
            <path fill="#4285F4" d="M16.51 8H8.98v3h4.3c-.18 1-.74 1.48-1.6 2.04v2.01h2.6a7.8 7.8 0 0 0 2.38-5.88c0-.57-.05-.66-.15-1.18z"/>
            <path fill="#34A853" d="M8.98 17c2.16 0 3.97-.72 5.3-1.94l-2.6-2.04a4.8 4.8 0 0 1-7.18-2.53H1.83v2.07A8 8 0 0 0 8.98 17z"/>
            <path fill="#FBBC05" d="M4.5 10.49a4.8 4.8 0 0 1 0-3.07V5.35H1.83a8 8 0 0 0 0 7.28l2.67-2.14z"/>
            <path fill="#EA4335" d="M8.98 3.58c1.32 0 2.5.45 3.44 1.35l2.54-2.59a7.81 7.81 0 0 0-5.98-2.26 8 8 0 0 0-7.15 4.42l2.67 2.14c.63-1.89 2.39-3.06 4.48-3.06z"/>
        </svg>
        
        Sign in with Google
    </button>
    
            <!-- Subtle subtitle -->
        <p style="
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            margin: 8px 0 0 0;
            font-style: italic;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            font-weight: 300;
        ">
            (for cloud saves across devices!)
</p>
</div>

    <!-- Add this near your existing title screen buttons -->
    <button onclick="showTitleSettings()" class="game-button" 
    style="
        position: absolute;
        top: 20px;
        right: 20px;
        padding: 10px;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        font-size: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2000;
    ">
    ‚öôÔ∏è
</button>

    <style>
        /* Keep your existing pulse animation */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        /* Enhanced title pulse animation */
        @keyframes title-pulse {
            0%, 100% {
                transform: scale(1);
                text-shadow: 0 0 10px #00a2ff, 0 0 20px #00a2ff;
            }
            50% {
                transform: scale(1.02);
                text-shadow: 0 0 15px #00a2ff, 0 0 30px #00a2ff, 0 0 40px #00a2ff;
            }
        }
        
        /* Particle styles */
        .particle {
            position: absolute;
            border-radius: 50%;
            background: linear-gradient(45deg, #00a2ff, #0070f3);
            opacity: 0.6;
            animation: float-up 8s infinite linear;
            box-shadow: 0 0 20px rgba(0, 162, 255, 0.5);
        }

        .particle:nth-child(odd) {
            background: linear-gradient(45deg, #ff6b6b, #ff8e53);
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
            animation-duration: 12s;
        }

        .particle:nth-child(3n) {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
            animation-duration: 10s;
        }

        .particle:nth-child(4n) {
            background: linear-gradient(45deg, #ffd93d, #ff8f00);
            box-shadow: 0 0 20px rgba(255, 217, 61, 0.5);
            animation-duration: 14s;
        }

        .particle:nth-child(5n) {
            background: linear-gradient(45deg, #a8edea, #fed6e3);
            box-shadow: 0 0 20px rgba(168, 237, 234, 0.5);
            animation-duration: 9s;
        }

        @keyframes float-up {
            0% {
                transform: translateY(100vh) scale(0);
                opacity: 0;
            }
            10% {
                opacity: 0.6;
            }
            90% {
                opacity: 0.6;
            }
            100% {
                transform: translateY(-100vh) scale(1);
                opacity: 0;
            }
        }

        /* Enhanced start button hover */
        .start-button:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 10px 30px rgba(76, 175, 80, 0.5);
            background-color: #45a049;
        }

        /* Mobile World Select Optimizations */
@media (max-width: 768px) {
    #worldSelectTitle {
        font-size: 32px !important;
        margin-bottom: 15px !important;
    }
    
    #worldNavigation {
        flex-direction: column !important;
        align-items: center !important;
        gap: 15px !important;
    }
    
    #worldNavigation button {
        font-size: 20px !important;
        padding: 8px 16px !important;
        margin: 0 10px !important;
    }
    
    #worldDisplay {
        width: 85vw !important;
        max-width: 350px !important;
        height: 180px !important;
        margin: 0 !important;
    }
    
    #worldName {
        font-size: 24px !important;
        margin-bottom: 8px !important;
    }
    
    #worldDescription {
        font-size: 16px !important;
        padding: 0 15px !important;
    }
    
    #worldUnlockStatus {
        font-size: 14px !important;
    }
    
    #startGameFromWorldButton {
        font-size: 24px !important;
        padding: 12px 30px !important;
        margin-top: 10px !important;
    }
}

@media (max-width: 480px) {
    #worldSelectTitle {
        font-size: 28px !important;
    }
    
    #worldDisplay {
        width: 90vw !important;
        height: 160px !important;
    }
    
    #worldName {
        font-size: 20px !important;
    }
    
    #worldDescription {
        font-size: 14px !important;
    }
    
    #startGameFromWorldButton {
        font-size: 20px !important;
        padding: 10px 25px !important;
    }
}
    </style>
</div>

<!--------- BUTTONS & UI SECTION--------->
<!--==============================-->
<!--==============================-->



<div id="characterSelectScreen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 300; background: linear-gradient(to bottom, #000428, #004e92);">
    <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" id="characterSelectCanvas"></div>
    <h2 style="color: white; font-size: 48px; margin-bottom: 20px; text-shadow: 0 0 10px #00a2ff, 0 0 20px #00a2ff; position: relative; z-index: 10;">Select Your Character</h2>
    <div style="display: flex; align-items: center; margin-bottom: 30px; position: relative; z-index: 10;">
        <button id="prevCharacterBtn" class="game-button" style="font-size: 24px; padding: 10px 20px; margin-right: 20px;">‚Üê</button>
<div id="characterDisplay" style="width: 200px; height: 200px;"></div>
        <button id="nextCharacterBtn" class="game-button" style="font-size: 24px; padding: 10px 20px; margin-left: 20px;">‚Üí</button>
    </div>
    <div id="characterInfo" style="color: white; text-align: center; margin-bottom: 20px; position: relative; z-index: 10;">
        <h3 id="characterName" style="font-size: 32px; margin-bottom: 10px;">Apple</h3>
        <p id="characterDescription" style="font-size: 18px;">Classic runner</p>
        <p id="characterUnlockStatus" style="font-size: 16px; color: #4CAF50;">Unlocked</p>
    </div>
    <button id="startGameButton" class="game-button" style="font-size: 32px; padding: 15px 50px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; position: relative; z-index: 10; animation: pulse 1.5s infinite;">RUN!</button>
</div>
<!-- World Select Screen -->
<div id="worldSelectScreen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 300; background: linear-gradient(to bottom, #000428, #004e92); padding: 20px; box-sizing: border-box;">
    <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" id="worldSelectCanvas"></div>
    <h2 id="worldSelectTitle" style="color: white; font-size: 48px; margin-bottom: 20px; text-shadow: 0 0 10px #00a2ff, 0 0 20px #00a2ff; position: relative; z-index: 10; text-align: center;">Select Your World</h2>
    <div id="worldNavigation" style="display: flex; align-items: center; margin-bottom: 30px; position: relative; z-index: 10; width: 100%; max-width: 500px; justify-content: center;">
        <button id="prevWorldBtn" class="game-button" style="font-size: 24px; padding: 10px 20px; margin-right: 20px; flex-shrink: 0;">‚Üê</button>
        <div id="worldDisplay" style="width: 300px; height: 200px; max-width: calc(100vw - 140px); background-color: rgba(0, 0, 0, 0.3); border-radius: 15px; display: flex; justify-content: center; align-items: center; box-shadow: 0 0 20px rgba(0, 162, 255, 0.5); position: relative; overflow: hidden;">
            <div id="worldPreview" style="width: 100%; height: 100%; border-radius: 15px;"></div>
        </div>
        <button id="nextWorldBtn" class="game-button" style="font-size: 24px; padding: 10px 20px; margin-left: 20px; flex-shrink: 0;">‚Üí</button>
    </div>
    <div id="worldInfo" style="color: white; text-align: center; margin-bottom: 20px; position: relative; z-index: 10; width: 100%; max-width: 400px;">
        <h3 id="worldName" style="font-size: 32px; margin-bottom: 10px; word-wrap: break-word;">Classic Plains</h3>
        <p id="worldDescription" style="font-size: 18px; word-wrap: break-word; padding: 0 10px;">Rolling green hills and peaceful meadows</p>
        <p id="worldUnlockStatus" style="font-size: 16px; color: #4CAF50;">Unlocked</p>
    </div>
    <button id="startGameFromWorldButton" class="game-button" style="font-size: 32px; padding: 15px 50px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; position: relative; z-index: 10; animation: pulse 1.5s infinite; max-width: calc(100vw - 40px); word-wrap: break-word;">START ADVENTURE!</button>
</div>

<!-- Game Over Screen -->
<div id="score">Score: 0</div>
    <div id="totalCoins">Coins: 0</div>
    <button id="pauseBtn">‚è∏Ô∏è</button>
    <div id="speedIndicator">Speed: 1x</div>
    <div id="gameOver">
    <h2 style="margin-top: 0;">Game Over</h2>
    <span id="finalScore" style="font-size: 24px;"></span><br>
    <span id="coinsCollected" style="font-size: 20px; margin-bottom: 15px; display: inline-block;"></span><br>
    <div id="newHighScoreMessage" style="display: none; color: gold; margin: 10px 0;">
        <div style="margin-bottom: 10px; font-size: 22px;">New High Score!</div>
        <input type="text" id="playerNameInput" placeholder="Enter your name" maxlength="15">
        <button id="saveScoreButton">Save Score</button>
    </div>
    <div class="game-buttons" style="display: flex; flex-direction: column; gap: 10px; width: 100%; max-width: 250px; margin: 0 auto;">
        <button id="restartButton" class="game-button">Restart</button>
        <button id="gameOverCharactersBtn" class="game-button">Characters</button>
        <button id="gameOverSettingsBtn" class="game-button">Settings</button>
    </div>
</div>
    <div id="startScreen">
        <h1>3D Endless Runner</h1>
        <p style="color: white; margin-bottom: 20px;">
            Use ‚Üê ‚Üí to move and ‚Üë or SPACE to jump. Press ‚Üì to drop quickly!<br>
            Press P to pause the game. Jump over streams and avoid obstacles.<br>
            <span id="mobileInstructions" style="display: none;">On mobile, swipe left/right to move, swipe up to jump, and swipe down to drop quickly.</span>
        </p>
        <button id="startButton">Start Game</button>
    </div>

    <!-- Pause Screen -->
    <div id="pauseScreen">
    <h2>Paused</h2>
    <p>Press P or tap to resume</p>
    <div class="game-buttons" style="display: flex; flex-direction: column; gap: 10px; width: 100%; max-width: 250px; margin: 0 auto;">
        <button id="resumeButton" class="game-button">Resume Game</button>
        <button id="pauseRestartButton" class="game-button">Restart</button>
        <button id="pauseCharactersBtn" class="game-button">Characters</button>
        <button id="pauseSettingsBtn" class="game-button">Settings</button>
    </div>
</div>

    <!-- Settings Menu Tabs -->
    <div id="modalOverlay"></div>
<div id="settingsScreen">
    <h2>Settings</h2>
    
    <div class="tab-buttons">
        <button class="tab-button active" data-tab="settings-tab">‚öôÔ∏è Game Settings</button>
        <button class="tab-button" data-tab="leaderboard-tab">üèÜ Leaderboard</button>
        <button class="tab-button" data-tab="global-leaderboard-tab">üåç Global</button>
    </div>
        
        <div id="settings-tab" class="tab-content active">
    <div class="settings-section">
    <h3>Audio Settings</h3>
    <div class="audio-setting-row">
        <span class="audio-label">Sound Effects</span>
        <label class="audio-checkbox">
            <input type="checkbox" id="soundEffectsCheckbox" checked>
            <span class="checkmark"></span>
        </label>
    </div>
    <div class="audio-setting-row">
        <span class="audio-label">Background Music</span>
        <label class="audio-checkbox">
            <input type="checkbox" id="backgroundMusicCheckbox" checked>
            <span class="checkmark"></span>
        </label>
    </div>
</div>

<div class="settings-section">
    <h3>üéµ Jukebox</h3>
    <p style="color: white; font-size: 14px; margin-bottom: 15px; opacity: 0.8;">Choose your soundtrack for the ultimate running experience!</p>
    <div id="jukeboxTracks">
        <!-- Track options will be populated by JavaScript -->
    </div>
    <div style="margin-top: 15px; padding: 10px; background: rgba(255, 255, 255, 0.1); border-radius: 8px;">
        <button id="previewTrackBtn" class="game-button" style="padding: 8px 16px; font-size: 16px; margin-right: 10px;">üéß Preview</button>
        <button id="applyTrackBtn" class="game-button" style="padding: 8px 16px; font-size: 16px;">‚úÖ Apply Track</button>
    </div>
</div>
    
    <div class="settings-section">
        <h3>Mod Options</h3>
        <div class="mod-option" id="mod-mode-option">
            <div class="mod-info">
                <h4>Mod Mode</h4>
                <p>Unlock all content</p>
            <input type="password" class="mod-password" id="modPassword" placeholder="Enter password">
        </div>
        <button class="mod-action" id="modModeButton">Enable</button>
    </div>
    <div class="mod-option" id="difficulty-override-option" style="display: none;">
        <div class="mod-info">
            <h4>Force Difficulty Level</h4>
            <p>Override speed level for testing</p>
            <select id="difficultyOverride" style="padding: 5px; margin: 5px 0; border-radius: 3px; border: none;">
                <option value="-1">Normal (Time-Based)</option>
                <option value="0">Level 1 - Cruise</option>
                <option value="1">Level 2 - Accelerating</option>
                <option value="2">Level 3 - Intense</option>
                <option value="3">Level 4 - Blazing</option>
                <option value="4">Level 5 - Maximum Chaos</option>
            </select>
        </div>
        <button class="mod-action" id="applyDifficultyButton">Apply</button>
    </div>
    <div class="mod-option" id="reset-data-option">
        <div class="mod-info">
            <h4>Reset Game Data</h4>
            <p>Clear all saved progress</p>
        </div>
        <button class="mod-action" id="resetDataButton">Reset</button>
    </div>
</div>
        </div>
        
       
        <!-- LEADERBOARD TAB -->
        <div id="leaderboard-tab" class="tab-content">
            <div class="settings-section">
                <h3>Top Scores</h3>
                <table class="leaderboard-table">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Name</th>
                            <th>Score</th>
                            <th>Date</th>
                        </tr>
                    </thead>
                    <tbody id="leaderboardBody">
                        <!-- Leaderboard entries will be added here -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- GLOBAL LEADERBOARD TAB -->
<div id="global-leaderboard-tab" class="tab-content">
    <div class="settings-section">
        <h3>üåç Global Leaderboard</h3>
        <table class="leaderboard-table">
            <thead>
                <tr>
                    <th>Rank</th>
                    <th>Player</th>
                    <th>Score</th>
                    <th>Character</th>
                </tr>
            </thead>
            <tbody id="globalLeaderboardBody">
                <!-- Global leaderboard entries will be added here -->
            </tbody>
        </table>
        
        <div style="text-align: center; margin-top: 15px;">
            <p id="globalPlayerRank" style="color: #FFD700; font-size: 14px; margin: 10px 0;"></p>
            <button onclick="updateGlobalLeaderboardDisplay()" class="game-button" 
                style="padding: 8px 16px; font-size: 14px; background: #4CAF50;">
                üîÑ Refresh Global Scores
            </button>
        </div>
    </div>
</div>

        <button id="closeSettingsButton">Close</button>
    </div>
    <div id="touchArea"></div>
    <div id="swipeInstructions">Swipe ‚Üê ‚Üí to move ‚Ä¢ Swipe ‚Üë to jump ‚Ä¢ Swipe ‚Üì to drop</div>

<!-- Power-up Status Bar -->
<div id="powerUpStatusBar">
    <div class="powerup-icon" id="shieldIcon">
        <div class="powerup-symbol">üõ°Ô∏è</div>
        <div class="powerup-fill"></div>
    </div>
    <div class="powerup-icon" id="multiplierIcon">
        <div class="powerup-symbol">üí∞</div>
        <div class="powerup-fill"></div>
    </div>
    <div class="powerup-icon" id="magnetIcon">
        <div class="powerup-symbol">üß≤</div>
        <div class="powerup-fill"></div>
    </div>
    <!-- Character Ability Icon (hidden by default) -->
    <div class="powerup-icon ability-icon" id="characterAbilityIcon" style="display: none;">
        <div class="powerup-symbol ability-symbol">üî•</div>
        <div class="powerup-fill ability-fill"></div>
    </div>
</div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

<!-- Character System - New Modular Approach -->
<script src="characters/shared.js"></script>
<script src="characters/installed/happyface.js"></script>
<script src="characters/installed/ghost.js"></script>
<script src="characters/installed/robot.js"></script>
<script src="characters/installed/dragon.js"></script>
<script src="characters/installed/ufo.js"></script>
<script src="characters/installed/atom.js"></script>
<script src="characters/installed/slime.js"></script>
<script src="characters/installed/apple.js"></script>
<script src="characters/installed/carrot.js"></script>
<script src="characters/installed/pumpkin.js"></script>
<script src="characters/installed/monster.js"></script>
<script src="characters/installed/creature.js"></script>
<!-- CHARACTER INJECTION POINT - Additional characters will be loaded here -->
<script src="worlds/forest.js"></script>
<script src="worlds/desert.js"></script>
<script src="systems/obstacles.js"></script>
<script src="systems/audio.js"></script>
<script src="systems/powerups.js"></script>



    <script>

// Game variables
        let scene, camera, renderer, player, obstacles = [], coins = [], ground;
        let waterStreams = [];
        let rareCoins = []; // Array for rare gradient coins
        let powerUps = []; // Array for power-ups
        let activePowerUps = {}; // Track active power-ups
        let powerUpTimers = {}; // Track power-up durations
        let explosionParticles = [];
        let sparkleParticles = [];
        let sceneryObjects = [];
        let meteors = []; // Array to store falling meteors
        let meteorSpawnCounter = 0; // Counter for meteor spawning
        let meteorSpawnRate = 600; // Frames between meteor spawns (much slower - about every 20 seconds)
        let score = 0;
        let totalCoins = 0;
        let gameStarted = false;
        let gameOver = false;
        let gamePaused = false;
        let playerSpeed = 0.2;

// Power-up states
let shieldActive = false;
let coinMultiplierActive = false;
let magnetActive = false;
let powerUpSpawnRate = 1200; // Power-ups spawn every 20 seconds (1200 frames at 60fps)

// Character ability states
let robotShieldActive = false;
let robotShieldCooldown = 0;
let dragonFireActive = false;
let dragonFireCooldown = 0;
let ghostPhaseActive = false;
let ghostPhaseCharges = 0;
let ghostPhaseCooldown = 0;


        
        // Dynamic difficulty variables (time-based)
        let baseSpeed = 0.25;                    // Starting speed
        let currentSpeed = 0.25;                 // Current game speed
        let maxSpeed = 0.65;                     // Maximum speed cap (increased for 4th level)
        let speedIncrement = 0.1;                // Speed increase per interval
        let currentSpeedMultiplier = 1.0;        // Visual speed indicator
        
        // Time-based speed progression
        let gameStartTime = 0;                   // When the game started
        let speedIncreaseIntervals = [20000, 50000, 100000, 160000]; // 20s, 50s more, 50s more, 60s more (in milliseconds)
        let currentSpeedLevel = 0;               // Which speed level we're at
        
        // Spawn rate variables - start with more obstacles, get more frequent with speed
        let baseObstacleSpawnRate = 80;          // Starting frames between obstacles (more frequent)
        let currentObstacleSpawnRate = 80;       // Current spawn rate
        let minObstacleSpawnRate = 40;           // Minimum spawn rate (very frequent)
        
        let baseStreamSpawnRate = 800;           // Starting frames between streams (very rare)
        let currentStreamSpawnRate = 800;        // Current stream spawn rate
        let minStreamSpawnRate = 500;            // Minimum stream spawn rate (still rare)
        
        let streamSpawnCounter = 0;              // Counter for tracking when to force spawn a stream
        let forcedStreamInterval = 800;          // Force spawn a stream after this many frames (rare)
        let coinSpawnRate = 40;                  // Frames between coin spawns (stays constant)
        let scenerySpawnRate = 25;               // Frames between scenery spawns (stays constant)
        
        let frameCount = 0;
        let lanes = [-2, 0, 2]; // Left, center, right
        let currentLane = 1; // Start in center (index 1)
        let jumping = false;
        let playerY = 0.5; // Player's base Y position (height is 1)
        let jumpHeight = 2;
        let jumpSpeed = 0.1;
        let jumpDirection = 1; // 1 = up, -1 = down
        let jumpRotation = 0; // For front flip animation
        let distanceTraveled = 0;
        let isMobile = false; // Flag for mobile device detection
        let groundSegments = []; // Store ground segments for texture updates
let sideTerrainSegments = []; // Store side terrain segments for movement
        let groundIndex = 0; // Index for tracking ground segments
        let streamCreated = false; // Flag to track if a stream was created on this frame
        
        // Leaderboard variables
        let leaderboard = [];
        let currentHighScore = 0;
        let pendingScore = 0;
        const MAX_LEADERBOARD_ENTRIES = 10;
        
        // Weather and environment variables
        let skyLight;
        let weatherParticles = [];
        let currentWeather = "clear"; // clear, rain, snow
        let targetWeather = "clear"; // For smooth transitions
        let weatherChangeCounter = 0;
        let weatherChangeDuration = 1800; // Frames until weather change (1 minute at 30fps)
        let weatherTransitionProgress = 0; // For smooth transitions
        let time = 0; // Time of day (0-1), 0 = day, 0.5 = sunset, 1 = night
        let timeCycleSpeed = 0.0001; // How fast time cycles
        let butterflyGroups = [];
        let birds = [];
        let currentSkyColor = new THREE.Color(0x87CEEB); // Starting sky color
        let targetSkyColor = new THREE.Color(0x87CEEB); // Target sky color for transitions

// Game state variables (simplified - no title character models needed)
let gameState = "title"; // title, characterSelect, playing, paused, gameOver
let titleCharacterModels = []; // Store character models for the title screen
let characterSelectModels = []; // Store character models for the selection screen
let selectedCharacterIndex = 0; // Index of the currently selected character
let characterNames = [
    // CHARACTER ROSTER INJECTION POINT - Package manager will modify this array
    "apple", "carrot", "pumpkin", "happyface", "monster", "atom", "slime", "ufo", "robot", "dragon", "ghost", "creature"
    // END CHARACTER ROSTER INJECTION POINT
];

// ==================== DEBUG SYSTEM ====================
// Control all console logging from one place
let DEBUG_MODE = false; // Set to true only when debugging

function debug(message, ...args) {
    if (DEBUG_MODE) {
        debug(message, ...args);
    }
}

function debugWarn(message, ...args) {
    if (DEBUG_MODE) {
        debugWarn(message, ...args);
    }
}

function debugError(message, ...args) {
    // Always show errors
    console.error(message, ...args);
}

// World system variables
let currentWorld = "classic";
let selectedWorldIndex = 0;
let worldNames = ["classic"];
let unlockedWorlds = {
    classic: true
};
let worldCosts = {};

// World definitions
let availableWorlds = [
    {
        id: 'classic',
        name: 'Classic Plains',
        description: 'Rolling green hills and peaceful meadows',
        cost: 0,
        colors: {
            sky: 0x87CEEB,
            fog: 0xB0E0E6,
            ground: 0x4CAF50
        },
        lighting: {
            ambient: { color: 0xffffff, intensity: 0.6 },
            directional: { color: 0xffffff, intensity: 0.8 }
        }
    },
    {
        id: 'forest',
        name: 'Enchanted Forest',
        description: 'Mystical woodland with towering trees and magical creatures',
        cost: 5000,
        colors: {
            sky: 0x228B22,
            fog: 0x90EE90,
            ground: 0x2F4F2F
        },
        lighting: {
            ambient: { color: 0x404040, intensity: 0.4 },
            directional: { color: 0xFFFFE0, intensity: 0.6 }
        }
    },
    {
        id: 'desert',
        name: 'Desert Mirage',
        description: 'Scorching sand dunes with mysterious mirages and ancient secrets',
        cost: 10000,
        colors: {
            sky: 0xFFE4B5,
            fog: 0xDEB887,
            ground: 0xF4A460
        },
        lighting: {
            ambient: { color: 0xFFE4B5, intensity: 0.7 },
            directional: { color: 0xFFF8DC, intensity: 1.0 }
        }
    }
];

let worldSelectModels = [];
let worldSelectScene, worldSelectCamera, worldSelectRenderer;


        
        // Mod mode variables
let modModeEnabled = false;
const MOD_PASSWORD = "5050";
let difficultyOverride = -1; // -1 = normal, 0-4 = force specific level

// Audio control variables
let soundEffectsEnabled = true;
let backgroundMusicEnabled = true;

// Jukebox system variables
let availableTracks = [
    { id: 'medieval', name: 'The Throne', description: 'Epic fantasy adventure music' },
    { id: 'electronic', name: 'Cybershock', description: 'Futuristic electronic beats' },
    { id: 'ambient', name: 'Field of Memories', description: 'Dreamy ethereal lofi vibes' }
];
let currentTrack = 'ambient'; // Default to ambient music
let selectedTrack = 'ambient'; // Track selected in jukebox

// Object pools for performance optimization
let sparklePool = [];
let explosionPool = [];
let poolSize = 50; // Maximum pooled objects

// ==================== OBJECT POOL SYSTEM ====================
// Performance optimization - pre-created objects for reuse
// Dependencies: None
// Functions: initializeObjectPools(), getSparkleFromPool(), returnSparkleToPool(), etc.

// Shared materials for performance
const SharedMaterials = {
    coin: null,
    coinEdge: null,
    obstacle: null,
    
    init() {
        this.coin = new THREE.MeshStandardMaterial({ 
            color: 0xFFD700,
            metalness: 1.0,
            roughness: 0.05,
            emissive: 0xFFD700,
            emissiveIntensity: 0.4
        });
        
        this.coinEdge = new THREE.MeshStandardMaterial({ 
            color: 0xFFD700,
            metalness: 1.0, 
            roughness: 0.03,
            emissive: 0xFFD700,
            emissiveIntensity: 0.3
        });
        
        this.obstacle = new THREE.MeshStandardMaterial({
            color: 0xff0000,
            roughness: 0.8
        });
    }
};

// Initialize shared materials
SharedMaterials.init();

// Initialize object pools
function initializeObjectPools() {
    // Pre-create sparkle particles
    for (let i = 0; i < poolSize; i++) {
        const sparkleGeometry = new THREE.SphereGeometry(0.05, 8, 8);
        const sparkleMaterial = new THREE.MeshStandardMaterial({
            color: 0xFFD700,
            emissive: 0xFFFFFF,
            emissiveIntensity: 1,
            transparent: true,
            opacity: 0
        });
        const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
        sparkle.visible = false;
        sparklePool.push(sparkle);
    }
    
    // Pre-create explosion particles
    for (let i = 0; i < poolSize; i++) {
        const explosionGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const explosionMaterial = new THREE.MeshStandardMaterial({
            color: 0xff0000,
            emissive: 0xff0000,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0
        });
        const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
        explosion.visible = false;
        explosionPool.push(explosion);
    }
}

// Coin pool for performance
let coinPool = [];
let coinPoolSize = 20;

function initializeCoinPool() {
    for (let i = 0; i < coinPoolSize; i++) {
        const coin = createCoinObject();
        coin.visible = false;
        coinPool.push(coin);
    }
}

function getCoinFromPool() {
    for (let i = 0; i < coinPool.length; i++) {
        if (!coinPool[i].visible) {
            coinPool[i].visible = true;
            return coinPool[i];
        }
    }
    // Pool exhausted, create new coin
    return createCoinObject();
}

function returnCoinToPool(coin) {
    coin.visible = false;
    coin.position.set(0, 0, -100);
    coin.rotation.set(0, 0, 0);
}

// Get sparkle from pool
function getSparkleFromPool() {
    for (let i = 0; i < sparklePool.length; i++) {
        if (!sparklePool[i].visible) {
            return sparklePool[i];
        }
    }
    return null; // Pool exhausted
}

// Return sparkle to pool
function returnSparkleToPool(sparkle) {
    sparkle.visible = false;
    sparkle.material.opacity = 0;
    sparkle.scale.set(1, 1, 1);
    sparkle.position.set(0, 0, 0);
    if (sparkle.userData) {
        sparkle.userData.age = 0;
        sparkle.userData.lifespan = 0;
    }
}

// Get explosion particle from pool
function getExplosionFromPool() {
    for (let i = 0; i < explosionPool.length; i++) {
        if (!explosionPool[i].visible) {
            return explosionPool[i];
        }
    }
    return null; // Pool exhausted
}

// Return explosion particle to pool
function returnExplosionToPool(explosion) {
    explosion.visible = false;
    explosion.material.opacity = 0;
    explosion.scale.set(1, 1, 1);
    explosion.position.set(0, 0, 0);
    if (explosion.userData) {
        explosion.userData.age = 0;
        explosion.userData.lifespan = 0;
    }
}

// Collision boundary cache for performance
let collisionCache = new Map();
let cacheUpdateThreshold = 0.5; // Update cache if object moved more than this distance

// Get cached or calculate collision boundary
function getCachedCollisionBox(object) {
    const objectId = object.uuid;
    const currentPos = object.position.clone();
    
    // Check if we have cached data
    if (collisionCache.has(objectId)) {
        const cached = collisionCache.get(objectId);
        const distance = cached.lastPosition.distanceTo(currentPos);
        
        // If object hasn't moved much, use cached boundary
        if (distance < cacheUpdateThreshold) {
            // Update the cached box position without recalculating
            const offset = new THREE.Vector3().subVectors(currentPos, cached.lastPosition);
            cached.boundingBox.translate(offset);
            cached.lastPosition = currentPos;
            return cached.boundingBox.clone();
        }
    }
    
    // Calculate new bounding box
    const boundingBox = new THREE.Box3().setFromObject(object);
    
    // Cache it
    collisionCache.set(objectId, {
        boundingBox: boundingBox.clone(),
        lastPosition: currentPos
    });
    
    return boundingBox;
}

// Clean up collision cache for removed objects
function cleanupCollisionCache(objectsArray, cacheKey) {
    const activeIds = new Set(objectsArray.map(obj => obj.uuid));
    for (const [id, cached] of collisionCache.entries()) {
        if (id.startsWith(cacheKey) && !activeIds.has(id)) {
            collisionCache.delete(id);
        }
    }
}

// Simplified distance-based collision for coins and power-ups
function checkSimpleCollision(object, player, threshold = 1.5) {
    return object.position.distanceTo(player.position) < threshold;
}
        
        // Character variables
        let currentCharacter = "happyface";
        let unlockedCharacters = {
    apple: true,
    carrot: false,
    pumpkin: false,
    happyface: false,
    monster: false,
    atom: false,
    slime: false,
    ufo: false,
    robot: false,
    dragon: false,
    ghost: false,
    creature: false
};
        let characterCosts = {
    carrot: 200,
    pumpkin: 500,
    happyface: 1000,
    monster: 5000,
    atom: 10000,
    slime: 15000,
    ufo: 20000,
    robot: 25000,
    dragon: 30000,
    ghost: 40000,
    creature: 50000
};
        
        // Touch/swipe variables
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;
        let swipeThreshold = 40; // Reduced threshold for easier swipe detection
        let jumpSwipeThreshold = 30; // Even lower threshold for jump
        
        // Textures
        let grassTexture;
        let waterTexture;
        
        // Time-based difficulty adjustment function
        function updateDynamicDifficulty() {
            // Check if we should increase speed based on time
            const currentTime = Date.now();
            const gameTime = currentTime - gameStartTime;
            
            // Check if we're using difficulty override
if (difficultyOverride >= 0) {
    // Use the forced difficulty level
    currentSpeedLevel = difficultyOverride;
} else {
    // Use normal time-based progression
    // Check each speed interval
    for (let i = currentSpeedLevel; i < speedIncreaseIntervals.length; i++) {
        if (gameTime >= speedIncreaseIntervals[i]) {
            // Time to increase speed!
            currentSpeedLevel = i + 1;
                    currentSpeed = Math.min(baseSpeed + (currentSpeedLevel * speedIncrement), maxSpeed);
                    
                    // Adjust obstacle spawn rates - more aggressive at higher speeds
let speedProgress = currentSpeedLevel / speedIncreaseIntervals.length;

// Make the progression more dramatic for higher speeds
if (currentSpeedLevel >= 3) {
    // At level 3 and 4, make it much more intense
    speedProgress = 0.7 + (currentSpeedLevel - 3) * 0.15; // 0.7, 0.85, 1.0+
}

currentObstacleSpawnRate = Math.floor(Math.max(
    baseObstacleSpawnRate - (speedProgress * (baseObstacleSpawnRate - minObstacleSpawnRate)),
    currentSpeedLevel >= 4 ? 25 : minObstacleSpawnRate // Even more frequent at max level
));
                    
                    // Adjust stream spawn rate - reduce streams at higher speeds since obstacles are more frequent
if (currentSpeedLevel >= 3) {
    // At high speeds, reduce streams since obstacles are much more frequent
    currentStreamSpawnRate = Math.floor(baseStreamSpawnRate * 1.2);
} else {
    currentStreamSpawnRate = Math.floor(Math.max(
        baseStreamSpawnRate - (speedProgress * 0.2 * (baseStreamSpawnRate - minStreamSpawnRate)),
        minStreamSpawnRate
    ));
}
                    
                    // Update speed multiplier for display
                    currentSpeedMultiplier = currentSpeed / baseSpeed;
                    updateSpeedIndicator();
                    
                    // Debug log to see what's happening
                    debug(`Speed Level: ${currentSpeedLevel}, Speed: ${currentSpeed.toFixed(2)}, Obstacle Rate: ${currentObstacleSpawnRate}, Stream Rate: ${currentStreamSpawnRate}`);
                }
            }
        }
    } // Close the else statement for normal progression
        
        // Update speed indicator display with dynamic theming
function updateSpeedIndicator() {
    const speedIndicator = document.getElementById('speedIndicator');
    
    // Remove all existing speed level classes
    speedIndicator.className = '';
    
    // Apply visual theme based on speed level
    if (currentSpeedLevel === 0) {
        speedIndicator.classList.add('speed-level-1');
    } else if (currentSpeedLevel === 1) {
        speedIndicator.classList.add('speed-level-2');
    } else if (currentSpeedLevel === 2) {
        speedIndicator.classList.add('speed-level-3');
    } else if (currentSpeedLevel === 3) {
        speedIndicator.classList.add('speed-level-4');
    } else if (currentSpeedLevel >= 4) {
        speedIndicator.classList.add('speed-level-5');
    }
    
    // Show only the level names
    let levelText = '';
    if (currentSpeedLevel === 0) {
        levelText = 'CRUISE';
    } else if (currentSpeedLevel === 1) {
        levelText = 'ACCELERATING';
    } else if (currentSpeedLevel === 2) {
        levelText = 'INTENSE';
    } else if (currentSpeedLevel === 3) {
        levelText = 'BLAZING';
    } else if (currentSpeedLevel >= 4) {
        levelText = 'MAXIMUM CHAOS';
    }
    
    // Set only the level name without speed multiplier
    speedIndicator.textContent = levelText;
    
    // Ensure consistent font size for all levels
    speedIndicator.style.fontSize = '18px';
}
        
        // Reset difficulty to starting values
        function resetDynamicDifficulty() {
            gameStartTime = Date.now(); // Reset the timer
            currentSpeedLevel = 0;      // Reset speed level
            currentSpeed = baseSpeed;
            currentObstacleSpawnRate = baseObstacleSpawnRate;
            currentStreamSpawnRate = baseStreamSpawnRate;
            currentSpeedMultiplier = 1.0;
            streamSpawnCounter = 0;
            streamCreated = false;
            updateSpeedIndicator();
            
            // Debug log to confirm reset
            debug(`Game Reset - Speed: ${currentSpeed}, Obstacle Rate: ${currentObstacleSpawnRate}, Stream Rate: ${currentStreamSpawnRate}`);
        }
        
        // Check if it's a mobile device
        function checkMobile() {
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (isMobile) {
                // Show mobile instructions
                document.getElementById('mobileInstructions').style.display = 'inline';
                document.getElementById('touchArea').style.display = 'block';
                document.getElementById('swipeInstructions').style.display = 'block';
                
                // Adjust jump threshold based on screen size for better responsiveness
                const screenHeight = window.innerHeight;
                jumpSwipeThreshold = Math.max(20, Math.min(30, screenHeight / 40));
                swipeThreshold = Math.max(30, Math.min(40, screenHeight / 30));
            }
        }

// Mobile performance settings - define after checkMobile() is called
        let mobileSparkleCount = isMobile ? 8 : 20;        // Fewer sparkles on mobile
        let mobileExplosionCount = isMobile ? 15 : 30;     // Fewer explosion particles
        let mobileWeatherCount = isMobile ? 150 : 500;     // Much fewer weather particles
        let mobileButterflyLimit = isMobile ? 3 : 10;      // Fewer butterflies
        let mobileBirdsLimit = isMobile ? 2 : 5;           // Fewer birds


// ==================== MOBILE CONTROLS ====================
// Touch controls, swipe gestures, and mobile input handling
// Dependencies: Game Loop, Player Controls
// Functions: setupMobileControls(), handleTouch(), etc.

        
        // Setup mobile touch controls with swipe gestures
        function setupMobileControls() {
            const touchArea = document.getElementById('touchArea');
            
            // Simplified swipe detection to prevent freezing
            let lastTouchY = 0;
            
            touchArea.addEventListener('touchstart', function(e) {
                if (!gameStarted || gameOver || gamePaused) return;
                
                e.preventDefault();
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                lastTouchY = touchStartY;
                touchStartTime = Date.now();
            });
            
            touchArea.addEventListener('touchend', function(e) {
                if (!gameStarted || gameOver || gamePaused) return;
                
                e.preventDefault();
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                const touchTime = Date.now() - touchStartTime;
                
                // Simple, reliable swipe detection
                if (touchTime < 300) { // Short swipe = faster response
                    const deltaX = touchEndX - touchStartX;
                    const deltaY = touchStartY - touchEndY; // Note: reversed for Y
                    
                    // Simple thresholds
                    const minSwipeDistance = 30;
                    
                    // Determine primary direction of swipe
                    if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > minSwipeDistance) {
                        // Horizontal swipe
                        if (deltaX > 0) {
                            moveRight();
                        } else {
                            moveLeft();
                        }
                    } 
                    else if (Math.abs(deltaY) > Math.abs(deltaX) && Math.abs(deltaY) > minSwipeDistance) {
                        // Vertical swipe
                        if (deltaY > 0 && !jumping) {
                            // Swipe up to jump (only if not already jumping)
                            jump();
                        } else if (deltaY < 0) {
                            // Swipe down to quick drop
                            quickDrop();
                        }
                    }
                }
            });
        }
        
// ==================== GAME INITIALIZATION ====================
// Core game setup and initialization functions
// Dependencies: THREE.js, Audio System, Object Pools
// Functions: init(), setupGame(), initializeGameElements(), etc.

        // Initialize the game
        function init() {
            // Check if it's a mobile device FIRST
            checkMobile();

// Initialize audio system
    initializeAudio();

// Background music system
let backgroundMusic = null;
let musicPlaying = false;
let musicLayers = [];
let currentMusicIntensity = 0;
let targetMusicIntensity = 0;

    // Set initial game state
    gameState = "title";
    
    // Hide the original start screen
    document.getElementById('startScreen').style.display = 'none';
    
    // Show the title screen
document.getElementById('titleScreen').style.display = 'flex';
debug('Title screen should be visible now'); // Debug log

// Initialize the title screen
initTitleScreen();
debug('Title screen initialized'); // Debug log
            
            // Initialize new save system
initializeSaveSystem();

// Initialize world system
selectedWorldIndex = availableWorlds.findIndex(w => w.id === currentWorld);
if (selectedWorldIndex === -1) selectedWorldIndex = 0;

// Legacy: Load leaderboard data (will be migrated to profiles)
loadLeaderboard();

// Initialize object pools for performance
initializeObjectPools();
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue background
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 5);
            camera.lookAt(0, 0, -10);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            skyLight = new THREE.DirectionalLight(0xffffff, 0.8);
            skyLight.position.set(10, 20, 0);
            scene.add(skyLight);
            
            // Load textures
            loadTextures();
            
            // Create ground with grass texture
            createGround();
            
            // Create background scenery
            createBackground();
            
            // Create player based on selected character
            createPlayer();
            
            // Add weather systems
            initializeWeatherSystems();
            
            // Initialize dynamic difficulty
            resetDynamicDifficulty();
            
            // Add event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);
            
            // Setup click outside to close settings
            document.getElementById('modalOverlay').addEventListener('click', closeSettingsScreen);
            
            // Setup tab switching in settings
            document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', function() {
                    // Remove active class from all tabs
                    document.querySelectorAll('.tab-button').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    
                    // Add active class to clicked tab
                    this.classList.add('active');
                    const tabId = this.getAttribute('data-tab');
                    document.getElementById(tabId).classList.add('active');
                });
            });
            
            // Update leaderboard display
            updateLeaderboardDisplay();
            
            

            // Setup settings UI
            setupSettingsUI();
            
            // Use onclick instead of addEventListener for more reliability
            document.getElementById('startButton').onclick = startGame;
            document.getElementById('restartButton').onclick = restartGame;
            document.getElementById('gameOverCharactersBtn').onclick = showCharacterSelectScreen;
            document.getElementById('gameOverSettingsBtn').onclick = toggleSettingsFromGameOver;
            document.getElementById('resumeButton').onclick = togglePause;
            document.getElementById('pauseRestartButton').onclick = restartFromPause;
            document.getElementById('pauseCharactersBtn').onclick = showCharacterSelectScreenFromPause;
            document.getElementById('pauseSettingsBtn').onclick = toggleSettingsFromPause;
            document.getElementById('pauseBtn').onclick = togglePause;
            document.getElementById('closeSettingsButton').onclick = closeSettingsScreen;
            document.getElementById('modModeButton').onclick = toggleModMode;
            document.getElementById('resetDataButton').onclick = resetGameData;
            document.getElementById('saveScoreButton').onclick = saveHighScore;
            document.getElementById('applyDifficultyButton').onclick = applyDifficultyOverride;

document.getElementById('soundEffectsCheckbox').addEventListener('change', function() {
    soundEffectsEnabled = this.checked;
    saveGameData('settings_change');
});



document.getElementById('backgroundMusicCheckbox').addEventListener('change', function() {
    backgroundMusicEnabled = this.checked;
    if (!backgroundMusicEnabled && musicPlaying) {
        stopBackgroundMusic();
    } else if (backgroundMusicEnabled && gameStarted && !gameOver && !gamePaused) {
        if (!backgroundMusic) {
            createBackgroundMusic();
        }
        startBackgroundMusic();
    }
    saveGameData('settings_change');
});
            
            // Add mobile touch controls if needed
            if (isMobile) {
                setupMobileControls();
            }
            
            // Update the total coins display
            updateTotalCoins();

            
            // Start animation loop
            animate();
        }
        
// ==================== SETTINGS & UI SYSTEM ====================
// Settings menu, UI controls, and user interface management
// Dependencies: Character System, World System
// Functions: setupSettingsUI(), updateCharactersInSettings(), toggleSettings(), etc.

        // Setup settings UI
        function setupSettingsUI() {
// Initialize jukebox
    initializeJukebox();

            // Update mod mode UI
if (modModeEnabled) {
    document.getElementById('mod-mode-option').classList.add('enabled');
    document.getElementById('modModeButton').textContent = 'Disable';
    
    // Show difficulty override option since mod mode is active
    const difficultyOption = document.getElementById('difficulty-override-option');
    if (difficultyOption) {
        difficultyOption.style.display = 'flex';
    }
} else {
    document.getElementById('mod-mode-option').classList.remove('enabled');
    document.getElementById('modModeButton').textContent = 'Enable';
    
    // Hide difficulty override option since mod mode is inactive
    const difficultyOption = document.getElementById('difficulty-override-option');
    if (difficultyOption) {
        difficultyOption.style.display = 'none';
    }
}
        }

        // Initialize jukebox system
function initializeJukebox() {
    const jukeboxContainer = document.getElementById('jukeboxTracks');
    
    // Clear existing tracks
    jukeboxContainer.innerHTML = '';
    
    // Create track options
    availableTracks.forEach(track => {
        const trackElement = document.createElement('div');
        trackElement.className = 'track-option';
        trackElement.dataset.trackId = track.id;
        
        // Add selected class if this is the current track
        if (track.id === selectedTrack) {
            trackElement.classList.add('selected');
        }
        
        // Set track icon based on type
        let trackIcon = 'üéµ';
        if (track.id === 'medieval') trackIcon = '‚öîÔ∏è';
        else if (track.id === 'electronic') trackIcon = 'üåà';
        else if (track.id === 'ambient') trackIcon = 'üåå';
        
        trackElement.innerHTML = `
            <div class="track-icon">${trackIcon}</div>
            <div class="track-info">
                <div class="track-name">${track.name}</div>
                <div class="track-description">${track.description}</div>
            </div>
            <div class="track-status ${track.id === currentTrack ? 'track-playing' : (track.id === selectedTrack ? 'track-selected' : '')}" id="status-${track.id}">
                ${track.id === currentTrack ? 'Playing' : (track.id === selectedTrack ? 'Selected' : '')}
            </div>
        `;
        
        // Add click listener
        trackElement.addEventListener('click', () => selectTrack(track.id));
        
        jukeboxContainer.appendChild(trackElement);
    });
    
    // Add button listeners
    document.getElementById('previewTrackBtn').addEventListener('click', previewSelectedTrack);
    document.getElementById('applyTrackBtn').addEventListener('click', applySelectedTrack);
    
    debug('üéµ Jukebox system initialized!');
}

// Select a track in the jukebox
function selectTrack(trackId) {
    selectedTrack = trackId;
    
    // Update UI
    document.querySelectorAll('.track-option').forEach(option => {
        option.classList.remove('selected');
        const status = option.querySelector('.track-status');
        if (option.dataset.trackId === currentTrack) {
            status.textContent = 'Playing';
            status.className = 'track-status track-playing';
        } else if (option.dataset.trackId === selectedTrack) {
            status.textContent = 'Selected';
            status.className = 'track-status track-selected';
        } else {
            status.textContent = '';
            status.className = 'track-status';
        }
    });
    
    // Add selected class to clicked track
    document.querySelector(`[data-track-id="${trackId}"]`).classList.add('selected');
    
    debug(`üéµ Selected track: ${trackId}`);
}

// Preview the selected track
// Preview the selected track
function previewSelectedTrack() {
    debug(`üéß Previewing track: ${selectedTrack}`);
    
    // Stop any existing preview
    if (window.previewMusic && window.previewMusic.playing) {
        stopPreview();
    }
    
    // Don't preview if it's already the current track
    if (selectedTrack === currentTrack && musicPlaying) {
        debug('üéµ Track already playing - no preview needed!');
        alert(`üéµ "${availableTracks.find(t => t.id === selectedTrack)?.name}" is already playing!`);
        return;
    }
    
    // Create and start preview
    startPreview(selectedTrack);
    
    // Update button text to show preview is playing
    const previewBtn = document.getElementById('previewTrackBtn');
    previewBtn.textContent = '‚èπÔ∏è Stop Preview';
    previewBtn.onclick = stopPreview;
    
    // Auto-stop preview after 15 seconds
    if (window.previewTimeout) {
        clearTimeout(window.previewTimeout);
    }
    window.previewTimeout = setTimeout(() => {
        stopPreview();
    }, 15000); // 15 second preview
}

// Start preview of a specific track
function startPreview(trackId) {
    if (!audioInitialized) {
        alert('üîá Audio not ready yet! Try clicking the start button first.');
        return;
    }
    
    try {
        debug(`üéß Starting preview of: ${trackId}`);
        
        // Create preview music layers
        window.previewMusic = {
            layers: [],
            playing: true,
            trackId: trackId
        };
        
        // Create preview music based on track
        if (trackId === 'medieval') {
            createPreviewMedieval();
        } else if (trackId === 'electronic') {
            createPreviewElectronic();
        } else if (trackId === 'ambient') {
            createPreviewAmbient();
        }
        
        // Start all preview patterns
        window.previewMusic.layers.forEach(layer => {
            if (layer.pattern) {
                layer.pattern.start(0);
            }
        });
        
        // Start transport if not already running
        if (Tone.Transport.state !== 'started') {
            Tone.Transport.start();
        }
        
        debug(`‚úÖ Preview started for: ${availableTracks.find(t => t.id === trackId)?.name}`);
        
    } catch (error) {
        console.error('‚ùå Error starting preview:', error);
        alert('‚ùå Error starting preview! Check console for details.');
    }
}

// Stop preview
function stopPreview() {
    debug('üõë Stopping preview...');
    
    if (window.previewMusic && window.previewMusic.layers) {
        // Stop and dispose all preview patterns
        window.previewMusic.layers.forEach(layer => {
            if (layer.pattern) {
                layer.pattern.stop();
                layer.pattern.dispose();
            }
            if (layer.synth && layer.synth.dispose) {
                layer.synth.dispose();
            }
        });
        
        window.previewMusic = null;
    }
    
    // Clear timeout
    if (window.previewTimeout) {
        clearTimeout(window.previewTimeout);
        window.previewTimeout = null;
    }
    
    // Reset button
    const previewBtn = document.getElementById('previewTrackBtn');
    previewBtn.textContent = 'üéß Preview';
    previewBtn.onclick = previewSelectedTrack;
    
    debug('‚úÖ Preview stopped');
}

// Preview versions of each track (shorter, simpler versions)
function createPreviewMedieval() {
    debug('üéß Creating medieval preview...');
    
    // Just drums and lute for preview
    const drumSynth = new Tone.MembraneSynth({
        pitchDecay: 0.08,
        octaves: 12,
        oscillator: { type: "sine" },
        envelope: { attack: 0.01, decay: 0.6, sustain: 0.1, release: 2.0 }
    }).toDestination();
    
    const drumPattern = new Tone.Pattern((time, note) => {
        drumSynth.triggerAttackRelease(note, "4n", time);
    }, ["C1", "C1", "G1", "C1"], "up");
    
    drumPattern.interval = "2n";
    drumSynth.volume.value = -10;
    
    const luteSynth = new Tone.Synth({
        oscillator: { type: "triangle" },
        envelope: { attack: 0.02, decay: 0.4, sustain: 0.3, release: 0.8 }
    }).toDestination();
    
    const lutePattern = new Tone.Pattern((time, note) => {
        luteSynth.triggerAttackRelease(note, "8n", time);
    }, ["D3", "F3", "A3", "D4"], "up");
    
    lutePattern.interval = "4n";
    luteSynth.volume.value = -12;
    
    window.previewMusic.layers = [
        { name: "drums", pattern: drumPattern, synth: drumSynth },
        { name: "lute", pattern: lutePattern, synth: luteSynth }
    ];
}

function createPreviewElectronic() {
    debug('üéß Creating electronic preview...');
    
    // Kick and lead synth for preview
    const kickSynth = new Tone.MembraneSynth({
        pitchDecay: 0.05,
        octaves: 10,
        oscillator: { type: "sine" },
        envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4 }
    }).toDestination();
    
    const kickPattern = new Tone.Pattern((time, note) => {
        kickSynth.triggerAttackRelease(note, "8n", time);
    }, ["C1", "C1", "C1", "C1"], "up");
    
    kickPattern.interval = "4n";
    kickSynth.volume.value = -8;
    
    const leadSynth = new Tone.Synth({
        oscillator: { type: "square" },
        envelope: { attack: 0.05, decay: 0.3, sustain: 0.4, release: 1.0 }
    }).toDestination();
    
    const leadPattern = new Tone.Pattern((time, note) => {
        leadSynth.triggerAttackRelease(note, "8n", time);
    }, ["A4", "C5", "E5", "G5"], "up");
    
    leadPattern.interval = "8n";
    leadSynth.volume.value = -10;
    
    // Set faster tempo for electronic music
    Tone.Transport.bpm.value = 128;
    
    window.previewMusic.layers = [
        { name: "kick", pattern: kickPattern, synth: kickSynth },
        { name: "lead", pattern: leadPattern, synth: leadSynth }
    ];
}

function createPreviewAmbient() {
    debug('üéß Creating ambient preview...');
    
    // Drone and bells for preview
    const droneSynth = new Tone.Synth({
        oscillator: { type: "sine" },
        envelope: { attack: 2.0, decay: 1.0, sustain: 0.8, release: 3.0 }
    }).toDestination();
    
    const dronePattern = new Tone.Pattern((time, note) => {
        droneSynth.triggerAttackRelease(note, "2n", time);
    }, ["C2", "G2"], "up");
    
    dronePattern.interval = "1n";
    droneSynth.volume.value = -8;
    
    const bellSynth = new Tone.MetalSynth({
        frequency: 200,
        envelope: { attack: 0.001, decay: 1.0, release: 2.0 },
        harmonicity: 5.1,
        modulationIndex: 32,
        resonance: 4000,
        octaves: 1.5
    }).toDestination();
    
    const bellPattern = new Tone.Pattern((time, note) => {
        bellSynth.triggerAttackRelease(note, "4n", time);
    }, ["C4", "E4", "G4", "C5"], "up");
    
    bellPattern.interval = "2n";
    bellSynth.volume.value = -12;
    
    // Set slower tempo for ambient music
    Tone.Transport.bpm.value = 60;
    
    window.previewMusic.layers = [
        { name: "drone", pattern: dronePattern, synth: droneSynth },
        { name: "bells", pattern: bellPattern, synth: bellSynth }
    ];
}

// Apply the selected track
function applySelectedTrack() {
    if (selectedTrack === currentTrack) {
        debug('üéµ Track already playing!');
        return;
    }
    
    debug(`üéµ Switching from ${currentTrack} to ${selectedTrack}`);
    
    // Stop current music
    if (musicPlaying) {
        stopBackgroundMusic();
    }
    
    // Update current track
    currentTrack = selectedTrack;
    
    // Recreate music with new track
    createBackgroundMusic();
    
    // Start new music if game is playing and music is enabled
    if (gameStarted && !gameOver && !gamePaused && backgroundMusicEnabled) {
        startBackgroundMusic();
    }
    
    // Update UI
    initializeJukebox();
    
    // Save preference
    saveGameData('settings_change');
    
    debug(`‚úÖ Successfully switched to: ${availableTracks.find(t => t.id === currentTrack)?.name}`);
}
        
// Leaderboard functions - Updated with data preservation
function mergeLeaderboards() {
    // Get data from both keys
    const oldLeaderboard = JSON.parse(localStorage.getItem('endlessRunnerLeaderboard') || '[]');
    const newLeaderboard = JSON.parse(localStorage.getItem('runningBlitzLeaderboard') || '[]');
    
    // Combine both arrays
    const combinedLeaderboard = [...oldLeaderboard, ...newLeaderboard];
    
    // Remove duplicates and sort by score
    const uniqueLeaderboard = combinedLeaderboard
        .filter((entry, index, self) => 
            index === self.findIndex(e => e.name === entry.name && e.score === entry.score && e.date === entry.date)
        )
        .sort((a, b) => b.score - a.score)
        .slice(0, 10); // Keep only top 10
    
    // Save to both keys for compatibility
    localStorage.setItem('runningBlitzLeaderboard', JSON.stringify(uniqueLeaderboard));
    localStorage.setItem('endlessRunnerLeaderboard', JSON.stringify(uniqueLeaderboard));
    
    debug('Leaderboards merged:', uniqueLeaderboard);
    return uniqueLeaderboard;
}

function loadLeaderboard() {
    // First merge any existing data
    const mergedData = mergeLeaderboards();
    leaderboard = mergedData;
    
    // Get current high score
    if (leaderboard.length > 0) {
        currentHighScore = leaderboard[0].score;
    }
}

function saveLeaderboard() {
    // Save to both keys for compatibility
    localStorage.setItem('runningBlitzLeaderboard', JSON.stringify(leaderboard));
    localStorage.setItem('endlessRunnerLeaderboard', JSON.stringify(leaderboard));
}

function updateLeaderboardDisplay() {
    // Always merge fresh data when displaying
    const currentLeaderboard = mergeLeaderboards();
    
    const leaderboardBody = document.getElementById('leaderboardBody');
    leaderboardBody.innerHTML = '';
    
    if (currentLeaderboard.length === 0) {
        const row = document.createElement('tr');
        row.innerHTML = `<td colspan="4" style="text-align: center;">No high scores yet!</td>`;
        leaderboardBody.appendChild(row);
        return;
    }
    
    currentLeaderboard.forEach((entry, index) => {
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${index + 1}</td>
            <td>${entry.name}</td>
            <td>${entry.score}</td>
            <td>${entry.character || 'Unknown'}</td>
        `;
        leaderboardBody.appendChild(row);
    });
}

function formatDate(dateString) {
    const date = new Date(dateString);
    return date.toLocaleDateString();
}


        
        function saveHighScore() {
    const playerName = document.getElementById('playerNameInput').value.trim() || 'Anonymous';
    const currentScore = score;
    
    // Get existing leaderboard
    let leaderboard = JSON.parse(localStorage.getItem('runningBlitzLeaderboard') || '[]');
    
    // Add new score
    leaderboard.push({
        name: playerName,
        score: currentScore,
        character: currentCharacter,
        date: new Date().toLocaleDateString()
    });
    
    // Sort by score (highest first)
    leaderboard.sort((a, b) => b.score - a.score);
    
    // Keep only top 10
    leaderboard = leaderboard.slice(0, 10);
    
    // Save back to localStorage
    localStorage.setItem('runningBlitzLeaderboard', JSON.stringify(leaderboard));
    
    // Hide name entry section
    document.getElementById('newHighScoreMessage').style.display = 'none';
    
    // Clear the input for next time
    document.getElementById('playerNameInput').value = '';
    
    debug('Score saved to leaderboard!', leaderboard);

    // ADD THIS LINE - Submit to global leaderboard
    submitToGlobalLeaderboard(playerName, currentScore, currentCharacter);
    
    // Save profile with high score reason - THIS WILL SHOW THE SAVE INDICATOR
    saveGameData('high_score');
    
    // Optional: Show confirmation
    alert(`Score saved! ${playerName}: ${currentScore} points`);
}

// Allow Enter key to save score
document.getElementById('playerNameInput').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        document.getElementById('saveScoreButton').click();
    }
});

// ===== GLOBAL LEADERBOARD SYSTEM =====
let globalLeaderboard = [];
let playerGlobalRank = null;

// Submit score to global leaderboard
function submitToGlobalLeaderboard(playerName, score, character) {
    if (!cloudSaveEnabled || !playerId) {
        debug('‚ö†Ô∏è Cannot submit to global leaderboard - cloud save not available');
        return;
    }
    
    const globalEntry = {
        playerId: playerId,
        playerName: playerName,
        score: score,
        character: character,
        timestamp: Date.now(),
        date: new Date().toLocaleDateString(),
        country: 'Unknown' // We'll add geolocation later
    };
    
    // Submit to Firebase global leaderboard
    firebase.database().ref('globalLeaderboard').push(globalEntry)
        .then(() => {
            debug('üèÜ Score submitted to global leaderboard!');
            loadGlobalLeaderboard(); // Refresh to see new rankings
        })
        .catch((error) => {
            console.error('‚ùå Failed to submit to global leaderboard:', error);
        });
}

// Load global leaderboard from Firebase
function loadGlobalLeaderboard() {
    if (!cloudSaveEnabled) return;
    
    firebase.database().ref('globalLeaderboard')
        .orderByChild('score')
        .limitToLast(100) // Get top 100 scores
        .once('value')
        .then((snapshot) => {
            const data = snapshot.val();
            
            if (data) {
                // Convert to array and sort by score (highest first)
                globalLeaderboard = Object.values(data)
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 50); // Keep top 50
                
                debug(`üåç Loaded ${globalLeaderboard.length} global scores`);
                
                // Find player's rank
                findPlayerGlobalRank();
            } else {
                globalLeaderboard = [];
                debug('üåç No global scores found - be the first!');
            }
        })
        .catch((error) => {
            console.error('‚ùå Failed to load global leaderboard:', error);
        });
}

// Find current player's rank in global leaderboard
function findPlayerGlobalRank() {
    if (!playerId) return;
    
    playerGlobalRank = null;
    
    for (let i = 0; i < globalLeaderboard.length; i++) {
        if (globalLeaderboard[i].playerId === playerId) {
            playerGlobalRank = i + 1; // Rank is index + 1
            break;
        }
    }
    
    if (playerGlobalRank) {
        debug(`üèÜ Your global rank: #${playerGlobalRank}`);
    }
}

// Show global leaderboard popup
function showGlobalLeaderboard() {
    loadGlobalLeaderboard(); // Refresh data first
    
    setTimeout(() => { // Wait for data to load
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center;
            z-index: 10000; font-family: Arial, sans-serif;
        `;
        
        let leaderboardHTML = `
            <div style="
                background: rgba(0, 20, 40, 0.95);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.2);
                padding: 30px;
                border-radius: 20px;
                max-width: 500px;
                max-height: 80vh;
                overflow-y: auto;
                text-align: center;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            ">
                <h2 style="color: white; margin-bottom: 20px; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">
                    üåç Global Leaderboard
                </h2>
        `;
        
        if (globalLeaderboard.length === 0) {
            leaderboardHTML += `
                <p style="color: white; font-size: 18px; margin: 40px 0;">
                    üèÜ Be the first player on the global leaderboard!<br>
                    <small style="color: #ccc;">Play a game and your score will appear here!</small>
                </p>
            `;
        } else {
            // Show player's rank if they have one
            if (playerGlobalRank) {
                leaderboardHTML += `
                    <div style="background: rgba(255, 215, 0, 0.2); border: 1px solid #FFD700; border-radius: 10px; padding: 15px; margin-bottom: 20px;">
                        <p style="color: #FFD700; font-size: 16px; margin: 0;">
                            üèÜ Your Global Rank: #${playerGlobalRank}
                        </p>
                    </div>
                `;
            }
            
            leaderboardHTML += `
                <div style="text-align: left; max-height: 400px; overflow-y: auto;">
            `;
            
            // Display top scores
            globalLeaderboard.slice(0, 20).forEach((entry, index) => {
                const rank = index + 1;
                const isCurrentPlayer = entry.playerId === playerId;
                
                let rankEmoji = 'üèÖ';
                if (rank === 1) rankEmoji = 'ü•á';
                else if (rank === 2) rankEmoji = 'ü•à';
                else if (rank === 3) rankEmoji = 'ü•â';
                
                const bgColor = isCurrentPlayer ? 'rgba(0, 255, 0, 0.1)' : 'rgba(255, 255, 255, 0.05)';
                const textColor = isCurrentPlayer ? '#00FF00' : 'white';
                
                leaderboardHTML += `
                    <div style="
                        background: ${bgColor};
                        border: 1px solid rgba(255, 255, 255, 0.1);
                        border-radius: 8px;
                        padding: 12px;
                        margin: 8px 0;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    ">
                        <span style="color: ${textColor}; font-weight: bold;">
                            ${rankEmoji} #${rank} ${entry.playerName || 'Anonymous'}
                        </span>
                        <div style="text-align: right;">
                            <div style="color: ${textColor}; font-size: 18px; font-weight: bold;">
                                ${entry.score.toLocaleString()}
                            </div>
                            <div style="color: #ccc; font-size: 12px;">
                                ${entry.character} ‚Ä¢ ${entry.date}
                            </div>
                        </div>
                    </div>
                `;
            });
            
            leaderboardHTML += `</div>`;
            
            // Show total players
            leaderboardHTML += `
                <p style="color: #ccc; font-size: 14px; margin-top: 20px;">
                    üåç ${globalLeaderboard.length} players competing worldwide!
                </p>
            `;
        }
        
        leaderboardHTML += `
                <button onclick="this.parentElement.parentElement.remove()" 
                    style="background: #007AFF; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 16px; margin-top: 20px;">
                    Close
                </button>
            </div>
        `;
        
        modal.innerHTML = leaderboardHTML;
        document.body.appendChild(modal);
    }, 1000); // Give time for data to load
}

        
        // Update character display in settings
        function updateCharactersInSettings() {
            // Reset all selections
            document.querySelectorAll('#characterSelect .character-option').forEach(option => {
                option.classList.remove('selected');
            });
            
            // Mark current character as selected
            document.getElementById(`${currentCharacter}-option`).classList.add('selected');
            
            // Update cost displays
            for (const character in characterCosts) {
                const costElement = document.getElementById(`${character}-cost`);
                if (costElement) {
                    if (unlockedCharacters[character]) {
                        costElement.textContent = 'Unlocked';
                    } else {
                        costElement.textContent = `Cost: ${characterCosts[character]} coins`;
                    }
                }
            }
        }
        
        // Weather systems with smooth transitions
        function initializeWeatherSystems() {
            // Initialize with clear weather
            currentWeather = "clear";
            targetWeather = "clear";
            weatherTransitionProgress = 1; // Fully transitioned to start
            
            setWeather("clear");
        }
        
        function setWeather(weatherType) {
            // Start transition to new weather
            targetWeather = weatherType;
            weatherTransitionProgress = 0;
            
            // If no current weather particles exist, instantly create the new weather
            if (weatherParticles.length === 0 && weatherType !== "clear") {
                if (weatherType === "rain") {
                    createRainSystem();
                } else if (weatherType === "snow") {
                    createSnowSystem();
                }
            }
            
            // Reset weather change counter
            weatherChangeCounter = 0;
        }
        
// ==================== TITLE SCREEN SYSTEM ====================
// Title screen, animations, and initial game presentation
// Dependencies: Character System for orbiting characters
// Functions: initTitleScreen(), updateTitleScreen(), startTitleAnimations(), etc.

// Create particles for title screen
function createTitleScreenParticles() {
    if (!characterTitleScene) return; // Changed from window.titleScene
    
    // Create particles
    const particlesGeometry = new THREE.BufferGeometry();
    const particleCount = 150;
    
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    
    for (let i = 0; i < particleCount; i++) {
        // Position - spread wider for title screen
        positions[i * 3] = (Math.random() - 0.5) * 30;      // x
        positions[i * 3 + 1] = (Math.random() - 0.5) * 20;  // y
        positions[i * 3 + 2] = (Math.random() - 0.5) * 15;  // z (behind characters)
        
        // Color (blue/cyan matching your theme)
        colors[i * 3] = 0.1 + Math.random() * 0.3;          // r
        colors[i * 3 + 1] = 0.4 + Math.random() * 0.4;      // g
        colors[i * 3 + 2] = 0.7 + Math.random() * 0.3;      // b
    }
    
    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    
    const particlesMaterial = new THREE.PointsMaterial({
        size: 0.08,
        transparent: true,
        opacity: 0.6,
        vertexColors: true,
        blending: THREE.AdditiveBlending
    });
    
    const particles = new THREE.Points(particlesGeometry, particlesMaterial);
    particles.userData = {
        originalPositions: positions.slice()
    };
    
    characterTitleScene.add(particles); // Changed from window.titleScene
    characterTitleScene.userData.particles = particles; // Changed from window.titleScene
    
    debug('‚ú® Title screen particles created!'); // Debug log
}

// Animate title screen particles
function animateTitleParticles() {
    if (!characterTitleScene || !characterTitleScene.userData.particles) return; // Changed scene names
    
    const particles = characterTitleScene.userData.particles; // Changed scene name
    const positions = particles.geometry.attributes.position.array;
    const originalPositions = particles.userData.originalPositions;
    
    for (let i = 0; i < positions.length; i += 3) {
        // Gentle floating motion
        positions[i] = originalPositions[i] + Math.sin(frameCount * 0.008 + i * 0.1) * 0.15;
        positions[i + 1] = originalPositions[i + 1] + Math.cos(frameCount * 0.006 + i * 0.05) * 0.1;
        positions[i + 2] = originalPositions[i + 2] + Math.sin(frameCount * 0.004 + i * 0.02) * 0.05;
    }
    
    particles.geometry.attributes.position.needsUpdate = true;
}

// Animate title screen particles (time-based)
function animateTitleParticles() {
    if (!characterTitleScene || !characterTitleScene.userData.particles) return;
    
    const particles = characterTitleScene.userData.particles;
    const positions = particles.geometry.attributes.position.array;
    const originalPositions = particles.userData.originalPositions;
    
    // Use Date.now() for time-based animation instead of frameCount
    const time = Date.now() * 0.001; // Convert to seconds
    
    for (let i = 0; i < positions.length; i += 3) {
        // Gentle floating motion using time
        positions[i] = originalPositions[i] + Math.sin(time * 0.8 + i * 0.1) * 0.15;
        positions[i + 1] = originalPositions[i + 1] + Math.cos(time * 0.6 + i * 0.05) * 0.1;
        positions[i + 2] = originalPositions[i + 2] + Math.sin(time * 0.4 + i * 0.02) * 0.05;
    }
    
    particles.geometry.attributes.position.needsUpdate = true;
}

// Function to initialize the title screen with orbiting characters
function initTitleScreen() {

    // Create a new scene for the character orbits
    characterTitleScene = new THREE.Scene();
    characterTitleScene.background = null; // Transparent background
    
    // Create a camera for this scene
    characterTitleCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    characterTitleCamera.position.set(0, 0, 5);
    
    // Create a renderer for the title canvas
    const titleCanvas = document.getElementById('titleCanvas');
    titleRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    titleRenderer.setSize(window.innerWidth, window.innerHeight);
    titleRenderer.setClearColor(0x000000, 0); // Transparent background
    titleRenderer.domElement.style.position = 'absolute';
    titleRenderer.domElement.style.top = '0';
    titleRenderer.domElement.style.left = '0';
    titleRenderer.domElement.style.width = '100%';
    titleRenderer.domElement.style.height = '100%';
    titleRenderer.domElement.style.zIndex = '1';
    titleRenderer.domElement.style.pointerEvents = 'none'; // Allow clicks to pass through
    titleCanvas.appendChild(titleRenderer.domElement);
    debug('Title renderer canvas added to DOM'); // Debug log
    
    // Add lights to the title scene
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    characterTitleScene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    characterTitleScene.add(directionalLight);
    
    // Create a center sphere for characters to orbit
    const centerGeometry = new THREE.SphereGeometry(0.5, 32, 32);
    const centerMaterial = new THREE.MeshStandardMaterial({
        color: 0x004e92,
        metalness: 0.8,
        roughness: 0.2,
        emissive: 0x004e92,
        emissiveIntensity: 0.5
    });
    orbitCenter = new THREE.Mesh(centerGeometry, centerMaterial);
    characterTitleScene.add(orbitCenter);
    
    // Add glow effect to center sphere
    const glowGeometry = new THREE.SphereGeometry(0.65, 32, 32);
    const glowMaterial = new THREE.MeshBasicMaterial({
        color: 0x00a2ff,
        transparent: true,
        opacity: 0.3,
        side: THREE.BackSide
    });
    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
    orbitCenter.add(glow);
    
    // Create orbit ring viewed from top
    const ringGeometry = new THREE.TorusGeometry(3.2, 0.04, 16, 100);
    const ringMaterial = new THREE.MeshBasicMaterial({
        color: 0x00a2ff,
        transparent: true,
        opacity: 0.4
    });
    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
    characterTitleScene.add(ring);
    
    // Create character models and place them in orbit
    createTitleCharacters();
    
    // Setup title screen animation
    function animateTitleScreen() {
        requestAnimationFrame(animateTitleScreen);
        
        if (gameState === "title" && titleRenderer && characterTitleScene && characterTitleCamera) {
            // ADD THIS LINE - increment frameCount for animations
            frameCount++;

            // Rotate the center sphere
            if (orbitCenter) {
                orbitCenter.rotation.y += 0.003;
                orbitCenter.rotation.x += 0.001;
            }
            
            // Rotate ring clockwise when viewed from top
            characterTitleScene.children.forEach(child => {
                if (child.geometry && child.geometry.parameters && child.geometry.parameters.tube !== undefined) {
                    child.rotation.z -= 0.001;
                }
            });
            
            // Orbit and rotate each character
            titleCharacterModels.forEach((charObj, index) => {
                if (charObj && charObj.model) {
                    // Calculate perfect equal spacing angle
                    const baseAngle = (frameCount * 0.003) + (index * (Math.PI * 2 / characterNames.length));
                    const radius = charObj.radius;
                    
                    // Move in circular path with perfect equal spacing
                    charObj.model.position.x = Math.cos(baseAngle) * radius;
                    charObj.model.position.y = Math.sin(baseAngle) * radius;
                    charObj.model.position.z = 0;
                    
                    // Update stored angle for other calculations
                    charObj.angle = baseAngle;
                    
                    // Make character face outward toward viewer
                    if (charObj && charObj.model) {
                        try {
                            charObj.model.lookAt(charObj.model.position.x, charObj.model.position.y, 5);
                        } catch (error) {
                            debugWarn('Error making character face outward:', error);
                            charObj.model.rotation.z = 0;
                        }
                    }
                }
            });
            
            // ADD PARTICLE ANIMATION HERE
animateTitleParticles();

// Render the scene
titleRenderer.render(characterTitleScene, characterTitleCamera);
        }
    }

    // Create particles for title screen
createTitleScreenParticles();
    
    // Start the animation once
    animateTitleScreen();
    
   // Create floating particles (keeping the CSS particles too!)
if (typeof createTitleParticles === 'function') {
    createTitleParticles();
} else {
    debug('CSS particles already handling title screen effects');
}
    
    // Add event listener to the start button
setTimeout(() => {
    const startButton = document.getElementById('titleStartButton');
    if (startButton) {
        // Remove any existing listeners first
        startButton.replaceWith(startButton.cloneNode(true));
        const newStartButton = document.getElementById('titleStartButton');
        
        newStartButton.addEventListener('click', function() {
            debug('Start button clicked!');
            
            // Stop particles when leaving title screen (if function exists)
            if (typeof clearTitleParticles === 'function') {
                clearTitleParticles();
            }
            
            // Hide title screen, show character selection screen
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('characterSelectScreen').style.display = 'flex';
            
            // Initialize the character selection screen
            initCharacterSelectScreen();
            
            // Update game state
            gameState = "characterSelect";
        });
        debug('Start button event listener added successfully!');
    } else {
        debug('Start button not found!');
    }
}, 500); // Increased timeout to ensure DOM is ready



}

// Create character models for the title screen
function createTitleCharacters() {
    // Clear existing models
    titleCharacterModels.forEach(charObj => {
        characterTitleScene.remove(charObj.model);
    });
    titleCharacterModels = [];
    
    // Create each character
    characterNames.forEach((charType, index) => {
        // Create the character model
        let charModel;
        switch (charType) {
            // CHARACTER SELECTION SWITCH INJECTION POINT - Package manager will add cases here
    case "apple": charModel = createAppleCharacter(); break;
    case "carrot": charModel = createCarrotCharacter(); break;
    case "pumpkin": charModel = createPumpkinCharacter(); break;
    case "happyface": charModel = createHappyFaceCharacter(); break;
    case "monster": charModel = createMonsterCharacter(); break;
    case "atom": charModel = createAtomCharacter(); break;
    case "slime": charModel = createSlimeCharacter(); break;
    case "ufo": charModel = createUFOCharacter(); break;
    case "robot": charModel = createRobotCharacter(); break;
    case "dragon": charModel = createDragonCharacter(); break;
    case "ghost": charModel = createGhostCharacter(); break;
    case "creature": charModel = createCreatureCharacter(); break;
    // END CHARACTER SELECTION SWITCH INJECTION POINT
            default:
                debugWarn(`Unknown character type: ${charType}, using happyface instead`);
                charModel = createHappyFaceCharacter();
                break;
        }
        
        // Safety check
        if (!charModel) {
            console.error(`Failed to create character: ${charType}, using happyface instead`);
            charModel = createHappyFaceCharacter();
        }
        
        // Calculate position in circular orbit
        const startAngle = (index / characterNames.length) * Math.PI * 2;
        const orbitRadius = 3.2;
        const orbitSpeed = 0.003;

        // Position character in top-down circular orbit
        charModel.position.x = Math.cos(startAngle) * orbitRadius;
        charModel.position.y = Math.sin(startAngle) * orbitRadius;
        charModel.position.z = 0;

        // Scale characters smaller for cleaner look
        charModel.scale.set(0.7, 0.7, 0.7);
        
        // Add to scene
        characterTitleScene.add(charModel);
        
        // Store model and orbit parameters
        titleCharacterModels.push({
            model: charModel,
            type: charType,
            angle: startAngle,
            radius: orbitRadius,
            speed: orbitSpeed
        });
    });
}

        // ==================== CHARACTER SELECTION SYSTEM ====================
// Character selection screen and character preview functionality
// Dependencies: characters.js, THREE.js
// Functions: initCharacterSelectScreen(), selectCharacter(), previewCharacter(), etc.

        // Initialize Character Selection Screen
function initCharacterSelectScreen() {
    // Clear existing canvas content
    const selectCanvas = document.getElementById('characterSelectCanvas');
    selectCanvas.innerHTML = '';
    
    // Create a new scene for character display
    const characterSelectScene = new THREE.Scene();
    characterSelectScene.background = null; // Transparent background
    
    // Create a camera
const selectCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
selectCamera.position.set(0, 0, 3);
    
    // Create a renderer for full screen with background effects
const characterSelectRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
characterSelectRenderer.setSize(window.innerWidth, window.innerHeight);
characterSelectRenderer.setClearColor(0x000000, 0); // Transparent background
selectCanvas.appendChild(characterSelectRenderer.domElement);
    
    // Store references globally so they can be accessed by animation loop
window.characterSelectScene = characterSelectScene;
window.selectCamera = selectCamera;
window.characterSelectRenderer = characterSelectRenderer;
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            characterSelectScene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            characterSelectScene.add(directionalLight);
            
            // Create background effects
            createBackgroundEffects(characterSelectScene);
            
            // Clear existing character models if they exist
if (characterSelectModels && characterSelectModels.length > 0) {
    characterSelectModels.forEach(charObj => {
        if (charObj.model && charObj.model.parent) {
            charObj.model.parent.remove(charObj.model);
        }
    });
}

// Create all character models fresh
characterSelectModels = [];

characterNames.forEach(charType => {
    let charModel;
    
    try {
        switch (charType) {
    // CHARACTER SELECTION SWITCH INJECTION POINT - Package manager will add cases here
    case "apple": charModel = createAppleCharacter(); break;
    case "carrot": charModel = createCarrotCharacter(); break;
    case "pumpkin": charModel = createPumpkinCharacter(); break;
    case "happyface": charModel = createHappyFaceCharacter(); break;
    case "monster": charModel = createMonsterCharacter(); break;
    case "atom": charModel = createAtomCharacter(); break;
    case "slime": charModel = createSlimeCharacter(); break;
    case "ufo": charModel = createUFOCharacter(); break;
    case "robot": charModel = createRobotCharacter(); break;
    case "dragon": charModel = createDragonCharacter(); break;
    case "ghost": charModel = createGhostCharacter(); break;
    case "creature": charModel = createCreatureCharacter(); break;
    // END CHARACTER SELECTION SWITCH INJECTION POINT
    default:
        debugWarn(`Character ${charType} not yet extracted - using Happy Face`);
        charModel = createHappyFaceCharacter();
        break;
}
        
        // Safety check
        if (!charModel) {
            console.error(`Failed to create character: ${charType}, using apple instead`);
            charModel = createAppleCharacter();
        }

        debug(`‚úÖ Created character: ${charType}`, charModel);
        
        // Scale and position
charModel.scale.set(1.5, 1.5, 1.5);
charModel.position.set(0, 0, 0);
charModel.visible = false; // Hide all initially
        
        // Add to scene
        characterSelectScene.add(charModel);
        
        characterSelectModels.push({
            model: charModel,
            type: charType
        });
        
        debug(`‚úÖ Created character: ${charType}`);
        
    } catch (error) {
        console.error(`‚ùå Error creating character ${charType}:`, error);
        
        // Fallback to apple character
        charModel = createAppleCharacter();
        charModel.scale.set(1.5, 1.5, 1.5);
        charModel.position.set(0, 0, 0);
        charModel.visible = false;
        characterSelectScene.add(charModel);
        
        characterSelectModels.push({
            model: charModel,
            type: charType
        });
    }
});

// Ensure selectedCharacterIndex is valid
if (selectedCharacterIndex >= characterSelectModels.length) {
    selectedCharacterIndex = 0;
}

// Show the correct initial character
characterSelectModels[selectedCharacterIndex].model.visible = true;
updateCharacterInfo();
            
            // Clear any existing animation loop
if (window.characterSelectAnimationId) {
    cancelAnimationFrame(window.characterSelectAnimationId);
}

// Animation for character selection screen
function animateCharacterSelect() {
    window.characterSelectAnimationId = requestAnimationFrame(animateCharacterSelect);
    
    if (gameState === "characterSelect") {
        // Rotate the displayed character
        if (characterSelectModels && characterSelectModels[selectedCharacterIndex]) {
            const currentModel = characterSelectModels[selectedCharacterIndex].model;
            const currentType = characterSelectModels[selectedCharacterIndex].type;
            
            // Basic rotation
            if (currentModel && currentModel.visible) {
                currentModel.rotation.y += 0.01;
                
                // Apply specific character animations
                animateCharacterModel(currentModel, currentType, frameCount);
            }
        }
        
        // Animate background elements
        if (window.characterSelectScene && window.characterSelectScene.userData.particles) {
            animateBackgroundEffects();
        }
        
        // Render
if (window.characterSelectRenderer && window.characterSelectScene && window.selectCamera) {
    window.characterSelectRenderer.render(window.characterSelectScene, window.selectCamera);
}
    }
}

// Start animation
animateCharacterSelect();
            
            // Remove any existing event listeners and add fresh ones
const prevBtn = document.getElementById('prevCharacterBtn');
const nextBtn = document.getElementById('nextCharacterBtn');

// Clone buttons to remove all event listeners
const newPrevBtn = prevBtn.cloneNode(true);
const newNextBtn = nextBtn.cloneNode(true);
prevBtn.parentNode.replaceChild(newPrevBtn, prevBtn);
nextBtn.parentNode.replaceChild(newNextBtn, nextBtn);

// Add fresh event listeners
document.getElementById('prevCharacterBtn').addEventListener('click', function() {
    // Hide current model
    if (characterSelectModels[selectedCharacterIndex]) {
        characterSelectModels[selectedCharacterIndex].model.visible = false;
    }
    
    // Update index (with wrap-around)
    selectedCharacterIndex = (selectedCharacterIndex - 1 + characterNames.length) % characterNames.length;
    
    // Show new model
    if (characterSelectModels[selectedCharacterIndex]) {
        characterSelectModels[selectedCharacterIndex].model.visible = true;
    }
    
    // Update info display
    updateCharacterInfo();
});

document.getElementById('nextCharacterBtn').addEventListener('click', function() {
    // Hide current model
    if (characterSelectModels[selectedCharacterIndex]) {
        characterSelectModels[selectedCharacterIndex].model.visible = false;
    }
    
    // Update index (with wrap-around)
    selectedCharacterIndex = (selectedCharacterIndex + 1) % characterNames.length;
    
    // Show new model
    if (characterSelectModels[selectedCharacterIndex]) {
        characterSelectModels[selectedCharacterIndex].model.visible = true;
    }
    
    // Update info display
    updateCharacterInfo();
});
            
            // Start game button - now goes to world select
document.getElementById('startGameButton').addEventListener('click', function() {
    // Check if character is unlocked
    const selectedChar = characterNames[selectedCharacterIndex];
    
    if (unlockedCharacters[selectedChar] || modModeEnabled) {
        // Set the selected character
        currentCharacter = selectedChar;
        createPlayer(); // Update player model
        
        // Hide character selection screen and show world selection
        document.getElementById('characterSelectScreen').style.display = 'none';
        document.getElementById('worldSelectScreen').style.display = 'flex';
        
        // Initialize world selection screen
        initWorldSelectScreen();
        
        // Update game state
        gameState = "worldSelect";
    } else {
        // Character is locked - ask if they want to unlock
        const cost = characterCosts[selectedChar];
        if (confirm(`This character costs ${cost} coins. Do you want to unlock it?`)) {
            tryUnlockCharacter(selectedChar);
            updateCharacterInfo(); // Refresh display after attempt
        }
    }
});
        }

        // ==================== WORLD SELECTION SYSTEM ====================
// World selection screen and world preview functionality
// Dependencies: worlds/forest.js, worlds/desert.js, Character System
// Functions: initWorldSelectScreen(), selectWorld(), previewWorld(), switchWorld(), etc.

        // Initialize World Selection Screen
function initWorldSelectScreen() {
    // Clear existing canvas content
    const selectCanvas = document.getElementById('worldSelectCanvas');
    selectCanvas.innerHTML = '';
    
    // Create a new scene for world preview
    worldSelectScene = new THREE.Scene();
    worldSelectScene.background = null; // Transparent background
    
    // Create a camera
worldSelectCamera = new THREE.PerspectiveCamera(75, 300 / 200, 0.1, 1000);
worldSelectCamera.position.set(0, 2.5, 3); // Higher camera position to see more of the top
worldSelectCamera.lookAt(0, 0, 0); // Make sure camera looks at center
    
    // Create a renderer
worldSelectRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
worldSelectRenderer.setSize(300, 200); // Match the preview box size
worldSelectRenderer.setClearColor(0x000000, 0); // Transparent background

// Style the renderer to fit inside the preview box
worldSelectRenderer.domElement.style.position = 'absolute';
worldSelectRenderer.domElement.style.top = '0';
worldSelectRenderer.domElement.style.left = '0';
worldSelectRenderer.domElement.style.width = '100%';
worldSelectRenderer.domElement.style.height = '100%';
worldSelectRenderer.domElement.style.borderRadius = '15px';

// Add to the preview container instead of the main canvas
const previewContainer = document.getElementById('worldPreview');
previewContainer.appendChild(worldSelectRenderer.domElement);
    
    // Add lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    worldSelectScene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    worldSelectScene.add(directionalLight);
    
    // Create world preview models
    createWorldPreviews();
    
    // Show the correct initial world
    updateWorldDisplay();
    
    // Clear any existing animation loop
    if (window.worldSelectAnimationId) {
        cancelAnimationFrame(window.worldSelectAnimationId);
    }

    // Animation for world selection screen
    function animateWorldSelect() {
        window.worldSelectAnimationId = requestAnimationFrame(animateWorldSelect);
        
        if (gameState === "worldSelect") {
            // Rotate the displayed world preview
            if (worldSelectModels && worldSelectModels[selectedWorldIndex]) {
                const currentModel = worldSelectModels[selectedWorldIndex];
                
                if (currentModel && currentModel.visible) {
                    currentModel.rotation.y += 0.005; // Slow, elegant rotation
                    
                    // Add gentle floating motion around the centered position
const baseY = currentModel.userData.baseY || 0;
currentModel.position.y = baseY + Math.sin(frameCount * 0.02) * 0.08; // Smaller floating range
                }
            }
            
            // Render
            if (worldSelectRenderer && worldSelectScene && worldSelectCamera) {
                worldSelectRenderer.render(worldSelectScene, worldSelectCamera);
            }
        }
    }

    // Start animation
    animateWorldSelect();
    
    // Setup navigation buttons
    setupWorldSelectButtons();
}

// Create world preview models
function createWorldPreviews() {
    // Clear existing models
    worldSelectModels.forEach(model => {
        if (model && model.parent) {
            model.parent.remove(model);
        }
    });
    worldSelectModels = [];
    
    availableWorlds.forEach(world => {
        const worldPreview = createWorldPreviewModel(world);
        worldPreview.visible = false; // Hide all initially
        worldSelectScene.add(worldPreview);
        worldSelectModels.push(worldPreview);
    });
    
    // Show the first world
    if (worldSelectModels.length > 0) {
        worldSelectModels[selectedWorldIndex].visible = true;
    }
}

// Create a 3D preview model for a world
function createWorldPreviewModel(world) {
    const previewGroup = new THREE.Group();
    
    if (world.id === 'classic') {
    // Create classic plains preview
    
    // Ground platform
    const groundGeometry = new THREE.BoxGeometry(4, 0.2, 4);
    const groundMaterial = new THREE.MeshStandardMaterial({
        color: world.colors.ground,
        roughness: 0.8
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.position.y = -0.1;
    previewGroup.add(ground);
    
    // Add some grass
    for (let i = 0; i < 8; i++) {
        const grassGeometry = new THREE.ConeGeometry(0.05, 0.3, 4);
        const grassMaterial = new THREE.MeshStandardMaterial({
            color: 0x228B22
        });
        const grass = new THREE.Mesh(grassGeometry, grassMaterial);
        grass.position.set(
            (Math.random() - 0.5) * 3,
            0.05,
            (Math.random() - 0.5) * 3
        );
        previewGroup.add(grass);
    }
    
    // Add a small tree
    const trunkGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.6, 8);
    const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
    trunk.position.set(1, 0.3, 1);
    previewGroup.add(trunk);
    
    const leavesGeometry = new THREE.SphereGeometry(0.4, 8, 8);
    const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
    const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
    leaves.position.set(1, 0.8, 1);
    previewGroup.add(leaves);
    
    // Add some flowers
    for (let i = 0; i < 5; i++) {
        const flowerGeometry = new THREE.SphereGeometry(0.03, 6, 6);
        const flowerColors = [0xFF0000, 0xFFFF00, 0xFF00FF, 0xFFFFFF];
        const flowerMaterial = new THREE.MeshStandardMaterial({
            color: flowerColors[Math.floor(Math.random() * flowerColors.length)]
        });
        const flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
        flower.position.set(
            (Math.random() - 0.5) * 2,
            0.1,
            (Math.random() - 0.5) * 2
        );
        previewGroup.add(flower);
    }
} else if (world.id === 'forest') {
    // Create forest preview
    
    // Dark forest ground
    const groundGeometry = new THREE.BoxGeometry(4, 0.2, 4);
    const groundMaterial = new THREE.MeshStandardMaterial({
        color: world.colors.ground,
        roughness: 0.9
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.position.y = -0.1;
    previewGroup.add(ground);
    
    // Add tall pine trees
    for (let i = 0; i < 4; i++) {
        const trunkGeometry = new THREE.CylinderGeometry(0.08, 0.12, 1.2, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.set(
            (Math.random() - 0.5) * 3,
            0.6,
            (Math.random() - 0.5) * 3
        );
        previewGroup.add(trunk);
        
        // Pine cone shape leaves
        const leavesGeometry = new THREE.ConeGeometry(0.5, 1.0, 8);
        const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x1F4F2F });
        const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
        leaves.position.copy(trunk.position);
        leaves.position.y += 0.8;
        previewGroup.add(leaves);
    }
    
    // Add mushrooms
    for (let i = 0; i < 6; i++) {
        const stemGeometry = new THREE.CylinderGeometry(0.03, 0.04, 0.15, 6);
        const stemMaterial = new THREE.MeshStandardMaterial({ color: 0xF5DEB3 });
        const stem = new THREE.Mesh(stemGeometry, stemMaterial);
        stem.position.set(
            (Math.random() - 0.5) * 2,
            0.075,
            (Math.random() - 0.5) * 2
        );
        previewGroup.add(stem);
        
        const capGeometry = new THREE.SphereGeometry(0.06, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
        const capMaterial = new THREE.MeshStandardMaterial({ 
            color: i % 2 === 0 ? 0xFF4500 : 0x8B4513 
        });
        const cap = new THREE.Mesh(capGeometry, capMaterial);
        cap.position.copy(stem.position);
        cap.position.y += 0.12;
        previewGroup.add(cap);
    }
    
    // Add ferns
    for (let i = 0; i < 8; i++) {
        const fernGeometry = new THREE.PlaneGeometry(0.2, 0.3);
        const fernMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x228B22,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.8
        });
        const fern = new THREE.Mesh(fernGeometry, fernMaterial);
        fern.position.set(
            (Math.random() - 0.5) * 3,
            0.15,
            (Math.random() - 0.5) * 3
        );
        fern.rotation.y = Math.random() * Math.PI * 2;
        previewGroup.add(fern);
    }
} else if (world.id === 'desert') {
    // Create desert preview
    
    // Sandy ground
    const groundGeometry = new THREE.BoxGeometry(4, 0.2, 4);
    const groundMaterial = new THREE.MeshStandardMaterial({
        color: world.colors.ground,
        roughness: 0.9
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.position.y = -0.1;
    previewGroup.add(ground);
    
    // Add sand dunes
    for (let i = 0; i < 3; i++) {
        const duneGeometry = new THREE.SphereGeometry(0.8, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
        const duneMaterial = new THREE.MeshStandardMaterial({
            color: 0xF4A460,
            roughness: 0.9
        });
        const dune = new THREE.Mesh(duneGeometry, duneMaterial);
        dune.position.set(
            (Math.random() - 0.5) * 3,
            0,
            (Math.random() - 0.5) * 3
        );
        dune.scale.set(1, 0.5, 1);
        previewGroup.add(dune);
    }
    
    // Add a small cactus
    const cactusGeometry = new THREE.CylinderGeometry(0.1, 0.12, 0.8, 8);
    const cactusMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
    const cactus = new THREE.Mesh(cactusGeometry, cactusMaterial);
    cactus.position.set(1.2, 0.4, 0.8);
    previewGroup.add(cactus);
    
    // Add cactus flower
    const flowerGeometry = new THREE.SphereGeometry(0.05, 6, 6);
    const flowerMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xFF69B4,
        emissive: 0xFF1493,
        emissiveIntensity: 0.3
    });
    const flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
    flower.position.set(1.2, 0.85, 0.8);
    previewGroup.add(flower);
    
    // Add some rocks
    for (let i = 0; i < 4; i++) {
        const rockGeometry = new THREE.DodecahedronGeometry(0.08, 1);
        const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x8B7355 });
        const rock = new THREE.Mesh(rockGeometry, rockMaterial);
        rock.position.set(
            (Math.random() - 0.5) * 2.5,
            0.05,
            (Math.random() - 0.5) * 2.5
        );
        rock.rotation.set(
            Math.random() * Math.PI,
            Math.random() * Math.PI,
            Math.random() * Math.PI
        );
        previewGroup.add(rock);
    }
    
    // Add heat shimmer effect
    const shimmerGeometry = new THREE.PlaneGeometry(4, 0.5);
    const shimmerMaterial = new THREE.MeshBasicMaterial({
        color: 0xFFFFFF,
        transparent: true,
        opacity: 0.1,
        side: THREE.DoubleSide
    });
    const shimmer = new THREE.Mesh(shimmerGeometry, shimmerMaterial);
    shimmer.rotation.x = -Math.PI / 2;
    shimmer.position.y = 0.01;
    previewGroup.add(shimmer);
}
    
    // Scale up the preview to fill the rectangle better
previewGroup.scale.set(1.5, 1.5, 1.5);

// Center the preview perfectly in the rectangle  
previewGroup.position.set(0, 0.3, 0); // Raise it up slightly
previewGroup.userData.baseY = 0.3; // Store base position for floating animation

return previewGroup;
}

        // Setup world select navigation buttons
function setupWorldSelectButtons() {
    // Remove any existing event listeners by cloning buttons
    const prevBtn = document.getElementById('prevWorldBtn');
    const nextBtn = document.getElementById('nextWorldBtn');
    const startBtn = document.getElementById('startGameFromWorldButton');

    // Clone buttons to remove all event listeners
    const newPrevBtn = prevBtn.cloneNode(true);
    const newNextBtn = nextBtn.cloneNode(true);
    const newStartBtn = startBtn.cloneNode(true);
    
    prevBtn.parentNode.replaceChild(newPrevBtn, prevBtn);
    nextBtn.parentNode.replaceChild(newNextBtn, nextBtn);
    startBtn.parentNode.replaceChild(newStartBtn, startBtn);

    // Add fresh event listeners
    document.getElementById('prevWorldBtn').addEventListener('click', function() {
        // Hide current model
        if (worldSelectModels[selectedWorldIndex]) {
            worldSelectModels[selectedWorldIndex].visible = false;
        }
        
        // Update index (with wrap-around)
        selectedWorldIndex = (selectedWorldIndex - 1 + availableWorlds.length) % availableWorlds.length;
        
        // Show new model
        if (worldSelectModels[selectedWorldIndex]) {
            worldSelectModels[selectedWorldIndex].visible = true;
        }
        
        // Update info display
        updateWorldDisplay();
    });

    document.getElementById('nextWorldBtn').addEventListener('click', function() {
        // Hide current model
        if (worldSelectModels[selectedWorldIndex]) {
            worldSelectModels[selectedWorldIndex].visible = false;
        }
        
        // Update index (with wrap-around)
        selectedWorldIndex = (selectedWorldIndex + 1) % availableWorlds.length;
        
        // Show new model
        if (worldSelectModels[selectedWorldIndex]) {
            worldSelectModels[selectedWorldIndex].visible = true;
        }
        
        // Update info display
        updateWorldDisplay();
    });
    
    // Start game from world select
    document.getElementById('startGameFromWorldButton').addEventListener('click', function() {
        const selectedWorld = availableWorlds[selectedWorldIndex];
        
        if (unlockedWorlds[selectedWorld.id] || modModeEnabled) {
            // Set the selected world
            currentWorld = selectedWorld.id;
            applyWorldSettings(selectedWorld);
            
            // Hide world selection screen
            document.getElementById('worldSelectScreen').style.display = 'none';
            
            // Update game state and start the game
            gameState = "playing";
            startGame();
        } else {
            // World is locked - ask if they want to unlock
            const cost = selectedWorld.cost;
            if (confirm(`This world costs ${cost} coins. Do you want to unlock it?`)) {
                tryUnlockWorld(selectedWorld.id);
                updateWorldDisplay(); // Refresh display after attempt
            }
        }
    });
}

// Update world display information
function updateWorldDisplay() {
    const selectedWorld = availableWorlds[selectedWorldIndex];
    const worldNameElem = document.getElementById('worldName');
    const worldDescElem = document.getElementById('worldDescription');
    const worldStatusElem = document.getElementById('worldUnlockStatus');
    
    // Set name
    worldNameElem.textContent = selectedWorld.name;
    
    // Set description
    worldDescElem.textContent = selectedWorld.description;
    
    // Check unlock status
    if (unlockedWorlds[selectedWorld.id] || modModeEnabled) {
        worldStatusElem.textContent = "Unlocked";
        worldStatusElem.style.color = "#4CAF50"; // Green
    } else {
        worldStatusElem.textContent = `Locked - Cost: ${selectedWorld.cost} coins`;
        worldStatusElem.style.color = "#FF5722"; // Orange-red
    }
}

// Try to unlock a world
function tryUnlockWorld(worldId) {
    const world = availableWorlds.find(w => w.id === worldId);
    if (!world) return;
    
    if (unlockedWorlds[worldId]) {
        return; // Already unlocked
    }
    
    const cost = world.cost;
    if (totalCoins >= cost) {
        totalCoins -= cost;
        unlockedWorlds[worldId] = true;
        updateTotalCoins();
        saveGameData('world_unlock');  // or 'world_unlock'
        alert(`${world.name} unlocked!`);
    } else {
        alert(`Not enough coins! You need ${cost} coins to unlock this world.`);
    }
}

// Apply world settings to the game
function applyWorldSettings(world) {
    // Apply sky color
    scene.background = new THREE.Color(world.colors.sky);
    
    // Apply lighting changes
    if (skyLight) {
        skyLight.color.setHex(world.lighting.directional.color);
        skyLight.intensity = world.lighting.directional.intensity;
    }
    
    // Store current world data for other systems to use
    window.currentWorldData = world;
    
    // IMPORTANT: Recreate the ground with the new world theme
    recreateGroundForWorld();
    
    debug(`Applied settings for world: ${world.name}`);
}

// Recreate ground and background with current world theme
function recreateGroundForWorld() {
    // Remove existing ground segments
    groundSegments.forEach(segment => {
        scene.remove(segment);
    });
    groundSegments = [];
    
    // Remove existing side terrain segments
    sideTerrainSegments.forEach(terrain => {
        scene.remove(terrain);
    });
    sideTerrainSegments = [];
    
    // Remove existing background elements (mountains, trees, etc.)
    removeOldBackground();
    
    // Recreate ground and background with current world theme
    createGround();
    createBackground();
    
    debug(`Ground and background recreated for world: ${currentWorld}`);
}

// Remove old background elements when switching worlds
function removeOldBackground() {
    // Find and remove background elements (mountains, trees, clouds, etc.)
    const elementsToRemove = [];
    
    scene.traverse((object) => {
        // Remove mountains, trees, and other background scenery
        // (but keep player, coins, obstacles, etc.)
        if (object.parent === scene && 
            object !== player && 
            !groundSegments.includes(object) &&
            !sideTerrainSegments.includes(object) &&
            !coins.includes(object) &&
            !obstacles.includes(object) &&
            !powerUps.includes(object) &&
            !waterStreams.includes(object) &&
            !sceneryObjects.includes(object) &&
            object.type !== 'DirectionalLight' &&
            object.type !== 'AmbientLight') {
            
            // Check if it's likely a background element (positioned far away)
            if (Math.abs(object.position.z) > 50 || Math.abs(object.position.x) > 20) {
                elementsToRemove.push(object);
            }
        }
    });
    
    // Remove the background elements
    elementsToRemove.forEach(element => {
        scene.remove(element);
    });
    
    debug(`Removed ${elementsToRemove.length} old background elements`);
}

        // Update character info display
        function updateCharacterInfo() {
            const selectedChar = characterNames[selectedCharacterIndex];
            const charNameElem = document.getElementById('characterName');
            const charDescElem = document.getElementById('characterDescription');
            const charStatusElem = document.getElementById('characterUnlockStatus');
            
            // Set name (capitalized)
            charNameElem.textContent = selectedChar.charAt(0).toUpperCase() + selectedChar.slice(1);
            
            // Set description
switch (selectedChar) {
    case "apple":
        charDescElem.textContent = "Classic runner";
        break;
    case "carrot":
        charDescElem.textContent = "Fast lane changes";
        break;
    case "pumpkin":
        charDescElem.textContent = "Higher jumps";
        break;
    case "happyface":
        charDescElem.textContent = "Bouncy and cheerful";
        break;
    case "monster":
        charDescElem.textContent = "Ominous and fast";
        break;
    case "atom":
        charDescElem.textContent = "Glowing nucleus";
        break;
    case "slime":
        charDescElem.textContent = "Oozing and creepy";
        break;
    case "ufo":
        charDescElem.textContent = "Alien technology";
        break;
    case "robot":
        charDescElem.textContent = "Electromagnetic shield";
        break;
    case "dragon":
        charDescElem.textContent = "Fire breath destroyer";
        break;
    case "ghost":
        charDescElem.textContent = "Phase through obstacles";
        break;
    case "creature":
        charDescElem.textContent = "Otherworldly cosmic entity";
        break;
}
            
            // Check unlock status
            if (unlockedCharacters[selectedChar] || modModeEnabled) {
                charStatusElem.textContent = "Unlocked";
                charStatusElem.style.color = "#4CAF50"; // Green
            } else {
                charStatusElem.textContent = `Locked - Cost: ${characterCosts[selectedChar]} coins`;
                charStatusElem.style.color = "#FF5722"; // Orange-red
            }
        }

        // Create and animate background effects
        function createBackgroundEffects(scene) {
            // Add particles, grid lines, etc. here
            // This is just a simple implementation - you can expand it
            
            // Create particles
            const particlesGeometry = new THREE.BufferGeometry();
            const particleCount = 200;
            
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                // Position
                positions[i * 3] = (Math.random() - 0.5) * 20;      // x
                positions[i * 3 + 1] = (Math.random() - 0.5) * 20;  // y
                positions[i * 3 + 2] = (Math.random() - 0.5) * 20;  // z
                
                // Color (blue/cyan)
                colors[i * 3] = 0.1 + Math.random() * 0.3;          // r
                colors[i * 3 + 1] = 0.4 + Math.random() * 0.4;      // g
                colors[i * 3 + 2] = 0.7 + Math.random() * 0.3;      // b
            }
            
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const particlesMaterial = new THREE.PointsMaterial({
                size: 0.1,
                transparent: true,
                opacity: 0.7,
                vertexColors: true
            });
            
            const particles = new THREE.Points(particlesGeometry, particlesMaterial);
            particles.userData = {
                originalPositions: positions.slice() // Store original positions
            };
            
            scene.add(particles);
            scene.userData.particles = particles;
        }

        function animateBackgroundEffects() {
            const scene = characterSelectModels[0].model.parent;
            const particles = scene.userData.particles;
            
            if (particles) {
                // Animate particles
                const positions = particles.geometry.attributes.position.array;
                const originalPositions = particles.userData.originalPositions;
                
                for (let i = 0; i < positions.length; i += 3) {
                    // Move particles in a wave pattern
                    positions[i] = originalPositions[i] + Math.sin(frameCount * 0.01 + i * 0.1) * 0.1;
                    positions[i + 1] = originalPositions[i + 1] + Math.cos(frameCount * 0.01 + i * 0.05) * 0.1;
                    positions[i + 2] = originalPositions[i + 2];
                }
                
                particles.geometry.attributes.position.needsUpdate = true;
            }
        }

        // Helper function to animate specific characters
        function animateCharacterModel(model, type, frame) {
            switch (type) {
                case "happyface":
    // Bouncy animation - but only during gameplay, not on title screen
    if (model.userData && model.userData.bounceOffset !== undefined && gameState === "playing") {
        model.position.y = Math.sin(frame * 0.05 + model.userData.bounceOffset) * 0.1;
    }
    break;
                case "monster":
                    // Smoky particle animation
                    if (model.children) {
                        for (let i = 5; i < model.children.length; i++) {
                            const particle = model.children[i];
                            if (particle.userData && particle.userData.initialPosition) {
                                particle.userData.angle += particle.userData.rotationSpeed;
                                
                                const orbitRadius = particle.userData.initialPosition.length() + 
                                    Math.sin(frame * particle.userData.oscillationSpeed) * 
                                    particle.userData.oscillationDistance;
                                
                                const newX = orbitRadius * Math.sin(particle.userData.angle);
                                const newY = particle.userData.initialPosition.y + 
                                    Math.sin(frame * 0.1 + i) * 0.05;
                                const newZ = orbitRadius * Math.cos(particle.userData.angle);
                                
                                particle.position.set(newX, newY, newZ);
                            }
                        }
                    }
                    break;
                case "atom":
                    // Update electrons in orbit
                    for (let i = 0; i < model.children.length; i++) {
                        const child = model.children[i];
                        
                        // Orbital rings rotation
                        if (i >= 2 && i <= 4) {
                            child.rotation.z += 0.01;
                        }
                        
                        // Electrons
                        if (child.userData && child.userData.orbitalIndex !== undefined) {
                            const electron = child;
                            const orbitalIndex = electron.userData.orbitalIndex;
                            const orbitalRadius = electron.userData.orbitalRadius;
                            const speed = electron.userData.speed;
                            
                            electron.userData.angle += speed;
                            
                            if (orbitalIndex === 0) {
                                electron.position.x = Math.cos(electron.userData.angle) * orbitalRadius;
                                electron.position.z = Math.sin(electron.userData.angle) * orbitalRadius;
                            } else if (orbitalIndex === 1) {
                                electron.position.y = Math.cos(electron.userData.angle) * orbitalRadius;
                                electron.position.z = Math.sin(electron.userData.angle) * orbitalRadius;
                            } else {
                                electron.position.x = Math.cos(electron.userData.angle) * orbitalRadius * 0.7;
                                electron.position.y = Math.cos(electron.userData.angle) * orbitalRadius * 0.7;
                                electron.position.z = Math.sin(electron.userData.angle) * orbitalRadius;
                            }
                        }
                        
                        // Nucleus sparkles
                        if (i === 0 && child.children) {
                            child.children.forEach(sparkle => {
                                if (sparkle.userData) {
                                    const pulseScale = 0.8 + Math.sin(frame * sparkle.userData.pulseSpeed + sparkle.userData.pulsePhase) * 0.3;
                                    sparkle.scale.set(pulseScale, pulseScale, pulseScale);
                                }
                            });
                        }
                        
                        // Glow effect
                        if (i === 1) {
                            const pulseScale = 1.0 + Math.sin(frame * 0.05) * 0.1;
                            child.scale.set(pulseScale, pulseScale, pulseScale);
                            child.material.opacity = 0.3 + Math.sin(frame * 0.08) * 0.15;
                        }
                    }
                    break;
case "ufo":
    // Rotate the outer ring
    if (model.userData && model.userData.ring) {
        model.userData.ring.rotation.y += 0.03;
    }
    
    // Pulse the lights
    if (model.userData && model.userData.lights) {
        model.userData.lights.children.forEach((light, index) => {
            if (light.userData) {
                const pulse = Math.sin(frame * light.userData.pulseSpeed + light.userData.pulsePhase);
                light.material.emissiveIntensity = light.userData.originalIntensity + pulse * 0.5;
            }
        });
    }
    
    // Pulse the dome
    if (model.userData && model.userData.dome) {
        const domePulse = Math.sin(frame * 0.03) * 0.2 + 0.5;
        model.userData.dome.material.emissiveIntensity = domePulse;
    }
    
    // Animate tractor beam
    if (model.userData && model.userData.beam) {
        const beamPulse = Math.sin(frame * 0.05) * 0.1 + 0.2;
        model.userData.beam.material.opacity = beamPulse;
        model.userData.beam.rotation.y += 0.02;
    }
    
    // Float energy particles
    if (model.userData && model.userData.particles) {
        model.userData.particles.forEach(particle => {
            if (particle.userData) {
                // Orbit motion
                particle.userData.orbitAngle += particle.userData.orbitSpeed;
                const x = Math.cos(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                const z = Math.sin(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                
                // Floating motion
                const floatY = Math.sin(frame * particle.userData.floatSpeed + particle.userData.floatOffset) * 0.3;
                
                particle.position.set(x, floatY, z);
                
                // Particle glow pulse
                const glowPulse = Math.sin(frame * 0.08 + particle.userData.floatOffset) * 0.3 + 0.7;
                particle.material.opacity = glowPulse;
            }
        });
    }
    break;

case "slime":
    // Wobble animation for slime
    if (model.userData) {
        const wobble = Math.sin(frame * model.userData.wobbleSpeed) * model.userData.wobbleIntensity;
        model.scale.set(1 + wobble, 1 - wobble * 0.5, 1 + wobble);
        
        // Animate bubbles
        if (model.userData.bubbles) {
            model.userData.bubbles.forEach(bubble => {
                if (bubble.userData) {
                    const pulseScale = bubble.userData.originalScale.x + Math.sin(frame * bubble.userData.pulseSpeed + bubble.userData.pulsePhase) * 0.3;
                    bubble.scale.set(pulseScale, pulseScale, pulseScale);
                }
            });
        }
    }
    break;

case "robot":
    // Animate electromagnetic field
    if (model.userData && model.userData.fieldParticles) {
        model.userData.fieldParticles.forEach(particle => {
            if (particle.userData) {
                // Orbit around robot
                particle.userData.orbitAngle += particle.userData.orbitSpeed;
                particle.position.x = Math.cos(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                particle.position.z = Math.sin(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                particle.position.y = particle.userData.verticalOffset + Math.sin(frame * 0.02 + particle.userData.orbitAngle) * 0.2;
                
                // Pulse brightness based on shield status
                const intensity = robotShieldActive ? 0.8 : 0.3;
                particle.material.opacity = intensity + Math.sin(frame * 0.1 + particle.userData.orbitAngle) * 0.2;
            }
        });
    }
    break;

case "dragon":
    // Animate wings
    if (model.userData && model.userData.wings) {
        const wingFlap = Math.sin(frame * 0.15) * 0.3;
        model.userData.wings[0].rotation.z = Math.PI / 3 + wingFlap; // Left wing
        model.userData.wings[1].rotation.z = -Math.PI / 3 - wingFlap; // Right wing
    }
    
    // Animate fire particles when fire breath is active
    if (model.userData && model.userData.fireParticles && dragonFireActive) {
        model.userData.fireParticles.forEach((particle, index) => {
            if (particle.userData) {
                // Move fire particles forward
                particle.position.z += particle.userData.speed;
                
                // Flicker effect
                const flicker = Math.sin(frame * particle.userData.flickerSpeed + index) * 0.3 + 0.7;
                particle.material.opacity = particle.userData.originalOpacity * flicker;
                particle.scale.setScalar(0.8 + flicker * 0.4);
                
                // Reset position if too far
                if (particle.position.z > 2.0) {
                    particle.position.set(
                        (Math.random() - 0.5) * 0.3,
                        0.1 + Math.random() * 0.2,
                        1.0
                    );
                }
            }
        });
    }
    break;

case "ghost":
    // Animate wispy tail
    if (model.userData && model.userData.wisps) {
        model.userData.wisps.forEach(wisp => {
            if (wisp.userData) {
                const float = Math.sin(frame * wisp.userData.floatSpeed + wisp.userData.floatOffset) * 0.1;
                wisp.position.y = wisp.userData.originalY + float;
                wisp.rotation.y += 0.01;
            }
        });
    }
    
    // Animate floating particles
    if (model.userData && model.userData.particles) {
        model.userData.particles.forEach(particle => {
            if (particle.userData) {
                // Orbit motion
                particle.userData.orbitAngle += particle.userData.orbitSpeed;
                particle.position.x = Math.cos(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                particle.position.z = Math.sin(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                
                // Floating motion
                const floatY = Math.sin(frame * particle.userData.floatSpeed + particle.userData.floatOffset) * 0.2;
                particle.position.y += floatY * 0.01;
                
                // Pulse opacity
                const pulse = Math.sin(frame * 0.05 + particle.userData.floatOffset) * 0.3 + 0.7;
                particle.material.opacity = 0.6 * pulse;
            }
        });
    }
    
    // Phase effect when phasing through obstacles
    if (ghostPhaseActive) {
        const phaseOpacity = 0.3 + Math.sin(frame * 0.2) * 0.2;
        model.children[0].material.opacity = phaseOpacity; // Main body
        
        // Make wisps more transparent too
        if (model.userData && model.userData.wisps) {
            model.userData.wisps.forEach((wisp, index) => {
                wisp.material.opacity = (0.5 - index * 0.05) * phaseOpacity;
            });
        }
    } else {
        // Normal opacity
        model.children[0].material.opacity = model.userData.originalOpacity;
        if (model.userData && model.userData.wisps) {
            model.userData.wisps.forEach((wisp, index) => {
                wisp.material.opacity = 0.5 - index * 0.05;
            });
        }
    }
    break;

    case "creature":
    // Animate the neon core pulsing
    if (model.userData && model.userData.neonCore) {
        model.userData.corePhase += model.userData.bodyPulseSpeed;
        const corePulse = Math.sin(model.userData.corePhase) * 0.3 + 1.0;
        model.userData.neonCore.scale.set(corePulse, corePulse, corePulse);
        model.userData.neonCore.material.emissiveIntensity = 0.8 + Math.sin(model.userData.corePhase * 1.5) * 0.4;
    }
    
    // Animate multiple eyes blinking independently
    if (model.userData && model.userData.eyes) {
        model.userData.eyes.forEach(eye => {
            if (eye.userData) {
                // Independent blinking
                const blink = Math.sin(frame * eye.userData.blinkSpeed + eye.userData.blinkOffset);
                eye.scale.y = Math.max(0.1, Math.abs(blink));
                
                // Color pulsing
                const pulse = Math.sin(frame * eye.userData.pulseSpeed + eye.userData.pulsePhase) * 0.5 + 1.0;
                eye.material.emissiveIntensity = pulse;
            }
        });
    }
    
    // Animate floating tentacles
    if (model.userData && model.userData.tentacles) {
        model.userData.tentacles.forEach(tentacle => {
            if (tentacle.userData) {
                // Sway tentacles
                const sway = Math.sin(frame * tentacle.userData.swaySpeed) * tentacle.userData.swayAmount;
                tentacle.rotation.z = sway * 0.3;
                
                // Animate individual segments
                tentacle.children.forEach(segment => {
                    if (segment.userData) {
                        const wave = Math.sin(frame * segment.userData.waveSpeed + segment.userData.waveOffset);
                        segment.position.x = wave * 0.1 * (segment.userData.segmentIndex + 1);
                    }
                });
            }
        });
    }
    
    // Animate ethereal wisps
    if (model.userData && model.userData.wisps) {
        model.userData.wisps.forEach(wisp => {
            if (wisp.userData) {
                // Orbit motion
                wisp.userData.orbitAngle += wisp.userData.orbitSpeed;
                wisp.position.x = Math.cos(wisp.userData.orbitAngle) * wisp.userData.orbitRadius;
                wisp.position.z = Math.sin(wisp.userData.orbitAngle) * wisp.userData.orbitRadius;
                
                // Vertical floating
                const verticalFloat = Math.sin(frame * wisp.userData.verticalSpeed + wisp.userData.verticalOffset) * 0.2;
                wisp.position.y += verticalFloat * 0.01;
                
                // Pulsing effect
                const pulse = Math.sin(frame * wisp.userData.pulseSpeed + wisp.userData.pulsePhase) * 0.4 + 0.6;
                wisp.material.opacity = pulse;
                wisp.scale.setScalar(pulse);
            }
        });
    }
    
    // Morph the main body slightly
    if (model.userData && model.userData.mainBody) {
        const morph = Math.sin(frame * model.userData.morphSpeed) * 0.05 + 1.0;
        model.userData.mainBody.scale.set(1.1 * morph, 0.9 / morph, 1.1 * morph);
    }
    break;

            }
        }

function createRainSystem() {
            const rainCount = isMobile ? 150 : 500;
            const rainGeometry = new THREE.BoxGeometry(0.03, 0.2, 0.03);
            const rainMaterial = new THREE.MeshBasicMaterial({
                color: 0x9ACEEB, // Light blue
                transparent: true,
                opacity: 0.6
            });
            
            for (let i = 0; i < rainCount; i++) {
                const raindrop = new THREE.Mesh(rainGeometry, rainMaterial);
                
                // Randomize positions in a large area around the player
                raindrop.position.set(
                    Math.random() * 80 - 40,
                    Math.random() * 30 + 10,
                    Math.random() * 80 - 100
                );
                
                // Set raindrop speed and properties
                raindrop.userData.speed = Math.random() * 0.3 + 0.2;
                raindrop.userData.horizontalSpeed = Math.random() * 0.05 - 0.025;
                raindrop.userData.weatherType = "rain";
                
                scene.add(raindrop);
                weatherParticles.push(raindrop);
            }
            
            // Target sky color for rain (not immediate)
            targetSkyColor = new THREE.Color(0x556677); // Darker sky
        }
        
        function createSnowSystem() {
            const snowCount = isMobile ? 120 : 400;
            const snowGeometry = new THREE.SphereGeometry(0.05, 6, 6);
            const snowMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            
            for (let i = 0; i < snowCount; i++) {
                const snowflake = new THREE.Mesh(snowGeometry, snowMaterial);
                
                // Randomize positions in a large area around the player
                snowflake.position.set(
                    Math.random() * 80 - 40,
                    Math.random() * 30 + 10,
                    Math.random() * 80 - 100
                );
                
                // Set snowflake speed and properties
                snowflake.userData.speed = Math.random() * 0.1 + 0.05;
                snowflake.userData.horizontalSpeed = Math.random() * 0.03 - 0.015;
                snowflake.userData.wobbleSpeed = Math.random() * 0.02 + 0.01;
                snowflake.userData.wobbleAmount = Math.random() * 0.1;
                snowflake.userData.wobblePosition = Math.random() * Math.PI * 2;
                snowflake.userData.weatherType = "snow";
                
                scene.add(snowflake);
                weatherParticles.push(snowflake);
            }
            
            // Target sky color for snow (gradual transition)
            targetSkyColor = new THREE.Color(0xc8d8f0); // Light blue-gray sky
        }
        
        function updateWeather() {
            // Progress the transition between weather types
            if (weatherTransitionProgress < 1) {
                weatherTransitionProgress += 0.005; // Slow transition
                
                // Gradually adjust the sky color
                scene.background.lerp(targetSkyColor, 0.005);
                
                // Gradually adjust light intensity based on target weather
                let targetIntensity = 0.8; // Default for clear
                if (targetWeather === "rain") {
                    targetIntensity = 0.5;
                } else if (targetWeather === "snow") {
                    targetIntensity = 0.7;
                }
                
                // Apply time of day modifications to target intensity
                if (time < 0.3 || time > 0.7) {
                    // Lower light during dawn/dusk/night
                    targetIntensity *= (time > 0.85 || time < 0.2) ? 0.4 : 0.75;
                }
                
                skyLight.intensity += (targetIntensity - skyLight.intensity) * 0.01;
                
                // Remove particles of the weather type we're transitioning away from
                if (targetWeather !== currentWeather && weatherTransitionProgress > 0.5) {
                    for (let i = weatherParticles.length - 1; i >= 0; i--) {
                        const particle = weatherParticles[i];
                        if (particle.userData.weatherType === currentWeather) {
                            // Fade out the particle
                            if (particle.material.opacity > 0.05) {
                                particle.material.opacity -= 0.05;
                            } else {
                                scene.remove(particle);
                                weatherParticles.splice(i, 1);
                            }
                        }
                    }
                    
                    // If we've removed all particles of the old type, and we need to create new ones
                    if (weatherParticles.length === 0 && targetWeather !== "clear") {
                        if (targetWeather === "rain") {
                            createRainSystem();
                        } else if (targetWeather === "snow") {
                            createSnowSystem();
                        }
                    }
                }
                
                // If transition is complete, update current weather
                if (weatherTransitionProgress >= 1) {
                    currentWeather = targetWeather;
                }
            }
            
            // Update weather particles
            for (let i = weatherParticles.length - 1; i >= 0; i--) {
                const particle = weatherParticles[i];
                
                if (particle.userData.weatherType === "rain") {
                    // Move raindrop down and slightly sideways
                    particle.position.y -= particle.userData.speed;
                    particle.position.x += particle.userData.horizontalSpeed;
                    particle.position.z += currentSpeed; // Move with scene
                    
                    // Reset if too low or behind camera
                    if (particle.position.y < -2 || particle.position.z > 10) {
                        particle.position.set(
                            Math.random() * 80 - 40,
                            Math.random() * 20 + 20,
                            Math.random() * 40 - 120
                        );
                    }
                } else if (particle.userData.weatherType === "snow") {
                    // Move snowflake down with wobble and slightly sideways
                    particle.position.y -= particle.userData.speed;
                    
                    // Add wobble effect
                    particle.userData.wobblePosition += particle.userData.wobbleSpeed;
                    particle.position.x += Math.sin(particle.userData.wobblePosition) * particle.userData.wobbleAmount + particle.userData.horizontalSpeed;
                    
                    particle.position.z += currentSpeed; // Move with scene
                    particle.rotation.y += 0.01; // Rotate snowflake
                    
                    // Reset if too low or behind camera
                    if (particle.position.y < -2 || particle.position.z > 10) {
                        particle.position.set(
                            Math.random() * 80 - 40,
                            Math.random() * 20 + 20,
                            Math.random() * 40 - 120
                        );
                        particle.userData.wobblePosition = Math.random() * Math.PI * 2;
                    }
                }
            }
            
            // Check if it's time to change weather
            weatherChangeCounter++;
            if (weatherChangeCounter > weatherChangeDuration) {
                const roll = Math.random();
                if (currentWeather === "clear") {
                    // 40% chance of rain, 20% chance of snow when clear
                    if (roll < 0.4) setWeather("rain");
                    else if (roll < 0.6) setWeather("snow");
                    else setWeather("clear");
                } else {
                    // 60% chance of clear when raining or snowing
                    if (roll < 0.6) setWeather("clear");
                    else if (currentWeather === "rain" && roll < 0.8) setWeather("snow");
                    else if (currentWeather === "snow" && roll < 0.8) setWeather("rain");
                    else setWeather(currentWeather);
                }
            }
            
            // Update time of day
            updateTimeOfDay();
        }
        
        function updateTimeOfDay() {
            time += timeCycleSpeed;
            if (time > 1) time = 0;
            
            // Calculate target sky color based on time
            let timeSkyColor;
            if (time < 0.25) { // Morning
                timeSkyColor = new THREE.Color(0x87CEEB).lerp(new THREE.Color(0xFFA07A), time * 4);
            } else if (time < 0.3) { // Sunrise
                timeSkyColor = new THREE.Color(0xFFA07A).lerp(new THREE.Color(0x87CEEB), (time - 0.25) * 20);
            } else if (time < 0.7) { // Day
                timeSkyColor = new THREE.Color(0x87CEEB);
            } else if (time < 0.8) { // Sunset
                timeSkyColor = new THREE.Color(0x87CEEB).lerp(new THREE.Color(0xFF7F50), (time - 0.7) * 10);
            } else if (time < 0.85) { // Dusk
                timeSkyColor = new THREE.Color(0xFF7F50).lerp(new THREE.Color(0x191970), (time - 0.8) * 20);
            } else { // Night
                timeSkyColor = new THREE.Color(0x191970);
            }
            
            // Blend weather sky color with time of day sky color
            if (currentWeather === "clear") {
                targetSkyColor = timeSkyColor;
            } else {
                // For weather conditions, gradually blend with time-of-day
                const weatherInfluence = 0.7; // Weather has 70% influence
                const timeInfluence = 1 - weatherInfluence;
                
                // Create a blended target
                const blendedTarget = targetSkyColor.clone();
                blendedTarget.lerp(timeSkyColor, timeInfluence);
                targetSkyColor = blendedTarget;
            }
            
            // Gradually shift sky color
            scene.background.lerp(targetSkyColor, 0.005);
            
            // Adjust light intensity based on time (smooth transition)
            let targetIntensity;
            if (time < 0.3 || time > 0.7) {
                // Lower light during dawn/dusk/night
                targetIntensity = (time > 0.85 || time < 0.2) ? 0.3 : 0.6;
            } else if (currentWeather === "clear") {
                // Full daylight
                targetIntensity = 0.8;
            } else if (currentWeather === "rain") {
                // Dimmer for rain
                targetIntensity = 0.5;
            } else if (currentWeather === "snow") {
                // Moderate for snow
                targetIntensity = 0.7;
            } else {
                targetIntensity = 0.8;
            }
            
            // Smooth transition for light intensity
            skyLight.intensity += (targetIntensity - skyLight.intensity) * 0.01;
            
            // Adjust light color based on time
            let targetLightColor;
            if (time < 0.3) { // Morning
                targetLightColor = new THREE.Color(0xFFD580);
            } else if (time < 0.7) { // Day
                targetLightColor = new THREE.Color(0xFFFFFF);
            } else if (time < 0.85) { // Evening
                targetLightColor = new THREE.Color(0xFFA07A);
            } else { // Night
                targetLightColor = new THREE.Color(0x4169E1);
            }
            
            // Smooth transition for light color
            skyLight.color.lerp(targetLightColor, 0.01);
        }
        
        function updateButterfliesAndBirds() {
            // Update butterflies
            for (let i = butterflyGroups.length - 1; i >= 0; i--) {
                const butterfly = butterflyGroups[i];
                
                // Move forward
                butterfly.position.add(butterfly.userData.moveDirection.clone().multiplyScalar(butterfly.userData.moveSpeed));
                
                // Animate wings
                butterfly.userData.wingPosition += butterfly.userData.wingSpeed;
                const leftWing = butterfly.children[0];
                const rightWing = butterfly.children[1];
                
                leftWing.rotation.z = Math.sin(butterfly.userData.wingPosition) * 0.5;
                rightWing.rotation.z = -Math.sin(butterfly.userData.wingPosition) * 0.5;
                
                // Change direction occasionally
                butterfly.userData.changeDirectionCounter++;
                if (butterfly.userData.changeDirectionCounter > butterfly.userData.changeDirectionTime) {
                    butterfly.userData.moveDirection = new THREE.Vector3(
                        Math.random() * 2 - 1,
                        Math.random() * 2 - 1,
                        Math.random() * 2 - 1
                    ).normalize();
                    butterfly.userData.changeDirectionCounter = 0;
                    butterfly.userData.changeDirectionTime = Math.floor(Math.random() * 100) + 50;
                }
                
                // Remove if too far
                if (butterfly.position.distanceTo(player.position) > 50) {
                    scene.remove(butterfly);
                    butterflyGroups.splice(i, 1);
                }
            }
            
            // Update birds
            for (let i = birds.length - 1; i >= 0; i--) {
                const bird = birds[i];
                
                // Move forward
                bird.position.z += currentSpeed + bird.userData.flySpeed;
                
                // Animate wings
                bird.userData.wingPosition += bird.userData.wingSpeed;
                const wings = bird.children[1];
                wings.rotation.z = Math.sin(bird.userData.wingPosition) * 0.3;
                
                // Remove if behind camera
                if (bird.position.z > 10) {
                    scene.remove(bird);
                    birds.splice(i, 1);
                }
            }
            
            // Spawn new butterflies/beetles occasionally - world-specific
if (Math.random() < 0.005 && butterflyGroups.length < mobileButterflyLimit && currentWeather === "clear") {
    const x = Math.random() * 40 - 20;
    const y = Math.random() * 3 + 1;
    const z = Math.random() * 20 - 40;
    
    if (currentWorld === 'desert') {
        // Desert beetles instead of butterflies
        butterflyGroups.push(createDesertBeetle(x, y, z));
    } else {
        // Regular butterflies for classic and forest
        butterflyGroups.push(createButterfly(x, y, z));
    }
}
            
            // Spawn new birds occasionally - world-specific types
if (Math.random() < 0.002 && birds.length < mobileBirdsLimit) {
    const x = Math.random() * 60 - 30;
    const y = Math.random() * 10 + 10;
    const z = -100;
    
    // Different birds for different worlds
    if (currentWorld === 'desert') {
        // Vultures and desert birds fly higher
        const desertY = Math.random() * 15 + 15;
        birds.push(createBird(x, desertY, z));
    } else {
        // Regular birds for classic and forest
        birds.push(createBird(x, y, z));
    }
}
}

// Create desert beetle animation
function createDesertBeetle(x, y, z) {
    const beetleGroup = new THREE.Group();
    
    // Beetle colors - desert themed
    const beetleColors = [
        0x8B4513, // Saddle brown
        0xA0522D, // Sienna  
        0x654321, // Dark brown
        0x2F4F4F, // Dark slate gray
        0x556B2F, // Dark olive green
        0x8B7355  // Burlywood
    ];
    
    const color = beetleColors[Math.floor(Math.random() * beetleColors.length)];
    
    // Beetle body - more elongated than butterfly
    const bodyGeometry = new THREE.CapsuleGeometry(0.02, 0.15, 4, 8);
    const bodyMaterial = new THREE.MeshStandardMaterial({
        color: 0x000000, // Black body
        metalness: 0.7,
        roughness: 0.3
    });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.rotation.x = Math.PI / 2;
    beetleGroup.add(body);
    
    // Beetle wing covers (elytra) - hard wing cases using boxes
const wingGeometry = new THREE.BoxGeometry(0.06, 0.02, 0.2);
const wingMaterial = new THREE.MeshStandardMaterial({
    color: color,
    metalness: 0.8,
    roughness: 0.2
});

const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
leftWing.position.set(-0.05, 0, 0);
beetleGroup.add(leftWing);

const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
rightWing.position.set(0.05, 0, 0);
beetleGroup.add(rightWing);

// Add beetle head
const headGeometry = new THREE.SphereGeometry(0.04, 8, 8);
const headMaterial = new THREE.MeshStandardMaterial({
    color: 0x000000,
    metalness: 0.6,
    roughness: 0.4
});
const head = new THREE.Mesh(headGeometry, headMaterial);
head.position.z = 0.1;
beetleGroup.add(head);
    
    // Antennae
    for (let i = 0; i < 2; i++) {
        const antennaGeometry = new THREE.CylinderGeometry(0.005, 0.005, 0.1, 4);
        const antennaMaterial = new THREE.MeshStandardMaterial({
            color: 0x000000
        });
        const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
        antenna.position.set(i === 0 ? -0.02 : 0.02, 0, 0.08);
        antenna.rotation.z = (i === 0 ? -1 : 1) * Math.PI / 6;
        beetleGroup.add(antenna);
    }
    
    // Position beetle
    beetleGroup.position.set(x, y, z);
    
    // Add animation properties (beetles fly differently than butterflies)
    beetleGroup.userData.wingSpeed = Math.random() * 0.15 + 0.2; // Faster wing beat
    beetleGroup.userData.wingPosition = 0;
    beetleGroup.userData.moveSpeed = Math.random() * 0.02 + 0.015; // Slightly faster movement
    beetleGroup.userData.moveDirection = new THREE.Vector3(
        Math.random() * 2 - 1,
        Math.random() * 2 - 1,
        Math.random() * 2 - 1
    ).normalize();
    beetleGroup.userData.changeDirectionCounter = 0;
    beetleGroup.userData.changeDirectionTime = Math.floor(Math.random() * 80) + 40; // More erratic movement
    
    scene.add(beetleGroup);
    return beetleGroup;
}
        
        // Create butterfly animation
        function createButterfly(x, y, z) {
            const butterflyGroup = new THREE.Group();
            
            // Butterfly colors
            const colors = [
                0xFF7F50, // Coral
                0xFFB6C1, // Light Pink
                0x4682B4, // Steel Blue
                0xFFA500, // Orange
                0xBDB76B, // Dark Khaki
                0xADFF2F  // Green Yellow
            ];
            
            const color = colors[Math.floor(Math.random() * colors.length)];
            
            // Wings
            const wingGeometry = new THREE.CircleGeometry(0.3, 16, 0, Math.PI);
            const wingMaterial = new THREE.MeshBasicMaterial({
                color: color,
                side: THREE.DoubleSide
            });
            
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.rotation.x = Math.PI / 2;
            leftWing.rotation.y = Math.PI / 2;
            leftWing.position.x = -0.15;
            butterflyGroup.add(leftWing);
            
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.rotation.x = Math.PI / 2;
            rightWing.rotation.y = -Math.PI / 2;
            rightWing.position.x = 0.15;
            butterflyGroup.add(rightWing);
            
            // Body
            const bodyGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.3, 8);
            const bodyMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000 // Black
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.x = Math.PI / 2;
            butterflyGroup.add(body);
            
            // Position butterfly
            butterflyGroup.position.set(x, y, z);
            
            // Add animation properties
            butterflyGroup.userData.wingSpeed = Math.random() * 0.1 + 0.1;
            butterflyGroup.userData.wingPosition = 0;
            butterflyGroup.userData.moveSpeed = Math.random() * 0.03 + 0.01;
            butterflyGroup.userData.moveDirection = new THREE.Vector3(
                Math.random() * 2 - 1,
                Math.random() * 2 - 1,
                Math.random() * 2 - 1
            ).normalize();
            butterflyGroup.userData.changeDirectionCounter = 0;
            butterflyGroup.userData.changeDirectionTime = Math.floor(Math.random() * 100) + 50;
            
            scene.add(butterflyGroup);
            return butterflyGroup;
        }
        
        // Create birds
        function createBird(x, y, z) {
            const birdGroup = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const bodyMaterial = new THREE.MeshBasicMaterial({
                color: Math.random() > 0.5 ? 0x555555 : 0x777777 // Gray birds
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            birdGroup.add(body);
            
            // Wings
            const wingGeometry = new THREE.BoxGeometry(0.6, 0.02, 0.2);
            const wingMaterial = new THREE.MeshBasicMaterial({
                color: bodyMaterial.color,
                side: THREE.DoubleSide
            });
            
            const wings = new THREE.Mesh(wingGeometry, wingMaterial);
            wings.position.y = 0.08;
            birdGroup.add(wings);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const headMaterial = new THREE.MeshBasicMaterial({
                color: bodyMaterial.color
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.z = 0.15;
            head.position.y = 0.04;
            birdGroup.add(head);
            
            // Beak
            const beakGeometry = new THREE.ConeGeometry(0.03, 0.1, 8);
            const beakMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFD700 // Gold
            });
            const beak = new THREE.Mesh(beakGeometry, beakMaterial);
            beak.rotation.x = -Math.PI / 2;
            beak.position.z = 0.25;
            beak.position.y = 0.04;
            birdGroup.add(beak);
            
            // Position bird
            birdGroup.position.set(x, y, z);
            birdGroup.rotation.y = Math.PI; // Face forward
            
            // Add animation properties
            birdGroup.userData.wingSpeed = Math.random() * 0.1 + 0.2;
            birdGroup.userData.wingPosition = 0;
            birdGroup.userData.flySpeed = Math.random() * 0.1 + 0.15;
            
            scene.add(birdGroup);
            return birdGroup;
        }

// Toggle settings screen visibility
        function toggleSettingsScreen() {
            const settingsScreen = document.getElementById('settingsScreen');
            const modalOverlay = document.getElementById('modalOverlay');
            
            if (settingsScreen.style.display === 'flex') {
                closeSettingsScreen();
            } else {
                // Set the active tab back to the first tab
                document.querySelectorAll('.tab-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.querySelector('.tab-button').classList.add('active');
                document.getElementById('settings-tab').classList.add('active');
                
                // Update character display in settings
                updateCharactersInSettings();
                
                // Update mod mode display
                if (modModeEnabled) {
                    document.getElementById('mod-mode-option').classList.add('enabled');
                    document.getElementById('modModeButton').textContent = 'Disable';
                } else {
                    document.getElementById('mod-mode-option').classList.remove('enabled');
                    document.getElementById('modModeButton').textContent = 'Enable';
                }
                
                // Update leaderboard
                updateLeaderboardDisplay();
                
                // Show settings and overlay
                settingsScreen.style.display = 'flex';
                modalOverlay.style.display = 'block';
                
                // Pause the game if it's running
                if (gameState === "playing") {
                    gamePaused = true;
                    gameState = "paused";
                }
            }
        }
        
        // Close settings screen
        function closeSettingsScreen() {
// Stop any playing preview
    if (window.previewMusic && window.previewMusic.playing) {
        stopPreview();
    }

            document.getElementById('settingsScreen').style.display = 'none';
            document.getElementById('modalOverlay').style.display = 'none';
            
            // Check where to return to based on game state
            if (gameState === "paused") {
                // If we came from pause menu, go back to pause menu
                document.getElementById('pauseScreen').style.display = 'flex';
                // Keep gamePaused as true
            } else if (gameState === "gameOver") {
                // If we came from game over, go back to game over screen
                document.getElementById('gameOver').style.display = 'flex';
            } else if (gameState === "playing") {
                // If we opened settings during gameplay, unpause
                gamePaused = false;
            }
        }
        
        // Toggle mod mode on/off
        function toggleModMode() {
            const password = document.getElementById('modPassword').value;
            
            if (!modModeEnabled) {
    // Trying to enable mod mode
    if (password === MOD_PASSWORD) {
        modModeEnabled = true;
        document.getElementById('mod-mode-option').classList.add('enabled');
        document.getElementById('modModeButton').textContent = 'Disable';
        
        // Show difficulty override option
        document.getElementById('difficulty-override-option').style.display = 'flex';
        
        // Unlock all characters
        unlockedCharacters.apple = true;
        unlockedCharacters.carrot = true;
        unlockedCharacters.pumpkin = true;
        unlockedCharacters.happyface = true;
        unlockedCharacters.monster = true;
        unlockedCharacters.atom = true;
        unlockedCharacters.slime = true;
        unlockedCharacters.ufo = true;

        // Unlock all worlds
availableWorlds.forEach(world => {
    unlockedWorlds[world.id] = true;
});
        
        // Update UI
        updateCharactersInSettings();
        
        alert('Mod Mode enabled! All characters unlocked + Difficulty Override available.');
    } else {
        alert('Incorrect password!');
    }
} else {
    // Disabling mod mode
    modModeEnabled = false;
    document.getElementById('mod-mode-option').classList.remove('enabled');
    document.getElementById('modModeButton').textContent = 'Enable';
    document.getElementById('modPassword').value = '';
    
    // Hide difficulty override option
    document.getElementById('difficulty-override-option').style.display = 'none';
    difficultyOverride = -1; // Reset to normal
    
    // Reload the original unlocked state
    loadGameData(true);
    
    alert('Mod Mode disabled.');
}
            
            saveGameData('settings_change');



        }

// Apply difficulty override for testing
function applyDifficultyOverride() {
    const selectedLevel = parseInt(document.getElementById('difficultyOverride').value);
    difficultyOverride = selectedLevel;
    
    if (selectedLevel === -1) {
        alert('Difficulty override disabled. Using normal time-based progression.');
        // Reset to normal progression
        if (gameStarted && !gameOver) {
            resetDynamicDifficulty();
        }
    } else {
        const levelNames = ['Cruise', 'Accelerating', 'Intense', 'Blazing', 'Maximum Chaos'];
        alert(`Difficulty forced to Level ${selectedLevel + 1}: ${levelNames[selectedLevel]}`);
        
        // Immediately apply the override with full parameters
        currentSpeedLevel = selectedLevel;
        
        // Manually set speed based on level
        currentSpeed = baseSpeed + (currentSpeedLevel * speedIncrement);
        currentSpeed = Math.min(currentSpeed, maxSpeed);
        
        // Update speed multiplier for display
        currentSpeedMultiplier = currentSpeed / baseSpeed;
        
        // Update spawn rates based on level
        const speedProgress = currentSpeedLevel / speedIncreaseIntervals.length;
        if (currentSpeedLevel >= 3) {
            const adjustedProgress = 0.7 + (currentSpeedLevel - 3) * 0.15;
            currentObstacleSpawnRate = Math.floor(Math.max(
                baseObstacleSpawnRate - (adjustedProgress * (baseObstacleSpawnRate - minObstacleSpawnRate)),
                currentSpeedLevel >= 4 ? 25 : minObstacleSpawnRate
            ));
        } else {
            currentObstacleSpawnRate = Math.floor(Math.max(
                baseObstacleSpawnRate - (speedProgress * (baseObstacleSpawnRate - minObstacleSpawnRate)),
                minObstacleSpawnRate
            ));
        }
        
        // Update stream spawn rate
        if (currentSpeedLevel >= 3) {
            currentStreamSpawnRate = Math.floor(baseStreamSpawnRate * 1.2);
        } else {
            currentStreamSpawnRate = Math.floor(Math.max(
                baseStreamSpawnRate - (speedProgress * 0.2 * (baseStreamSpawnRate - minStreamSpawnRate)),
                minStreamSpawnRate
            ));
        }
        
        // Update visual speed indicator
        updateSpeedIndicator();
        
        debug(`Forced Level: ${currentSpeedLevel}, Speed: ${currentSpeed.toFixed(2)}, Obstacle Rate: ${currentObstacleSpawnRate}`);
    }
}
        
        // Reset game data
        function resetGameData() {
            if (confirm('Are you sure you want to reset all game data? This cannot be undone.')) {
                // Clear localStorage
                localStorage.removeItem('endlessRunnerData');
                
                // Reset game variables
totalCoins = 0;
modModeEnabled = false;
unlockedCharacters = {
    apple: true,
    carrot: false,
    pumpkin: false,
    happyface: false,
    monster: false,
    atom: false,
    slime: false,
    ufo: false
};
unlockedWorlds = {
    classic: true
};
currentCharacter = 'apple';
currentWorld = 'classic';
                
                // Update UI
                document.getElementById('mod-mode-option').classList.remove('enabled');
                document.getElementById('modModeButton').textContent = 'Enable';
                document.getElementById('modPassword').value = '';
                updateTotalCoins();
                updateCharactersInSettings();
                
                // Recreate player with default character
                createPlayer();
                
                alert('Game data has been reset.');
            }
        }
        
        // Load textures
        function loadTextures() {
            const textureLoader = new THREE.TextureLoader();
            
            // Create procedural grass texture for simplicity and guaranteed loading
            const grassCanvas = document.createElement('canvas');
            grassCanvas.width = 512;
            grassCanvas.height = 512;
            const grassCtx = grassCanvas.getContext('2d');
            
            // Base color - grass green
            grassCtx.fillStyle = '#4CAF50';
            grassCtx.fillRect(0, 0, 512, 512);
            
            // Add some texture/variation
            for (let i = 0; i < 2000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const size = Math.random() * 3 + 1;
                const brightness = Math.random() * 30 - 15;
                
                // Random shade of green
                const r = Math.max(0, Math.min(255, 76 + brightness));
                const g = Math.max(0, Math.min(255, 175 + brightness));
                const b = Math.max(0, Math.min(255, 80 + brightness));
                
                grassCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                grassCtx.fillRect(x, y, size, size);
            }
            
            // Create some grass blades
            for (let i = 0; i < 400; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const height = Math.random() * 10 + 5;
                const width = Math.random() * 2 + 1;
                
                grassCtx.fillStyle = '#2E7D32'; // Darker green for blades
                grassCtx.fillRect(x, y, width, height);
            }
            
            grassTexture = new THREE.CanvasTexture(grassCanvas);
            grassTexture.wrapS = THREE.RepeatWrapping;
            grassTexture.wrapT = THREE.RepeatWrapping;
            grassTexture.repeat.set(3, 20);
            
            // Create procedural water texture
            const waterCanvas = document.createElement('canvas');
            waterCanvas.width = 512;
            waterCanvas.height = 512;
            const waterCtx = waterCanvas.getContext('2d');
            
            // Base color - water blue
            waterCtx.fillStyle = '#1E88E5';
            waterCtx.fillRect(0, 0, 512, 512);
            
            // Add some wave effect
            for (let y = 0; y < 512; y += 8) {
                for (let x = 0; x < 512; x += 1) {
                    const brightness = Math.sin(y * 0.05 + x * 0.03) * 20;
                    const r = Math.max(0, Math.min(255, 30 + brightness));
                    const g = Math.max(0, Math.min(255, 136 + brightness));
                    const b = Math.max(0, Math.min(255, 229 + brightness));
                    
                    waterCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    waterCtx.fillRect(x, y, 1, 4);
                }
            }
            
            // Add some highlights
            for (let i = 0; i < 300; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const size = Math.random() * 2 + 1;
                
                waterCtx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                waterCtx.fillRect(x, y, size, size);
            }
            
            waterTexture = new THREE.CanvasTexture(waterCanvas);
            waterTexture.wrapS = THREE.RepeatWrapping;
            waterTexture.wrapT = THREE.RepeatWrapping;
            waterTexture.repeat.set(5, 1);
        }
        
        // Create ground with grass texture
function createGround() {
    // Create ground geometry
    const groundGeometry = new THREE.BoxGeometry(10, 0.5, 100);

    // Create material based on current world
    let groundMaterial;
    if (currentWorld === 'forest') {
        groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x2F4F2F, // Dark forest floor
            roughness: 0.9
        });
    } else if (currentWorld === 'desert') {
        groundMaterial = new THREE.MeshStandardMaterial({
            color: 0xF4A460, // Sandy brown
            roughness: 0.8
        });
    } else {
        // Classic world - use grass texture
        groundMaterial = new THREE.MeshStandardMaterial({
            map: grassTexture,
            roughness: 0.8,
            color: 0xffffff
        });
    }
    
    // Create multiple ground segments to ensure continuous ground coverage
    const numSegments = 8;
    
    for (let i = 0; i < numSegments; i++) {
        const segment = new THREE.Mesh(groundGeometry, groundMaterial);
        segment.position.y = -0.25;
        segment.position.z = -45 - (i * 50);
        scene.add(segment);
        groundSegments.push(segment);
        
        // Add dirt sides to each ground segment
        const dirtGeometry = new THREE.BoxGeometry(12, 1, 50.1);
        // Create dirt material based on world
        let dirtMaterial;
        if (currentWorld === 'forest') {
            dirtMaterial = new THREE.MeshStandardMaterial({
                color: 0x654321, // Dark brown forest soil
                roughness: 1
            });
        } else if (currentWorld === 'desert') {
            dirtMaterial = new THREE.MeshStandardMaterial({
                color: 0xCD853F, // Sandy rock color
                roughness: 0.9
            });
        } else {
            dirtMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513, // Classic brown dirt
                roughness: 1
            });
        }

        const dirtSide = new THREE.Mesh(dirtGeometry, dirtMaterial);
        dirtSide.position.y = -0.75;
        dirtSide.position.z = segment.position.z;
        scene.add(dirtSide);

        // Create side terrain material based on world
        let sideTerrainMaterial;
        if (currentWorld === 'forest') {
            sideTerrainMaterial = new THREE.MeshStandardMaterial({
                color: 0x1F4F2F, // Very dark forest green
                roughness: 1.0
            });
        } else if (currentWorld === 'desert') {
            sideTerrainMaterial = new THREE.MeshStandardMaterial({
                color: 0xDEB887, // Desert sand color
                roughness: 0.9
            });
        } else {
            // Classic world - use grass texture
            const wildGrassTexture = grassTexture.clone();
            wildGrassTexture.repeat.set(5, 30);
            sideTerrainMaterial = new THREE.MeshStandardMaterial({
                map: wildGrassTexture,
                roughness: 0.9,
                color: 0x88AA88
            });
        }

        // Left side terrain
        const leftTerrainGeometry = new THREE.BoxGeometry(50, 0.3, 100);
        const leftTerrain = new THREE.Mesh(leftTerrainGeometry, sideTerrainMaterial);
        leftTerrain.position.y = -0.15;
        leftTerrain.position.x = -30;
        leftTerrain.position.z = segment.position.z;
        scene.add(leftTerrain);
        sideTerrainSegments.push(leftTerrain);

        // Right side terrain
        const rightTerrainGeometry = new THREE.BoxGeometry(50, 0.3, 100);
        const rightTerrain = new THREE.Mesh(rightTerrainGeometry, sideTerrainMaterial);
        rightTerrain.position.y = -0.15;
        rightTerrain.position.x = 30;
        rightTerrain.position.z = segment.position.z;
        scene.add(rightTerrain);
        sideTerrainSegments.push(rightTerrain);

        // Left dirt underneath
        const leftDirtGeometry = new THREE.BoxGeometry(50, 1, 100);
        const leftDirt = new THREE.Mesh(leftDirtGeometry, dirtMaterial);
        leftDirt.position.y = -0.6;
        leftDirt.position.x = -30;
        leftDirt.position.z = segment.position.z;
        scene.add(leftDirt);
        sideTerrainSegments.push(leftDirt);

        // Right dirt underneath
        const rightDirtGeometry = new THREE.BoxGeometry(50, 1, 100);
        const rightDirt = new THREE.Mesh(rightDirtGeometry, dirtMaterial);
        rightDirt.position.y = -0.6;
        rightDirt.position.x = 30;
        rightDirt.position.z = segment.position.z;
        scene.add(rightDirt);
        sideTerrainSegments.push(rightDirt);
    }
}
        
        // Create a simple water stream with minimal visual effects
        function createWaterStream() {
            const streamGroup = new THREE.Group();
            
            // Water surface - spans way beyond visible area to look infinite
const waterGeometry = new THREE.BoxGeometry(150, 0.25, 3); // Much wider - extends off screen
const waterMaterial = new THREE.MeshStandardMaterial({
    color: 0x1E88E5, // Deep blue water
    roughness: 0.1,
    metalness: 0.3,
    // No transparency - this prevents flickering
});

const water = new THREE.Mesh(waterGeometry, waterMaterial);
water.position.y = -0.05; // Align with ground level
streamGroup.add(water);

// Add water surface highlights for realism
const highlightGeometry = new THREE.BoxGeometry(150, 0.01, 3); // Match full width
const highlightMaterial = new THREE.MeshStandardMaterial({
    color: 0x87CEEB, // Light blue highlight
    roughness: 0.05,
    metalness: 0.8,
    emissive: 0x003366,
    emissiveIntensity: 0.2
});

const highlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
highlight.position.y = 0.08; // On top of water
streamGroup.add(highlight);

// Clean river banks with better positioning
const bankGeometry = new THREE.BoxGeometry(150, 0.4, 0.6); // Full width banks
const bankMaterial = new THREE.MeshStandardMaterial({
    color: 0x8B4513, // Brown
    roughness: 0.9
});

// Front bank - positioned to create clean edge
const frontBank = new THREE.Mesh(bankGeometry, bankMaterial);
frontBank.position.z = -1.8;
frontBank.position.y = 0.05;
streamGroup.add(frontBank);

// Back bank - positioned to create clean edge
const backBank = new THREE.Mesh(bankGeometry, bankMaterial);
backBank.position.z = 1.8;
backBank.position.y = 0.05;
streamGroup.add(backBank);

// Add some sandy/muddy edges for realism
const edgeGeometry = new THREE.BoxGeometry(150, 0.1, 0.2); // Full width edges
const edgeMaterial = new THREE.MeshStandardMaterial({
    color: 0xD2B48C, // Sandy color
    roughness: 0.8
});

// Front edge
const frontEdge = new THREE.Mesh(edgeGeometry, edgeMaterial);
frontEdge.position.z = -1.4;
frontEdge.position.y = 0.02;
streamGroup.add(frontEdge);

// Back edge
const backEdge = new THREE.Mesh(edgeGeometry, edgeMaterial);
backEdge.position.z = 1.4;
backEdge.position.y = 0.02;
streamGroup.add(backEdge);
            
            // Add rocks and logs for visual interest only
            const numObjects = Math.floor(Math.random() * 3) + 2; // 2-4 objects
            
            for (let i = 0; i < numObjects; i++) {
                // 50% chance for rock, 50% chance for log
                const isRock = Math.random() > 0.5;
                
                if (isRock) {
                    const rockGeometry = new THREE.DodecahedronGeometry(0.2, 1);
                    const rockMaterial = new THREE.MeshStandardMaterial({
                        color: 0x808080,
                        roughness: 0.8
                    });
                    
                    const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                    rock.position.set(
                        Math.random() * 8 - 4,
                        0.1,
                        Math.random() * 2 - 1
                    );
                    rock.rotation.set(
                        Math.random() * Math.PI,
                        Math.random() * Math.PI,
                        Math.random() * Math.PI
                    );
                    streamGroup.add(rock);
                } else {
                    // Small log sticking out of water
                    const logGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
                    const logMaterial = new THREE.MeshStandardMaterial({
                        color: 0x8B4513,
                        roughness: 0.9
                    });
                    
                    const log = new THREE.Mesh(logGeometry, logMaterial);
                    log.position.set(
                        Math.random() * 8 - 4,
                        0.2,
                        Math.random() * 2 - 1
                    );
                    // Tilt the log
                    log.rotation.x = Math.random() * 0.3;
                    log.rotation.z = Math.random() * Math.PI;
                    streamGroup.add(log);
                }
            }
            
            // Position stream on the track
            streamGroup.position.z = -50; // Spawn far away
            streamGroup.position.y = 0;   // Align with ground
            
            scene.add(streamGroup);
            waterStreams.push(streamGroup);
            streamCreated = true;
            
            return streamGroup;
        }
        
        // Simplest possible water streams update - only moves them forward with no animations
        function updateWaterStreams() {
            for (let i = waterStreams.length - 1; i >= 0; i--) {
                const stream = waterStreams[i];
                
                // Just move stream forward
                stream.position.z += currentSpeed;
                
                // Check for collision
                if (checkCollision(stream)) {
                    if (!jumping) {
                        // Hit water stream without jumping - game over
                        endGame();
                    }
                }
                
                // Remove streams that have passed the player
                if (stream.position.z > 10) {
                    scene.remove(stream);
                    waterStreams.splice(i, 1);
                }
            }
        }
        
        // Create background scenery
        function createBackground() {
            // Create world-specific background
if (currentWorld === 'desert') {
    // Create desert mountains/mesas
    for (let i = 0; i < 15; i++) {
        const mesaHeight = Math.random() * 10 + 5;
        const mesaWidth = Math.random() * 12 + 8;
        
        // Flat-topped mesa
        const mesaGeometry = new THREE.CylinderGeometry(mesaWidth, mesaWidth * 1.2, mesaHeight, 8);
        const mesaMaterial = new THREE.MeshStandardMaterial({
            color: 0xCD853F, // Sandy rock color
            flatShading: true,
            roughness: 0.8
        });
        
        const mesa = new THREE.Mesh(mesaGeometry, mesaMaterial);
        
        // Position mesas in the background
        const distance = Math.random() * 400 + 150;
        const posX = Math.random() * 300 - 150;
        mesa.position.set(posX, mesaHeight / 2 - 3, -distance);
        
        scene.add(mesa);
    }
    
    // Add distant sand dunes
    for (let i = 0; i < 25; i++) {
        const duneGeometry = new THREE.SphereGeometry(Math.random() * 20 + 10, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
        const duneMaterial = new THREE.MeshStandardMaterial({
            color: 0xF4A460,
            roughness: 0.9
        });
        const dune = new THREE.Mesh(duneGeometry, duneMaterial);
        
        const distance = Math.random() * 200 + 80;
        const posX = Math.random() * 400 - 200;
        dune.position.set(posX, -2, -distance);
        dune.scale.set(1, 0.3, 1);
        
        scene.add(dune);
    }
} else if (currentWorld === 'forest') {
    // Create forest mountains
    for (let i = 0; i < 20; i++) {
        const mountainHeight = Math.random() * 15 + 8;
        const mountainWidth = Math.random() * 8 + 5;
        
        const mountainGeometry = new THREE.ConeGeometry(mountainWidth, mountainHeight, 16);
        const mountainMaterial = new THREE.MeshStandardMaterial({
            color: 0x2F4F2F, // Dark forest green
            flatShading: true,
            roughness: 0.9
        });
        
        const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
        
        // Position mountains in the background
        const distance = Math.random() * 300 + 100;
        const posX = Math.random() * 200 - 100;
        mountain.position.set(posX, mountainHeight / 2 - 5, -distance);
        
        scene.add(mountain);
    }
} else {
    // Classic world mountains with snow caps
    for (let i = 0; i < 20; i++) {
        const mountainHeight = Math.random() * 15 + 8;
        const mountainWidth = Math.random() * 8 + 5;
        
        const mountainGeometry = new THREE.ConeGeometry(mountainWidth, mountainHeight, 16);
        const mountainMaterial = new THREE.MeshStandardMaterial({
            color: 0x808080, // Gray for mountains
            flatShading: true,
            roughness: 0.9
        });
        
        const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
        
        // Add snow cap to mountain
        const snowCapGeometry = new THREE.ConeGeometry(mountainWidth * 0.7, mountainHeight * 0.2, 16);
        const snowMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff, // White for snow
            roughness: 0.5
        });
        const snowCap = new THREE.Mesh(snowCapGeometry, snowMaterial);
        snowCap.position.y = mountainHeight * 0.4;
        mountain.add(snowCap);
        
        // Position mountains in the background
        const distance = Math.random() * 300 + 100;
        const posX = Math.random() * 200 - 100;
        mountain.position.set(posX, mountainHeight / 2 - 5, -distance);
        
        scene.add(mountain);
    }
}
            
            // Create a sun in the sky
            const sunGeometry = new THREE.SphereGeometry(10, 32, 32);
            const sunMaterial = new THREE.MeshStandardMaterial({
                color: 0xffff00, // Yellow
                emissive: 0xffff00,
                emissiveIntensity: 1
            });
            const sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.position.set(70, 50, -300);
            scene.add(sun);
            
            // Create a moon
            const moonGeometry = new THREE.SphereGeometry(7, 32, 32);
            const moonMaterial = new THREE.MeshStandardMaterial({
                color: 0xDDDDDD, // Off-white
                emissive: 0xDDDDDD,
                emissiveIntensity: 0.5
            });
            const moon = new THREE.Mesh(moonGeometry, moonMaterial);
            moon.position.set(-70, 50, -300);
            scene.add(moon);
            
            // Add more detailed clouds
        for (let i = 0; i < (isMobile ? 15 : 30); i++) {
                const cloudGroup = new THREE.Group();
                
                // Create several spheres for a cloud with more variety
                const numSpheres = Math.floor(Math.random() * 5) + 5;
                for (let j = 0; j < numSpheres; j++) {
                    const size = Math.random() * 4 + 3;
                    const sphereGeometry = new THREE.SphereGeometry(size, 8, 8);
                    const cloudMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        roughness: 0.2,
                        metalness: 0
                    });
                    
                    const sphere = new THREE.Mesh(sphereGeometry, cloudMaterial);
                    sphere.position.set(
                        (Math.random() - 0.5) * 15,
                        (Math.random() - 0.5) * 3,
                        (Math.random() - 0.5) * 15
                    );
                    cloudGroup.add(sphere);
                }
                
                // Position cloud in sky with wider spread
                const distance = Math.random() * 400 + 100;
                const posX = Math.random() * 300 - 150;
                const posY = Math.random() * 40 + 20;
                cloudGroup.position.set(posX, posY, -distance);
                
                scene.add(cloudGroup);
            }
            
            // Add world-specific distant vegetation
if (currentWorld === 'desert') {
    // Add scattered desert plants
    for (let i = 0; i < (isMobile ? 20 : 80); i++) {
        const desertPlantGroup = new THREE.Group();
        
        // Random desert plant type
        const plantType = Math.random();
        
        if (plantType < 0.6) {
            // Small cactus
            const cactusGeometry = new THREE.CylinderGeometry(0.3, 0.4, 3, 8);
            const cactusMaterial = new THREE.MeshStandardMaterial({
                color: 0x228B22,
                roughness: 0.8
            });
            const cactus = new THREE.Mesh(cactusGeometry, cactusMaterial);
            cactus.position.y = 1.5;
            desertPlantGroup.add(cactus);
        } else {
            // Palm tree
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 4, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.8
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2;
            desertPlantGroup.add(trunk);
            
            // Palm fronds
            for (let j = 0; j < 6; j++) {
                const frondGeometry = new THREE.PlaneGeometry(0.5, 3);
                const frondMaterial = new THREE.MeshStandardMaterial({
                    color: 0x228B22,
                    side: THREE.DoubleSide
                });
                const frond = new THREE.Mesh(frondGeometry, frondMaterial);
                frond.position.y = 4.5;
                frond.rotation.y = (j / 6) * Math.PI * 2;
                frond.rotation.x = -Math.PI / 6;
                desertPlantGroup.add(frond);
            }
        }
        
        // Position at horizon
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 100 + 150;
        desertPlantGroup.position.set(
            Math.cos(angle) * radius,
            -5,
            -Math.sin(angle) * radius
        );
        
        scene.add(desertPlantGroup);
    }
} else if (currentWorld === 'forest') {
    // Dense dark forest
    for (let i = 0; i < (isMobile ? 80 : 300); i++) {
        const treeGroup = new THREE.Group();
        
        // Dark forest tree
        const trunkGeometry = new THREE.CylinderGeometry(1, 1.2, 8, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({
            color: 0x654321,
            roughness: 0.8
        });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.y = 4;
        treeGroup.add(trunk);
        
        // Dark pine-like canopy
        const leavesGeometry = new THREE.ConeGeometry(4, 12, 8);
        const leavesMaterial = new THREE.MeshStandardMaterial({
            color: 0x1F4F2F, // Very dark green
            roughness: 0.8
        });
        
        const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
        leaves.position.y = 10;
        treeGroup.add(leaves);
        
        // Position trees at horizon
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 100 + 150;
        treeGroup.position.set(
            Math.cos(angle) * radius,
            -5,
            -Math.sin(angle) * radius
        );
        
        scene.add(treeGroup);
    }
} else {
    // Classic world forest
    for (let i = 0; i < (isMobile ? 50 : 200); i++) {
        const treeGroup = new THREE.Group();
        
        // Tree trunk
        const trunkGeometry = new THREE.CylinderGeometry(1, 1.2, 5, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B4513,
            roughness: 0.7
        });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.y = 2.5;
        treeGroup.add(trunk);
        
        // Tree leaves - layered cones for more natural look
        const leavesGeometry = new THREE.ConeGeometry(3, 8, 8);
        const leavesMaterial = new THREE.MeshStandardMaterial({
            color: 0x228B22,
            roughness: 0.6
        });
        
        const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
        leaves.position.y = 7;
        treeGroup.add(leaves);
        
        // Position trees at horizon
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 100 + 150;
        treeGroup.position.set(
            Math.cos(angle) * radius,
            -5,
            -Math.sin(angle) * radius
        );
        
        // Add to scene
        scene.add(treeGroup);
    }
}
            
            // Add some hills in mid-distance
            for (let i = 0; i < 15; i++) {
                const hillGeometry = new THREE.SphereGeometry(20, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
                const hillMaterial = new THREE.MeshStandardMaterial({
                    color: 0x4CAF50, // Green
                    roughness: 0.8
                });
                
                const hill = new THREE.Mesh(hillGeometry, hillMaterial);
                
                // Position hill
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 60 + 80;
                hill.position.set(
                    Math.cos(angle) * radius,
                    -20,
                    -Math.sin(angle) * radius
                );
                
                scene.add(hill);
            }
            
            // Add some butterflies
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * 40 - 20;
                const y = Math.random() * 3 + 1;
                const z = Math.random() * 20 - 40;
                butterflyGroups.push(createButterfly(x, y, z));
            }
            
            // Add some birds
            for (let i = 0; i < 3; i++) {
                const x = Math.random() * 60 - 30;
                const y = Math.random() * 10 + 10;
                const z = Math.random() * 40 - 80;
                birds.push(createBird(x, y, z));
            }
        }
        
        
        
        // Create player based on selected character
        function createPlayer() {
            // Remove existing player if it exists
            if (player) {
                scene.remove(player);
            }

            // Create character based on selection
            switch (currentCharacter) {
    // CREATE PLAYER SWITCH INJECTION POINT - Package manager will add cases here
    case "apple": player = createAppleCharacter(); break;
    case "carrot": player = createCarrotCharacter(); break;
    case "pumpkin": player = createPumpkinCharacter(); break;
    case "happyface": player = createHappyFaceCharacter(); break;
    case "monster": player = createMonsterCharacter(); break;
    case "atom": player = createAtomCharacter(); break;
    case "slime": player = createSlimeCharacter(); break;
    case "ufo": player = createUFOCharacter(); break;
    case "robot": player = createRobotCharacter(); break;
    case "dragon": player = createDragonCharacter(); break;
    case "ghost": player = createGhostCharacter(); break;
    case "creature": player = createCreatureCharacter(); break;
    // END CREATE PLAYER SWITCH INJECTION POINT
    default:
        debugWarn(`Character ${currentCharacter} not yet extracted - using Happy Face`);
        currentCharacter = "happyface";
        player = createHappyFaceCharacter();
        break;
}

// After the switch statement, add this:
if (!player) {
    console.error('Failed to create player character! Falling back to Happy Face');
    player = createHappyFaceCharacter();
}

// Add null check before accessing player properties
if (player && player.position) {
    // Your existing code that uses player.position
} else {
    console.error('Player object is invalid:', player);
}
            
            // Set player position
player.position.y = playerY;
player.position.z = 0;
player.rotation.x = 0; // Reset rotation

// Make robot, dragon, and ghost face forward down the track
if (currentCharacter === 'robot' || currentCharacter === 'dragon' || currentCharacter === 'ghost') {
    player.rotation.y = Math.PI; // Face forward down the track
} else {
    player.rotation.y = 0; // Default orientation for other characters
}

scene.add(player);

// Initialize ability status bar for new character
if (typeof initializeAbilityStatusBar === 'function') {
    initializeAbilityStatusBar();
}
        }
        
        // Try to unlock a character
        function tryUnlockCharacter(character) {
            if (unlockedCharacters[character]) {
                // Already unlocked, select it
                selectCharacter(character);
                return;
            }
            
            const cost = characterCosts[character];
            if (totalCoins >= cost) {
                totalCoins -= cost;
                unlockedCharacters[character] = true;
                selectCharacter(character);
                updateTotalCoins();
                saveGameData('character_unlock');  // or 'world_unlock'
            } else {
                alert(`Not enough coins! You need ${cost} coins to unlock this character.`);
            }
        }
        
        // Select a character
        function selectCharacter(character) {
            if (!unlockedCharacters[character] && !modModeEnabled) return;
            
            currentCharacter = character;
            updateCharactersInSettings();
            createPlayer(); // Update the player model
            saveGameData();
        }
        


// ==================== GAME SAVE SYSTEM ====================
// This system ensures compatibility across all versions and devices
// =================================================================
// =================================================================

// ===== GOOGLE SIGN-IN SYSTEM =====
let isGoogleUser = false;

// Enable Google Sign-In in Firebase Console first!
// Enable Google Sign-In in Firebase Console first!
function signInWithGoogle() {
    if (!firebase.auth) {
        alert('‚ùå Authentication not available!');
        return;
    }
    
    const provider = new firebase.auth.GoogleAuthProvider();
    provider.addScope('profile');
    provider.addScope('email');
    
    firebase.auth().signInWithPopup(provider)
        .then((result) => {
            debug('‚úÖ Google sign-in successful!');
            const user = result.user;
            
            // Update player info
            playerId = user.uid;
            isGoogleUser = true;
            cloudSaveEnabled = true;
            
            debug('üë§ Signed in as:', user.displayName);
            debug('üìß Email:', user.email);
            
            // Merge anonymous data with Google account
            mergeAnonymousDataToGoogleAccount();
            
            // Hide the Google sign-in button on title screen
            const signInBtn = document.getElementById('googleSignInBtn');
            const authSection = document.getElementById('titleScreenAuth');
            if (signInBtn && authSection) {
                authSection.innerHTML = `
                    <p style="color: #34C759; font-size: 14px; margin: 10px 0;">
                        ‚úÖ Signed in as ${user.displayName}
                    </p>
                    <p style="color: #666; font-size: 12px; font-style: italic;">
                        Your progress syncs across all devices!
                    </p>
                `;
            }
            
            alert(`‚úÖ Signed in as ${user.displayName}!\nYour progress now syncs across all devices!`);
            
        })
        .catch((error) => {
            console.error('‚ùå Google sign-in failed:', error);
            alert('‚ùå Sign-in failed: ' + error.message);
        });
}

// Merge current anonymous progress to Google account
function mergeAnonymousDataToGoogleAccount() {
    if (!currentProfile || !playerId) return;
    
    debug('üîÑ Merging anonymous data to Google account...');
    
    // Check if Google account already has data
    firebase.database().ref('profiles/' + playerId + '/Default').once('value')
        .then((snapshot) => {
            const googleData = snapshot.val();
            
            if (googleData) {
                // Google account has existing data - ask player what to do
                const googleCoins = googleData.totalCoins || 0;
                const localCoins = currentProfile.totalCoins || 0;
                
                if (confirm(`You have progress on both devices!\n\nThis device: ${localCoins} coins\nGoogle account: ${googleCoins} coins\n\nKeep the higher amount?`)) {
                    if (localCoins > googleCoins) {
                        // Keep local data
                        saveProfile();
                    } else {
                        // Use Google data
                        currentProfile = validateAndMigrateProfile(googleData);
                        syncProfileToGameState();
                    }
                }
            } else {
                // No Google data - upload current progress
                debug('üì§ Uploading current progress to Google account...');
                saveProfile();
            }
            
            showSaveIndicator('‚òÅÔ∏è Google Synced');
        })
        .catch((error) => {
            debug('‚ö†Ô∏è Merge failed, saving current data:', error);
            saveProfile();
        });
}

// Sign out of Google
function signOutGoogle() {
    firebase.auth().signOut()
        .then(() => {
            debug('üëã Signed out of Google');
            
            // Revert to anonymous auth
            initializeCloudSave();
            
            alert('üëã Signed out! Your progress is now device-specific again.');
        })
        .catch((error) => {
            console.error('‚ùå Sign-out failed:', error);
        });
}

// ===== SAVE CODE SYSTEM =====
// Generate a transferable save code
function generateSaveCode() {
    if (!currentProfile || !playerId) {
        alert('‚ùå No save data available to export!');
        return null;
    }
    
    try {
        const exportData = {
            version: SAVE_VERSION,
            playerId: playerId,
            profileName: currentProfileName,
            profile: currentProfile,
            timestamp: Date.now(),
            deviceInfo: navigator.userAgent.substring(0, 50) // For reference
        };
        
        // Compress and encode the data
        const compressed = JSON.stringify(exportData);
        const encoded = btoa(compressed);
        
        // Create readable save code (format: BLITZ-XXXX-XXXX-XXXX)
        const codeBase = encoded.substring(0, 12).toUpperCase();
        const saveCode = `BLITZ-${codeBase.substring(0, 4)}-${codeBase.substring(4, 8)}-${codeBase.substring(8, 12)}`;
        
        debug('üíæ Save code generated:', saveCode);
        return { code: saveCode, fullData: encoded };
        
    } catch (error) {
        console.error('‚ùå Failed to generate save code:', error);
        alert('‚ùå Failed to generate save code!');
        return null;
    }
}

// Use a save code to restore progress
function useSaveCode(saveCode, fullData = null) {
    try {
        let decodedData;
        
        if (fullData) {
            // Use full data if provided
            decodedData = JSON.parse(atob(fullData));
        } else {
            // For now, save codes need the full data
            // In a real implementation, you'd store codes in Firebase
            alert('‚ùå Save codes need the full export data for now!');
            return false;
        }
        
        if (decodedData.version !== SAVE_VERSION) {
            debug('‚ö†Ô∏è Save code is from different version, attempting migration...');
        }
        
        // Validate the data
        if (!decodedData.profile || !decodedData.playerId) {
            throw new Error('Invalid save code data');
        }
        
        debug('üì• Restoring save from code...');
        debug(`üí∞ Restoring ${decodedData.profile.totalCoins} coins`);
        debug(`üë§ Restoring character: ${decodedData.profile.currentCharacter}`);
        
        // Apply the restored profile
        currentProfile = validateAndMigrateProfile(decodedData.profile);
        currentProfileName = decodedData.profileName || "Restored";
        
        // Sync to game state
        syncProfileToGameState();
        
        // Save the restored profile locally and to cloud
        saveProfile();
        
        alert(`‚úÖ Progress restored!\nüí∞ ${currentProfile.totalCoins} coins\nüë§ Character: ${currentProfile.currentCharacter}`);
        
        return true;
        
    } catch (error) {
        console.error('‚ùå Failed to use save code:', error);
        alert('‚ùå Invalid save code!');
        return false;
    }
}

// Show save code to player
function showSaveCode() {
    const result = generateSaveCode();
    if (!result) return;
    
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center;
        z-index: 10000; font-family: Arial, sans-serif;
    `;
    
    modal.innerHTML = `
        <div style="background: white; padding: 30px; border-radius: 15px; max-width: 500px; text-align: center;">
            <h2 style="color: #333; margin-bottom: 20px;">üì± Transfer Your Progress</h2>
            <p style="color: #666; margin-bottom: 20px;">Use this code to restore your progress on any device:</p>
            
            <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin: 20px 0;">
                <h3 style="color: #333; margin: 0 0 10px 0;">Save Code:</h3>
                <div style="font-size: 24px; font-weight: bold; color: #007AFF; letter-spacing: 2px;">${result.code}</div>
            </div>
            
            <textarea readonly style="width: 100%; height: 60px; font-size: 10px; margin: 10px 0; padding: 10px;" 
                onclick="this.select()">${result.fullData}</textarea>
            <p style="font-size: 12px; color: #999;">Copy both the code AND the text above</p>
            
            <div style="margin-top: 20px;">
                <button onclick="this.parentElement.parentElement.parentElement.remove()" 
                    style="background: #007AFF; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 16px;">
                    Done
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// Show restore from code dialog
function showRestoreCode() {
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center;
        z-index: 10000; font-family: Arial, sans-serif;
    `;
    
    modal.innerHTML = `
        <div style="background: white; padding: 30px; border-radius: 15px; max-width: 500px; text-align: center;">
            <h2 style="color: #333; margin-bottom: 20px;">üì• Restore Your Progress</h2>
            <p style="color: #666; margin-bottom: 20px;">Enter your save code and data:</p>
            
            <input type="text" id="saveCodeInput" placeholder="BLITZ-XXXX-XXXX-XXXX" 
                style="width: 100%; padding: 12px; margin: 10px 0; border: 2px solid #ddd; border-radius: 8px; text-align: center; font-size: 16px; letter-spacing: 1px;">
            
            <textarea id="saveDataInput" placeholder="Paste the full save data here..." 
                style="width: 100%; height: 80px; padding: 12px; margin: 10px 0; border: 2px solid #ddd; border-radius: 8px; font-size: 12px;"></textarea>
            
            <div style="margin-top: 20px;">
                <button onclick="restoreFromInputs()" 
                    style="background: #34C759; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 16px; margin-right: 10px;">
                    Restore Progress
                </button>
                <button onclick="this.parentElement.parentElement.parentElement.remove()" 
                    style="background: #666; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 16px;">
                    Cancel
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// Restore from save code
function restoreFromInputs() {
    const code = document.getElementById('saveCodeInput').value.trim();
    const data = document.getElementById('saveDataInput').value.trim();
    
    if (!code || !data) {
        alert('‚ùå Please enter both the save code and data!');
        return;
    }
    
    try {
        const decodedData = JSON.parse(atob(data));
        
        debug('üì• Restoring save from code...');
        debug(`üí∞ Restoring ${decodedData.profile.totalCoins} coins`);
        
        currentProfile = validateAndMigrateProfile(decodedData.profile);
        currentProfileName = decodedData.profileName || "Restored";
        
        syncProfileToGameState();
        saveGameData('manual_save');
        
        alert(`‚úÖ Progress restored!\nüí∞ ${currentProfile.totalCoins} coins\nüë§ Character: ${currentProfile.currentCharacter}`);
        
        document.querySelector('[style*="z-index: 10000"]').remove();
        
    } catch (error) {
        console.error('‚ùå Failed to restore save:', error);
        alert('‚ùå Invalid save code or data!');
    }
}

function showTitleSettings() {
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center;
        z-index: 10000; font-family: Arial, sans-serif;
    `;
    
    // Check if user is signed in with Google
    const currentUser = firebase.auth().currentUser;
    const isSignedIn = currentUser && !currentUser.isAnonymous;
    
    modal.innerHTML = `
        <div style="
        background: rgba(0, 20, 40, 0.95);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        padding: 30px;
        border-radius: 20px;
        max-width: 400px;
        text-align: center;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    ">
            <h2 style="color: white; margin-bottom: 20px; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">‚öôÔ∏è Settings</h2>
            
            <!-- Audio Settings -->
            <div style="margin: 20px 0; text-align: left;">
                <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                    <input type="checkbox" id="titleMusicCheckbox" ${backgroundMusicEnabled ? 'checked' : ''} 
                        onchange="backgroundMusicEnabled = this.checked; saveGameData('settings_change');"
                        style="margin-right: 10px; transform: scale(1.2);">
                    <span style="font-size: 16px; color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.5);">üéµ Background Music</span>
                </label>
                
                <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                    <input type="checkbox" id="titleSoundCheckbox" ${soundEffectsEnabled ? 'checked' : ''} 
                        onchange="soundEffectsEnabled = this.checked; saveGameData('settings_change');"
                        style="margin-right: 10px; transform: scale(1.2);">
                    <span style="font-size: 16px; color: white; text-shadow: 0 1px 2px rgba(0,0,0,0.5);">üîä Sound Effects</span>
                </label>
            </div>
            
            <hr style="margin: 20px 0; border: none; border-top: 1px solid #eee;">
            
            <!-- Save System -->
            <div style="margin: 20px 0;">
                <h3 style="color: white; margin-bottom: 15px; text-shadow: 0 1px 3px rgba(0,0,0,0.5);">üíæ Save System</h3>
                
                ${isSignedIn ? `
                    <p style="color: #34C759; margin-bottom: 15px;">
                        ‚úÖ Signed in as ${currentUser.displayName}<br>
                        <small style="color: #666;">Your progress syncs across all devices!</small>
                    </p>
                    <button onclick="signOutGoogle(); this.parentElement.parentElement.parentElement.remove();" 
                        style="background: #666; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; margin: 5px;">
                        Sign Out
                    </button>
                ` : `
                    <button onclick="signInWithGoogle(); this.parentElement.parentElement.parentElement.remove();" 
                        style="background: #4285f4; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; margin: 5px;">
                        üîó Sign in with Google
                    </button>
                `}
                
                <br>
                
                <button onclick="showSaveCode()" 
                    style="background: #34C759; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; margin: 5px;">
                    üì± Get Save Code
                </button>
                
                <button onclick="showRestoreCode()" 
                    style="background: #FF9500; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; margin: 5px;">
                    üì• Use Save Code
                </button>
            </div>
            
            <hr style="margin: 20px 0; border: none; border-top: 1px solid #eee;">
            
            <!-- Close Button -->
            <button onclick="this.parentElement.parentElement.remove()" 
                style="background: #007AFF; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 16px;">
                Done
            </button>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// Current save system version - increment when making breaking changes
const SAVE_VERSION = "1.0";
const GAME_ID = "runningBlitzEndlessRunner";

// Default save profile template
const DEFAULT_PROFILE = {
    version: SAVE_VERSION,
    gameId: GAME_ID,
    created: null,
    lastPlayed: null,
    
    // Player progress
    totalCoins: 0,
    highScore: 0,
    totalGamesPlayed: 0,
    totalTimePlayed: 0, // in seconds
    
    // Character data
currentCharacter: 'apple',
unlockedCharacters: {
    apple: true,
    carrot: false,
    pumpkin: false,
    happyface: false,
    monster: false,
    atom: false,
    slime: false,
    ufo: false,
    robot: false,
    dragon: false,
    ghost: false
},

// World data
currentWorld: 'classic',
unlockedWorlds: {
    classic: true
},
    
    // Settings
    soundEffectsEnabled: true,
    backgroundMusicEnabled: true,
    currentTrack: 'ambient',
    modModeEnabled: false,
    
    // Leaderboard (moved into profile)
    personalBests: [],
    
    // Achievement system (ready for future)
    achievements: {},
    unlockedAchievements: [],
    
    // Statistics (ready for future)
    stats: {
        coinsCollected: 0,
        obstaclesAvoided: 0,
        streamsJumped: 0,
        powerUpsCollected: 0,
        meteorsAvoided: 0,
        characterUsageTime: {}
    },
    
    // Future expansion data
    customData: {}
};

// Current active profile
let currentProfile = null;
let currentProfileName = "Default";

// ADD THESE CLOUD SAVE VARIABLES
let playerId = null;
let cloudSaveEnabled = false;

// Initialize Firebase Auth (anonymous)
function initializeCloudSave() {
    firebase.auth().signInAnonymously()
        .then((userCredential) => {
            playerId = userCredential.user.uid;
            cloudSaveEnabled = true;
            debug('üî• Cloud save enabled! Player ID:', playerId.substring(0, 8) + '...');
            
            // Try to sync existing profile with cloud
            syncProfileWithCloud();
        })
        .catch((error) => {
            debug('‚ö†Ô∏è Cloud save unavailable, using local storage:', error);
            cloudSaveEnabled = false;
        });
}

// Visual save indicator
function showSaveIndicator(message) {
    let indicator = document.getElementById('saveIndicator');
    if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'saveIndicator';
        indicator.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        `;
        document.body.appendChild(indicator);
    }
    
    indicator.textContent = message;
    indicator.style.opacity = '1';
    
    setTimeout(() => {
        indicator.style.opacity = '0';
    }, 2000);
}

// Sync profile with cloud when Firebase connects
function syncProfileWithCloud() {
    if (!cloudSaveEnabled || !playerId || !currentProfileName) return;
    
    // Check if cloud has newer data
    firebase.database().ref('profiles/' + playerId + '/' + currentProfileName).once('value')
        .then((snapshot) => {
            const cloudProfile = snapshot.val();
            
            if (cloudProfile) {
                const cloudTime = new Date(cloudProfile.lastPlayed || 0).getTime();
                const localTime = new Date(currentProfile.lastPlayed || 0).getTime();
                
                if (cloudTime > localTime) {
                    debug('‚òÅÔ∏è Cloud profile is newer, syncing down...');
                    currentProfile = validateAndMigrateProfile(cloudProfile);
                    syncProfileToGameState();
                    showSaveIndicator('‚òÅÔ∏è Cloud Synced');
                } else {
                    debug('üíæ Local profile is newer, syncing up...');
                    saveProfile(); // This will upload to cloud
                }
            } else {
                debug('‚òÅÔ∏è No cloud profile found, uploading local...');
                saveProfile(); // Upload current profile to cloud
            }
        })
        .catch((error) => {
            debug('‚ö†Ô∏è Cloud sync failed:', error);
        });
}



// Initialize save system
function initializeSaveSystem() {
    debug('üóÑÔ∏è Initializing future-proof save system...');
    
    // Check for legacy save data and migrate
    migrateLegacySaveData();
    
    // Load or create default profile
    loadProfile("Default");
    
    // Initialize cloud save after profile is loaded
    setTimeout(() => {
        initializeCloudSave();
    }, 1000);
    
    // Load global leaderboard after cloud save is ready
    setTimeout(() => {
        if (cloudSaveEnabled) {
            loadGlobalLeaderboard(); // Load global scores on startup
        }
    }, 3000);
    
    debug('‚úÖ Save system initialized successfully!');
}

// Migrate old save data to new profile system
function migrateLegacySaveData() {
    try {
        // Check if migration has already been completed
        const migrationComplete = localStorage.getItem('runningBlitzEndlessRunner_migrationComplete');
        if (migrationComplete) {
            debug('‚ÑπÔ∏è Legacy migration already completed - skipping');
            return;
        }
        
        // Check for old save format
        const legacySaveData = localStorage.getItem('endlessRunnerData');
        const legacyLeaderboard = localStorage.getItem('endlessRunnerLeaderboard');
        
        if (legacySaveData) {
            debug('üì¶ Found legacy save data - migrating...');
            
            const oldData = JSON.parse(legacySaveData);
            
            // Create new profile with legacy data
            const migratedProfile = JSON.parse(JSON.stringify(DEFAULT_PROFILE));
            
            // Migrate all the old data
            migratedProfile.totalCoins = oldData.totalCoins || 0;
            migratedProfile.currentCharacter = oldData.currentCharacter || 'apple';
            migratedProfile.currentWorld = oldData.currentWorld || 'classic';
            migratedProfile.unlockedWorlds = oldData.unlockedWorlds || {classic: true};
            migratedProfile.soundEffectsEnabled = oldData.soundEffectsEnabled !== undefined ? oldData.soundEffectsEnabled : true;
            migratedProfile.backgroundMusicEnabled = oldData.backgroundMusicEnabled !== undefined ? oldData.backgroundMusicEnabled : true;
            migratedProfile.modModeEnabled = oldData.modModeEnabled || false;
            
            // Migrate character unlocks
            if (oldData.unlockedCharacters) {
                Object.keys(oldData.unlockedCharacters).forEach(char => {
                    if (migratedProfile.unlockedCharacters.hasOwnProperty(char)) {
                        migratedProfile.unlockedCharacters[char] = oldData.unlockedCharacters[char];
                    }
                });
            }
            
            // Set timestamps
            migratedProfile.created = new Date().toISOString();
            migratedProfile.lastPlayed = new Date().toISOString();
            migratedProfile.profileId = generateProfileId();
            migratedProfile.profileName = "Default";
            
            // Migrate leaderboard if it exists
            if (legacyLeaderboard) {
                try {
                    const oldLeaderboard = JSON.parse(legacyLeaderboard);
                    migratedProfile.personalBests = oldLeaderboard;
                } catch (e) {
                    debug('‚ö†Ô∏è Could not migrate leaderboard data');
                }
            }
            
            // Save the migrated profile
            const saveKey = `${GAME_ID}_profile_Default`;
            localStorage.setItem(saveKey, JSON.stringify(migratedProfile));
            updateProfileList("Default");
            
            debug('‚úÖ Legacy data migrated successfully!');
            debug(`üí∞ Restored ${migratedProfile.totalCoins} coins`);
            debug(`üë§ Restored character: ${migratedProfile.currentCharacter}`);
            
            // Keep the old data for a while as backup, but mark it as migrated
            localStorage.setItem('endlessRunnerData_migrated', legacySaveData);
            
            // Mark migration as complete
            localStorage.setItem('runningBlitzEndlessRunner_migrationComplete', 'true');
            
        } else {
            debug('‚ÑπÔ∏è No legacy save data found - starting fresh');
            // Still mark migration as complete so we don't check again
            localStorage.setItem('runningBlitzEndlessRunner_migrationComplete', 'true');
        }
        
    } catch (error) {
        console.error('‚ùå Error during legacy migration:', error);
        debug('üîÑ Creating fresh profile instead');
        // Mark migration as complete even if it failed
        localStorage.setItem('runningBlitzEndlessRunner_migrationComplete', 'true');
    }
}

// Create a new profile
function createProfile(profileName, baseProfile = null) {
    const profile = baseProfile ? JSON.parse(JSON.stringify(baseProfile)) : JSON.parse(JSON.stringify(DEFAULT_PROFILE));
    
    profile.created = new Date().toISOString();
    profile.lastPlayed = new Date().toISOString();
    
    // Generate unique ID for cross-device sync
    profile.profileId = generateProfileId();
    profile.profileName = profileName;
    
    return profile;
}

// Generate unique profile ID
function generateProfileId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
}

// Save current profile (Cloud Enhanced) - with save reasons
function saveProfile(profileName = currentProfileName, saveReason = 'general') {
    if (!currentProfile) {
        console.error('‚ùå No active profile to save!');
        return false;
    }
    
    // Define which reasons should show the save indicator
    const importantSaveReasons = [
        'game_end',
        'character_unlock',
        'world_unlock', 
        'high_score',
        'major_purchase',
        'settings_change',
        'manual_save'
    ];
    
    const showIndicator = importantSaveReasons.includes(saveReason);
    
    try {
        // Update timestamps and current data
        currentProfile.lastPlayed = new Date().toISOString();
        currentProfile.version = SAVE_VERSION;
        
        // Sync current game state to profile
        syncGameStateToProfile();
        
        // Save to localStorage with versioned key (local backup)
        const saveKey = `${GAME_ID}_profile_${profileName}`;
        localStorage.setItem(saveKey, JSON.stringify(currentProfile));
        
        // Update profile list
        updateProfileList(profileName);
        
        // Save to cloud if available
        if (cloudSaveEnabled && playerId) {
            firebase.database().ref('profiles/' + playerId + '/' + profileName).set(currentProfile)
                .then(() => {
                    debug(`‚òÅÔ∏è Profile "${profileName}" saved to cloud! (${saveReason})`);
                    if (showIndicator) {
                        showSaveIndicator('‚òÅÔ∏è Progress Saved');
                    }
                })
                .catch((error) => {
                    debug('‚ö†Ô∏è Cloud save failed, local backup saved:', error);
                    if (showIndicator) {
                        showSaveIndicator('üíæ Local Saved');
                    }
                });
        } else {
            if (showIndicator) {
                showSaveIndicator('üíæ Progress Saved');
            }
        }
        
        debug(`üíæ Profile "${profileName}" saved successfully! (${saveReason})`);
        return true;
        
    } catch (error) {
        console.error('‚ùå Failed to save profile:', error);
        return false;
    }
}

// Load profile
function loadProfile(profileName) {
    try {
        const saveKey = `${GAME_ID}_profile_${profileName}`;
        const savedData = localStorage.getItem(saveKey);
        
        if (savedData) {
            debug(`üìÇ Loading profile "${profileName}"...`);
            
            const profile = JSON.parse(savedData);
            
            // Validate and migrate if necessary
            currentProfile = validateAndMigrateProfile(profile);
            currentProfileName = profileName;
            
            // Apply profile data to game state
            syncProfileToGameState();
            
            debug(`‚úÖ Profile "${profileName}" loaded successfully!`);
debug(`üí∞ Current balance: ${currentProfile.totalCoins} coins`);
debug(`üë§ Current character: ${currentProfile.currentCharacter}`);
            
        } else {
            // Create new profile
            debug(`üÜï Creating new profile "${profileName}"...`);
            
            currentProfile = createProfile(profileName);
            currentProfileName = profileName;
            
            // Set default game state
            syncProfileToGameState();
            
            // Save the new profile
            saveProfile(profileName);
        }
        
        return true;
        
    } catch (error) {
        console.error('‚ùå Failed to load profile:', error);
        
        // Fallback to default profile
        currentProfile = createProfile(profileName);
        currentProfileName = profileName;
        syncProfileToGameState();
        
        return false;
    }
}

// Validate and migrate profile data
function validateAndMigrateProfile(profile) {
    debug(`üîÑ Validating profile (version: ${profile.version || 'unknown'})...`);
    
    // Create a clean profile with current structure
    const migratedProfile = JSON.parse(JSON.stringify(DEFAULT_PROFILE));
    
    // Copy over valid data from old profile
    if (profile.version) {
        migratedProfile.version = profile.version;
    }
    
    // Migrate basic data (always compatible)
    migratedProfile.totalCoins = profile.totalCoins || 0;
    migratedProfile.currentCharacter = profile.currentCharacter || 'apple';
    migratedProfile.currentWorld = profile.currentWorld || 'classic';
    migratedProfile.soundEffectsEnabled = profile.soundEffectsEnabled !== undefined ? profile.soundEffectsEnabled : true;
    migratedProfile.backgroundMusicEnabled = profile.backgroundMusicEnabled !== undefined ? profile.backgroundMusicEnabled : true;
    migratedProfile.modModeEnabled = profile.modModeEnabled || false;
    
    // Migrate character unlocks (merge with new characters)
    if (profile.unlockedCharacters) {
        Object.keys(profile.unlockedCharacters).forEach(char => {
            if (migratedProfile.unlockedCharacters.hasOwnProperty(char)) {
                migratedProfile.unlockedCharacters[char] = profile.unlockedCharacters[char];
            }
        });
    }

    // Migrate world unlocks (merge with new worlds)
if (profile.unlockedWorlds) {
    Object.keys(profile.unlockedWorlds).forEach(world => {
        if (migratedProfile.unlockedWorlds.hasOwnProperty(world)) {
            migratedProfile.unlockedWorlds[world] = profile.unlockedWorlds[world];
        }
    });
}
    
    // Migrate leaderboard data
    if (profile.personalBests) {
        migratedProfile.personalBests = profile.personalBests;
    }
    
    // Migrate timestamps
    migratedProfile.created = profile.created || new Date().toISOString();
    migratedProfile.lastPlayed = new Date().toISOString();
    
    // Migrate profile ID
    migratedProfile.profileId = profile.profileId || generateProfileId();
    migratedProfile.profileName = profile.profileName || currentProfileName;
    
    // Migrate stats (if they exist)
    if (profile.stats) {
        Object.keys(profile.stats).forEach(stat => {
            if (migratedProfile.stats.hasOwnProperty(stat)) {
                migratedProfile.stats[stat] = profile.stats[stat];
            }
        });
    }
    
    // Migrate custom data for future compatibility
    if (profile.customData) {
        migratedProfile.customData = profile.customData;
    }
    
    // Update version
    migratedProfile.version = SAVE_VERSION;
    
    debug('‚úÖ Profile validation and migration completed!');
    return migratedProfile;
}

// Sync current game state to profile
function syncGameStateToProfile() {
    if (!currentProfile) return;

    debug('üîÑ Syncing game state to profile...');
    debug('Current totalCoins in game:', totalCoins);
    debug('Current totalCoins in profile before sync:', currentProfile.totalCoins);
    
    currentProfile.totalCoins = totalCoins;
    currentProfile.currentCharacter = currentCharacter;
    currentProfile.unlockedCharacters = {...unlockedCharacters};
    currentProfile.currentWorld = currentWorld;
    currentProfile.unlockedWorlds = {...unlockedWorlds};
    currentProfile.soundEffectsEnabled = soundEffectsEnabled;
    currentProfile.backgroundMusicEnabled = backgroundMusicEnabled;
    currentProfile.modModeEnabled = modModeEnabled;
    currentProfile.currentTrack = currentTrack;

    debug('Current totalCoins in profile after sync:', currentProfile.totalCoins);

    
    // Update high score
    if (score > (currentProfile.highScore || 0)) {
        currentProfile.highScore = score;
    }
    
    // Sync leaderboard
    currentProfile.personalBests = [...leaderboard];
}

// Sync profile data to game state
function syncProfileToGameState() {
    if (!currentProfile) return;

    debug('üìÇ Syncing profile to game state...');
    debug('Profile totalCoins:', currentProfile.totalCoins);
    debug('Game totalCoins before sync:', totalCoins);
    
    totalCoins = currentProfile.totalCoins || 0;
    currentCharacter = currentProfile.currentCharacter || 'apple';
    unlockedCharacters = {...currentProfile.unlockedCharacters};
    currentWorld = currentProfile.currentWorld || 'classic';
    unlockedWorlds = currentProfile.unlockedWorlds || {classic: true};
    soundEffectsEnabled = currentProfile.soundEffectsEnabled !== undefined ? currentProfile.soundEffectsEnabled : true;
    backgroundMusicEnabled = currentProfile.backgroundMusicEnabled !== undefined ? currentProfile.backgroundMusicEnabled : true;
    modModeEnabled = currentProfile.modModeEnabled || false;
    currentTrack = currentProfile.currentTrack || 'ambient';
    selectedTrack = currentTrack;

    debug('Game totalCoins after sync:', totalCoins);

    
    // Sync leaderboard
    if (currentProfile.personalBests) {
        leaderboard = [...currentProfile.personalBests];
        if (leaderboard.length > 0) {
            currentHighScore = leaderboard[0].score;
        }
    }
    
    // Update UI elements
    updateTotalCoins();
    updateLeaderboardDisplay();
    
    // Update checkboxes
    setTimeout(() => {
        const soundCheckbox = document.getElementById('soundEffectsCheckbox');
        const musicCheckbox = document.getElementById('backgroundMusicCheckbox');
        
        if (soundCheckbox) soundCheckbox.checked = soundEffectsEnabled;
        if (musicCheckbox) musicCheckbox.checked = backgroundMusicEnabled;
    }, 100);
}

// Update global leaderboard display in pause menu tab
function updateGlobalLeaderboardDisplay() {
    const tbody = document.getElementById('globalLeaderboardBody');
    const rankDisplay = document.getElementById('globalPlayerRank');
    
    if (!tbody) return;
    
    // Load fresh data
    loadGlobalLeaderboard();
    
    setTimeout(() => {
        // Clear existing content
        tbody.innerHTML = '';
        
        if (globalLeaderboard.length === 0) {
            tbody.innerHTML = `
                <tr>
                    <td colspan="4" style="text-align: center; padding: 40px; color: white;">
                        üèÜ Be the first on the global leaderboard!<br>
                        <small style="color: #ccc;">Complete a game to see your score here!</small>
                    </td>
                </tr>
            `;
            return;
        }
        
        // Add top 15 scores (more than local leaderboard)
        globalLeaderboard.slice(0, 15).forEach((entry, index) => {
            const rank = index + 1;
            const isCurrentPlayer = entry.playerId === playerId;
            
            let rankDisplay = `#${rank}`;
            if (rank === 1) rankDisplay = 'ü•á';
            else if (rank === 2) rankDisplay = 'ü•à';
            else if (rank === 3) rankDisplay = 'ü•â';
            
            const rowStyle = isCurrentPlayer ? 'background: rgba(0, 255, 0, 0.1); color: #00FF00;' : '';
            
            tbody.innerHTML += `
                <tr style="${rowStyle}">
                    <td>${rankDisplay}</td>
                    <td>${entry.playerName || 'Anonymous'}</td>
                    <td>${entry.score.toLocaleString()}</td>
                    <td>${entry.character}</td>
                </tr>
            `;
        });
        
        // Update player rank display
        if (playerGlobalRank && rankDisplay) {
            rankDisplay.textContent = `üèÜ Your Global Rank: #${playerGlobalRank} out of ${globalLeaderboard.length} players`;
            rankDisplay.style.color = '#FFD700';
        } else if (rankDisplay) {
            rankDisplay.textContent = `üåç ${globalLeaderboard.length} players competing worldwide`;
            rankDisplay.style.color = '#ccc';
        }
        
    }, 1000); // Wait for data to load
}

// Update profile list in localStorage
function updateProfileList(profileName) {
    try {
        const profileListKey = `${GAME_ID}_profiles`;
        let profileList = [];
        
        const savedList = localStorage.getItem(profileListKey);
        if (savedList) {
            profileList = JSON.parse(savedList);
        }
        
        // Add profile to list if not already there
        if (!profileList.includes(profileName)) {
            profileList.push(profileName);
            localStorage.setItem(profileListKey, JSON.stringify(profileList));
        }
        
    } catch (error) {
        console.error('‚ùå Failed to update profile list:', error);
    }
}

// Get list of all profiles
function getProfileList() {
    try {
        const profileListKey = `${GAME_ID}_profiles`;
        const savedList = localStorage.getItem(profileListKey);
        
        if (savedList) {
            return JSON.parse(savedList);
        }
        
        return ["Default"];
        
    } catch (error) {
        console.error('‚ùå Failed to get profile list:', error);
        return ["Default"];
    }
}

// Export profile data (for sharing between devices)
function exportProfile(profileName = currentProfileName) {
    try {
        const saveKey = `${GAME_ID}_profile_${profileName}`;
        const profileData = localStorage.getItem(saveKey);
        
        if (profileData) {
            const exportData = {
                exportDate: new Date().toISOString(),
                gameVersion: SAVE_VERSION,
                profileName: profileName,
                profileData: JSON.parse(profileData)
            };
            
            return JSON.stringify(exportData, null, 2);
        }
        
        return null;
        
    } catch (error) {
        console.error('‚ùå Failed to export profile:', error);
        return null;
    }
}

// Import profile data (for sharing between devices)
function importProfile(exportedData, newProfileName = null) {
    try {
        const importData = JSON.parse(exportedData);
        
        // Validate import data
        if (!importData.profileData || !importData.gameVersion) {
            throw new Error('Invalid export data format');
        }
        
        const profileName = newProfileName || importData.profileName || "Imported";
        const profile = validateAndMigrateProfile(importData.profileData);
        
        profile.profileName = profileName;
        
        // Save imported profile
        const saveKey = `${GAME_ID}_profile_${profileName}`;
        localStorage.setItem(saveKey, JSON.stringify(profile));
        
        updateProfileList(profileName);
        
        debug(`üì• Profile "${profileName}" imported successfully!`);
        return true;
        
    } catch (error) {
        console.error('‚ùå Failed to import profile:', error);
        return false;
    }
}

// Wrapper functions for compatibility
function saveGameData(reason = 'general') {
    saveProfile(currentProfileName, reason);
}

function loadGameData(ignoreModMode = false) {
    // The new system handles mod mode automatically
    syncProfileToGameState();
}
        
        // Update total coins display
        function updateTotalCoins() {
            document.getElementById('totalCoins').textContent = `Coins: ${totalCoins}`;
        }
        
        function startGame() {

                // ADD THIS LINE AT THE START
    saveGameData(); // Save current state when starting

// Reset power-up states at game start
shieldActive = false;
coinMultiplierActive = false;
magnetActive = false;
powerUpTimers = {};

// Initialize status bars
initializePowerUpStatusBar();
initializeAbilityStatusBar();
    
    document.getElementById('startScreen').style.display = 'none';

            // Hide any remaining screens
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('characterSelectScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('pauseScreen').style.display = 'none';
            document.getElementById('settingsScreen').style.display = 'none';
            document.getElementById('modalOverlay').style.display = 'none';
            
            // Show game UI elements
            document.getElementById('pauseBtn').style.display = 'block';
            document.getElementById('speedIndicator').style.display = 'block';
            if (isMobile) {
                document.getElementById('swipeInstructions').style.display = 'block';
            }
            
            // Update game state
            gameState = "playing";

// Apply current world settings
const selectedWorld = availableWorlds.find(w => w.id === currentWorld);
if (selectedWorld) {
    applyWorldSettings(selectedWorld);
}

            gameStarted = true;
            gameOver = false;
            gamePaused = false;

            
            
            // Reset game variables
            score = 0;
            distanceTraveled = 0;
            streamSpawnCounter = 0;
            streamCreated = false;
            
            // Reset dynamic difficulty
            resetDynamicDifficulty();
            
            updateScore();

// Start background music with debugging and fallback
debug('üéµ Attempting to start background music...');
debug('üéµ Audio initialized:', audioInitialized);
debug('üéµ Background music enabled:', backgroundMusicEnabled);
debug('üéµ Music playing:', musicPlaying);

if (!backgroundMusic) {
    debug('üéµ Creating background music...');
    createBackgroundMusic();
}
startBackgroundMusic();

// Fallback: try again after a short delay if music didn't start
setTimeout(() => {
    if (!musicPlaying && backgroundMusicEnabled && audioInitialized) {
        debug('üéµ Fallback: Retrying music start...');
        if (!backgroundMusic) {
            createBackgroundMusic();
        }
        startBackgroundMusic();
    }
}, 1000);

        }
        
        function restartGame() {
            // Clear obstacles, coins and streams
            obstacles.forEach(obstacle => scene.remove(obstacle));
            obstacles = [];
            
            coins.forEach(coin => scene.remove(coin));
            coins = [];

            rareCoins.forEach(rareCoin => scene.remove(rareCoin));
            rareCoins = [];

            powerUps.forEach(powerUp => scene.remove(powerUp));
powerUps = [];

// Reset power-up states completely
shieldActive = false;
coinMultiplierActive = false;
magnetActive = false;
powerUpTimers = {};

// Remove shield effect if active
if (player && player.userData && player.userData.shieldEffect) {
    player.remove(player.userData.shieldEffect);
    player.userData.shieldEffect = null;
}

// Force log to confirm reset
debug('Power-ups reset - Shield:', shieldActive, 'Multiplier:', coinMultiplierActive, 'Magnet:', magnetActive);
            
            waterStreams.forEach(stream => scene.remove(stream));
            waterStreams = [];
            
            // Clear scenery objects
            sceneryObjects.forEach(object => scene.remove(object));
            sceneryObjects = [];

            // Clear meteors
            meteors.forEach(meteor => scene.remove(meteor));
            meteors = [];
            meteorSpawnCounter = 0;
            
            // Clear explosion particles
            explosionParticles.forEach(particle => scene.remove(particle));
            explosionParticles = [];
            
            // Clear sparkle particles
            sparkleParticles.forEach(particle => scene.remove(particle));
            sparkleParticles = [];
            
            // Reset player position and make visible again
player.position.x = 0;
player.position.y = playerY;
player.rotation.x = 0; // Reset rotation
player.visible = true;
currentLane = 1;
jumping = false;
jumpRotation = 0;
streamSpawnCounter = 0;
streamCreated = false;

// Reset dragon fire particles if dragon character
if (currentCharacter === 'dragon' && player.userData && player.userData.fireParticles) {
    player.userData.fireParticles.forEach(particle => {
        particle.visible = false;
        particle.position.set(
            (Math.random() - 0.5) * 0.3,
            0.1 + Math.random() * 0.2,
            1.0
        );
        particle.material.opacity = particle.userData.originalOpacity;
        particle.scale.setScalar(1.0);
    });
}
dragonFireActive = false;
dragonFireCooldown = 0;
            
            // Reset game state
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('pauseScreen').style.display = 'none';
            document.getElementById('settingsScreen').style.display = 'none';
            document.getElementById('modalOverlay').style.display = 'none';
            document.getElementById('pauseBtn').style.display = 'block';
            document.getElementById('speedIndicator').style.display = 'block';
            document.getElementById('newHighScoreMessage').style.display = 'none';
            if (isMobile) {
                document.getElementById('swipeInstructions').style.display = 'block';
            }
            gameOver = false;
            gamePaused = false;
            gameState = "playing";
            score = 0;
            distanceTraveled = 0;
            
            // Reset dynamic difficulty
            resetDynamicDifficulty();
            
            updateScore();

// Restart background music
            if (musicPlaying) {
                stopBackgroundMusic();
            }
            if (!backgroundMusic) {
                createBackgroundMusic();
            }
            startBackgroundMusic();
        }
        
        function updateScore() {
            document.getElementById('score').textContent = `Score: ${score}`;
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ==================== DESKTOP CONTROLS ====================
// Keyboard input, key handling, and desktop controls
// Dependencies: Game Loop, Player Controls  
// Functions: onKeyDown(), onKeyUp(), handleKeyboard(), etc.
        
        function onKeyDown(event) {
            if (gameOver) return;
            
            if (event.key === 'p' || event.key === 'P') {
                togglePause();
                return;
            }
            
            if (event.key === 's' || event.key === 'S') {
                toggleSettingsScreen();
                return;
            }

            // Add this to your keyboard controls
            if (event.key === 'd' || event.key === 'D') {
                DEBUG_MODE = !DEBUG_MODE;
                console.log('Debug mode:', DEBUG_MODE ? 'ON' : 'OFF');
            }
            
            if (!gameStarted || gamePaused) return;
        

            switch (event.key) {
                case 'ArrowLeft':
                    moveLeft();
                    break;
                case 'ArrowRight':
                    moveRight();
                    break;
                case 'ArrowUp':
                case ' ': // Space bar
                    jump();
                    break;
                case 'ArrowDown':
                    quickDrop();
                    break;
            }
        }
        
function togglePause() {
    // Don't do anything if not in playing or paused state
    if (!gameStarted || gameOver || (gameState !== "playing" && gameState !== "paused")) return;
    
    // Toggle pause state
    gamePaused = !gamePaused;
    
    if (gamePaused) {
        // Pause the game
        gameState = "paused";
        document.getElementById('pauseScreen').style.display = 'flex';
        document.getElementById('swipeInstructions').style.display = 'none';
        
        // INSTANT audio cutoff - no hanging sound!
        if (musicPlaying) {
            try {
                // Stop all music layers instantly
                musicLayers.forEach(layer => {
                    if (layer.pattern) {
                        layer.pattern.stop(0); // Stop immediately
                    }
                    if (layer.synth) {
                        layer.synth.volume.rampTo(-60, 0.01); // Instant volume cut
                    }
                });
                
                // Stop transport and cancel scheduled events
                Tone.Transport.stop();
                Tone.Transport.cancel();
                
                musicPlaying = false;
            } catch (error) {
                debug('Audio pause error (non-critical):', error);
            }
        }
        
        // Also stop any preview music
        if (window.previewMusic && window.previewMusic.playing) {
            try {
                stopPreview();
            } catch (error) {
                debug('Preview stop error (non-critical):', error);
            }
        }
        
    } else {
        // Resume the game
        gameState = "playing";
        document.getElementById('pauseScreen').style.display = 'none';
        if (isMobile) {
            document.getElementById('swipeInstructions').style.display = 'block';
        }
        
        // Restart music cleanly if enabled
        if (backgroundMusicEnabled) {
            try {
                // Recreate music layers for clean restart
                createBackgroundMusic();
                startBackgroundMusic();
            } catch (error) {
                debug('Audio resume error (non-critical):', error);
            }
        }
    }
}

        // Show character select screen from game over menu
function showCharacterSelectScreen() {
    // Hide game over screen
    document.getElementById('gameOver').style.display = 'none';
    
    // Show character select screen
    document.getElementById('characterSelectScreen').style.display = 'flex';
    
    // Reset game state
    gameState = "characterSelect";
    
    // Reset the selected character index to current character
    selectedCharacterIndex = characterNames.indexOf(currentCharacter);
    if (selectedCharacterIndex === -1) selectedCharacterIndex = 0;
    
    // Reinitialize character select screen completely
    initCharacterSelectScreen();
}

// Show world select screen from character select (NEW FUNCTION)
function showWorldSelectFromCharacter() {
    // Hide character select screen
    document.getElementById('characterSelectScreen').style.display = 'none';
    
    // Show world select screen
    document.getElementById('worldSelectScreen').style.display = 'flex';
    
    // Reset game state
    gameState = "worldSelect";
    
    // Reset the selected world index to current world
    selectedWorldIndex = availableWorlds.findIndex(w => w.id === currentWorld);
    if (selectedWorldIndex === -1) selectedWorldIndex = 0;
    
    // Initialize world select screen
    initWorldSelectScreen();
}

// Show character select screen from pause menu
function showCharacterSelectScreenFromPause() {
    // Hide pause screen
    document.getElementById('pauseScreen').style.display = 'none';
    
    // Show character select screen
    document.getElementById('characterSelectScreen').style.display = 'flex';
    
    // Reset game state
    gameState = "characterSelect";
    
    // Reset the selected character index to current character
    selectedCharacterIndex = characterNames.indexOf(currentCharacter);
    if (selectedCharacterIndex === -1) selectedCharacterIndex = 0;
    
    // Reinitialize character select screen completely
    initCharacterSelectScreen();
}

        // Restart from pause menu
        function restartFromPause() {
            // First close the pause menu
            document.getElementById('pauseScreen').style.display = 'none';
            
            // Then restart the game
            restartGame();
        }

        // Show settings screen from pause menu
        function toggleSettingsFromPause() {
            // Hide pause screen
            document.getElementById('pauseScreen').style.display = 'none';
            
            // Show settings screen and overlay
            document.getElementById('settingsScreen').style.display = 'flex';
            document.getElementById('modalOverlay').style.display = 'block';
            
            // Game is already paused from pause menu, so we don't need to change gamePaused
            // But we should update the game state
            gameState = "paused"; // Keep it in paused state while in settings
        }

        // Show settings screen from game over menu
        function toggleSettingsFromGameOver() {
            // Hide game over screen
            document.getElementById('gameOver').style.display = 'none';
            
            // Show settings screen and overlay
            document.getElementById('settingsScreen').style.display = 'flex';
            document.getElementById('modalOverlay').style.display = 'block';
            
            // Keep game state as "gameOver" so we know where to return
            gameState = "gameOver";
        }

        // Show settings screen during gameplay
        function toggleSettingsFromGame() {
            // Pause the game
            gamePaused = true;
            
            // Show settings screen and overlay
            document.getElementById('settingsScreen').style.display = 'flex';
            document.getElementById('modalOverlay').style.display = 'block';
            
            // Set game state
            gameState = "playing"; // Remember we're coming from playing state
        }
        
        function moveLeft() {
            if (currentLane > 0) {
                currentLane--;
            }
        }
        
        function moveRight() {
            if (currentLane < 2) {
                currentLane++;
            }
        }
        
        function jump() {
    if (!jumping) {
        playJumpSound(); // Add this line
        jumping = true;
        jumpDirection = 1;
        jumpRotation = 0; // Reset flip rotation
        
        // Adjust jump height for pumpkin character (higher jumps)
        if (currentCharacter === 'pumpkin') {
            jumpHeight = 2.0;    // Reduced height but still higher than others
            jumpSpeed = 0.08;    // Reduced speed to maintain same duration
        } else {
            jumpHeight = 1.6;    // Reduced height for all other characters
            jumpSpeed = 0.065;   // Reduced speed to maintain same duration
        }
                
                
            }
        }
        
        function quickDrop() {
            // Only work if the character is currently jumping and moving upward
            if (jumping) {
                // If going up, immediately reverse direction
                if (jumpDirection === 1) {
                    jumpDirection = -1;
                    // Increase fall speed for a quicker drop
                    jumpSpeed *= 1.5;
                }
                // If already falling, increase fall speed
                else if (jumpDirection === -1) {
                    // Increase fall speed for a quicker drop
                    jumpSpeed *= 1.2;
                }
            }
        }

      
        
// ==================== SCENERY SYSTEM ====================
// Background scenery, environmental decorations, and world atmosphere
// Dependencies: World System, forest.js, desert.js
// Functions: spawnScenery(), createTallPine(), createMushroomPatch(), etc.

        // Create roadside scenery objects
        function spawnScenery() {
            // Spawn scenery to the sides of the lanes
const side = Math.random() > 0.5 ? 1 : -1; // Left or right side
const distance = Math.random() * 3 + 5; // Distance from center

let sceneryObject;

if (currentWorld === 'forest') {
    // Forest-specific scenery
    const forestScenery = Math.floor(Math.random() * 5);
    switch (forestScenery) {
        case 0: // Tall pine trees
            sceneryObject = createTallPine();
            break;
        case 1: // Mushroom patches
            sceneryObject = createMushroomPatch();
            break;
        case 2: // Fern clusters
            sceneryObject = createFernCluster();
            break;
        case 3: // Firefly swarms
            sceneryObject = createFireflySwarm();
            break;
        case 4: // Ancient oak
            sceneryObject = createAncientOak();
            break;
    }
} else if (currentWorld === 'desert') {
    // Desert-specific scenery
    const desertScenery = Math.floor(Math.random() * 4);
    switch (desertScenery) {
        case 0: // Palm oasis
            sceneryObject = createPalmOasis();
            break;
        case 1: // Shimmering mirage
            sceneryObject = createMirage();
            break;
        case 2: // Rolling tumbleweed
            sceneryObject = createTumbleweed();
            break;
        case 3: // Distant pyramid
            sceneryObject = createPyramidDistance();
            break;
    }
} else {
    // Classic world scenery
    const sceneryType = Math.floor(Math.random() * 4);
    switch (sceneryType) {
        case 0: // Tree
            sceneryObject = createTree();
            break;
        case 1: // Rock formation
            sceneryObject = createRockFormation();
            break;
        case 2: // Flowers
            sceneryObject = createFlowers();
            break;
        case 3: // Bush cluster
            sceneryObject = createBushCluster();
            break;
    }
}
            
            sceneryObject.position.x = side * distance;
            sceneryObject.position.z = -50; // Spawn far away
            scene.add(sceneryObject);
            sceneryObjects.push(sceneryObject);
        }
        
        function createTree() {
            const treeGroup = new THREE.Group();
            
            // Tree trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.7
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 1;
            treeGroup.add(trunk);
            
            // Add bark texture
            const barkGeometry = new THREE.CylinderGeometry(0.31, 0.41, 2.01, 8, 4, true);
            const barkMaterial = new THREE.MeshStandardMaterial({
                color: 0x6B4513,
                roughness: 0.9,
                wireframe: true,
                transparent: true,
                opacity: 0.4
            });
            const bark = new THREE.Mesh(barkGeometry, barkMaterial);
            bark.position.y = 1;
            treeGroup.add(bark);
            
            // Tree leaves - layered cones for more natural look
            const leavesGeometries = [
                new THREE.ConeGeometry(1.5, 2, 8),
                new THREE.ConeGeometry(1.2, 1.8, 8),
                new THREE.ConeGeometry(0.9, 1.6, 8)
            ];
            
            const leavesMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x228B22,
                roughness: 0.6
            });
            
            const leaves1 = new THREE.Mesh(leavesGeometries[0], leavesMaterial);
            leaves1.position.y = 2.5;
            treeGroup.add(leaves1);
            
            const leaves2 = new THREE.Mesh(leavesGeometries[1], leavesMaterial);
            leaves2.position.y = 3.2;
            treeGroup.add(leaves2);
            
            const leaves3 = new THREE.Mesh(leavesGeometries[2], leavesMaterial);
            leaves3.position.y = 3.8;
            treeGroup.add(leaves3);
            
            return treeGroup;
        }
        
        function createRockFormation() {
            const rockFormationGroup = new THREE.Group();
            
            // Create several rocks of different sizes and shapes
            for (let i = 0; i < 7; i++) {
                const size = Math.random() * 0.8 + 0.4;
                // Mix different geometries for more natural look
                let rockGeometry;
                const geoType = Math.floor(Math.random() * 3);
                switch (geoType) {
                    case 0:
                        rockGeometry = new THREE.DodecahedronGeometry(size, 1);
                        break;
                    case 1:
                        rockGeometry = new THREE.IcosahedronGeometry(size, 0);
                        break;
                    case 2:
                        rockGeometry = new THREE.OctahedronGeometry(size, 1);
                        break;
                }
                
                // Mix different shades of gray
                const shade = Math.random() * 40 + 90; // 90-130 range for gray
                const rockMaterial = new THREE.MeshStandardMaterial({ 
                    color: new THREE.Color().setRGB(shade/255, shade/255, shade/255),
                    roughness: 0.8,
                    flatShading: true
                });
                
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.set(
                    Math.random() * 2 - 1,
                    size / 2,
                    Math.random() * 2 - 1
                );
                rock.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                rock.scale.set(
                    1 + Math.random() * 0.4 - 0.2,
                    1 + Math.random() * 0.4 - 0.2,
                    1 + Math.random() * 0.4 - 0.2
                );
                rockFormationGroup.add(rock);
            }
            
            // Add some moss on top of some rocks
            const mossGeometry = new THREE.SphereGeometry(0.2, 8, 4);
            const mossMaterial = new THREE.MeshStandardMaterial({
                color: 0x3A5F0B,
                roughness: 1
            });
            
            for (let i = 0; i < 4; i++) {
                const moss = new THREE.Mesh(mossGeometry, mossMaterial);
                moss.position.set(
                    Math.random() * 1.5 - 0.75,
                    Math.random() * 0.5 + 0.8,
                    Math.random() * 1.5 - 0.75
                );
                moss.scale.set(0.6, 0.3, 0.6);
                rockFormationGroup.add(moss);
            }
            
            return rockFormationGroup;
        }
        
        function createFlowers() {
    const flowerGroup = new THREE.Group();
    
    // Skip grass base - flowers will sit directly on the dark side terrain
            
            // Add flowers of different colors
            const flowerColors = [
                0xFF0000, // Red
                0xFFFF00, // Yellow
                0xFF00FF, // Pink
                0xFFFFFF, // White
                0x0000FF, // Blue
                0xFF9900  // Orange
            ];
            
            for (let i = 0; i < 15; i++) {
                // Stem
                const stemGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.5, 8);
                const stemMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
                const stem = new THREE.Mesh(stemGeometry, stemMaterial);
                
                // Position within flower patch area
const angle = Math.random() * Math.PI * 2;
const radius = Math.random() * 1.2; // Slightly larger spread since no grass circle
stem.position.set(
    Math.cos(angle) * radius,
    0.25,
    Math.sin(angle) * radius
);
                
                // Slight random tilt to stems
                stem.rotation.set(
                    Math.random() * 0.3 - 0.15,
                    0,
                    Math.random() * 0.3 - 0.15
                );
                
                // Flower head - choose different shapes for variety
                const flowerType = Math.floor(Math.random() * 3);
                let flower;
                
                if (flowerType === 0) {
                    // Simple sphere flower
                    const flowerGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                    const flowerMaterial = new THREE.MeshStandardMaterial({ 
                        color: flowerColors[Math.floor(Math.random() * flowerColors.length)],
                        emissive: 0x333333,
                        emissiveIntensity: 0.2
                    });
                    flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
                    flower.position.y = 0.5;
                } 
                else if (flowerType === 1) {
                    // Daisy-like flower with petals
                    flower = new THREE.Group();
                    
                    // Center of flower
                    const centerGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                    const centerMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFF00 });
                    const center = new THREE.Mesh(centerGeometry, centerMaterial);
                    flower.add(center);
                    
                    // Add petals
                    const petalColor = flowerColors[Math.floor(Math.random() * flowerColors.length)];
                    const petalMaterial = new THREE.MeshStandardMaterial({ 
                        color: petalColor,
                        emissive: petalColor,
                        emissiveIntensity: 0.1
                    });
                    
                    for (let j = 0; j < 8; j++) {
                        const petalGeometry = new THREE.SphereGeometry(0.04, 8, 8);
                        const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                        const petalAngle = (j / 8) * Math.PI * 2;
                        petal.position.set(
                            Math.cos(petalAngle) * 0.08,
                            0,
                            Math.sin(petalAngle) * 0.08
                        );
                        petal.scale.set(1.5, 0.5, 1.5);
                        flower.add(petal);
                    }
                    
                    flower.position.y = 0.5;
                }
                else {
                    // Tulip-like flower
                    const flowerGeometry = new THREE.ConeGeometry(0.08, 0.15, 8);
                    const flowerMaterial = new THREE.MeshStandardMaterial({ 
                        color: flowerColors[Math.floor(Math.random() * flowerColors.length)],
                        emissive: 0x333333,
                        emissiveIntensity: 0.2
                    });
                    flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
                    flower.position.y = 0.5;
                    flower.rotation.x = Math.PI; // Invert cone to look like a tulip
                }
                
                stem.add(flower);
                flowerGroup.add(stem);
            }
            
            return flowerGroup;
        }
        
        function createBushCluster() {
            const bushClusterGroup = new THREE.Group();
            
            // Create several bushes of different sizes
            for (let i = 0; i < 5; i++) {
                const bushSize = Math.random() * 0.6 + 0.6;
                
                // Base bush
                const bushGeometry = new THREE.SphereGeometry(bushSize, 8, 8);
                const bushMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x228B22, 
                    roughness: 0.7
                });
                const bush = new THREE.Mesh(bushGeometry, bushMaterial);
                
                // Position bushes in a small cluster
                const angle = Math.random() * Math.PI * 2;
                const clusterRadius = Math.random() * 1.2;
                bush.position.set(
                    Math.cos(angle) * clusterRadius,
                    bushSize / 2,
                    Math.sin(angle) * clusterRadius
                );
                
                // Add some variation to the bush color
                const colorVariation = Math.random() * 0.2 - 0.1; // -0.1 to 0.1
                bushMaterial.color.g += colorVariation;
                
                bushClusterGroup.add(bush);
                
                // Add details to each bush
                const detailGeometry = new THREE.SphereGeometry(bushSize * 1.05, 8, 8);
                const detailMaterial = new THREE.MeshStandardMaterial({
                    color: 0x196F3D,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.3
                });
                const detail = new THREE.Mesh(detailGeometry, detailMaterial);
                detail.position.copy(bush.position);
                bushClusterGroup.add(detail);
            }
            
            return bushClusterGroup;
        }
        
        // Create a coin with improved shiny gold appearance
        function spawnCoin() {
            const laneIndex = Math.floor(Math.random() * 3); // Random lane
            const coinGroup = new THREE.Group();
            
            // Create coin with brilliant shiny gold material
// Reuse shared geometry for all coins
if (!window.sharedCoinGeometry) {
    window.sharedCoinGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.05, 16); // Reduced segments
}
const coinGeometry = window.sharedCoinGeometry;
const coinMaterial = new THREE.MeshStandardMaterial({ 
    color: 0xFFD700, // Bright gold
    metalness: 1.0,  // Fully metallic
    roughness: 0.05, // Very shiny
    emissive: 0xFFD700, // Golden glow
    emissiveIntensity: 0.4
});
const coin = new THREE.Mesh(coinGeometry, coinMaterial);
coin.rotation.x = Math.PI / 2;
coinGroup.add(coin);

// Add edge detail to coin with enhanced shine (properly aligned)
const edgeGeometry = new THREE.TorusGeometry(0.3, 0.03, 8, 32);
const edgeMaterial = new THREE.MeshStandardMaterial({ 
    color: 0xFFD700, // Same bright gold
    metalness: 1.0, 
    roughness: 0.03, // Extra shiny
    emissive: 0xFFD700,
    emissiveIntensity: 0.3
});
const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
// No rotation needed - both coin and edge are now in the same orientation
coinGroup.add(edge);

// Add sparkle particles around the coin
for (let i = 0; i < 8; i++) {
    const sparkleGeometry = new THREE.SphereGeometry(0.02, 8, 8);
    const sparkleMaterial = new THREE.MeshBasicMaterial({
        color: 0xFFFFFF,
        transparent: true,
        opacity: 0.8
    });
    
    const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
    
    // Position sparkles around the coin
    const angle = (i / 8) * Math.PI * 2;
    const radius = 0.4 + Math.random() * 0.1;
    sparkle.position.set(
        Math.cos(angle) * radius,
        0,
        Math.sin(angle) * radius
    );
    
    // Animation properties for sparkles
    sparkle.userData = {
        orbitSpeed: 0.02 + Math.random() * 0.02,
        orbitRadius: radius,
        orbitAngle: angle,
        pulseSpeed: 0.05 + Math.random() * 0.05,
        pulsePhase: Math.random() * Math.PI * 2
    };
    
    coinGroup.add(sparkle);
}

// Store sparkles for animation
coinGroup.userData.sparkles = coinGroup.children.filter(child => 
    child.userData && child.userData.orbitSpeed !== undefined
);
            
            // Add dollar sign to the coin (simple geometry representation)
            const dollarSignGroup = new THREE.Group();
            
            // Vertical bar
            const barGeometry = new THREE.BoxGeometry(0.05, 0.3, 0.02);
            const dollarMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFCC00,
                metalness: 1.0, 
                roughness: 0.2,
                emissive: 0xFFAA00,
                emissiveIntensity: 0.3
            });
            const bar = new THREE.Mesh(barGeometry, dollarMaterial);
            dollarSignGroup.add(bar);
            
            // Top and bottom curves
            const topCurveGeometry = new THREE.TorusGeometry(0.08, 0.02, 8, 8, Math.PI);
            const topCurve = new THREE.Mesh(topCurveGeometry, dollarMaterial);
            topCurve.position.set(0.04, 0.08, 0);
            topCurve.rotation.z = Math.PI / 2;
            dollarSignGroup.add(topCurve);
            
            const bottomCurveGeometry = new THREE.TorusGeometry(0.08, 0.02, 8, 8, Math.PI);
            const bottomCurve = new THREE.Mesh(bottomCurveGeometry, dollarMaterial);
            bottomCurve.position.set(-0.04, -0.08, 0);
            bottomCurve.rotation.z = -Math.PI / 2;
            dollarSignGroup.add(bottomCurve);
            
            // Front side dollar sign
dollarSignGroup.position.set(0, 0, 0.03); // Position it just on the surface of the coin
// No rotation - keep dollar sign standing upright
coinGroup.add(dollarSignGroup);

// Back side dollar sign (duplicate)
const dollarSignGroupBack = dollarSignGroup.clone();
dollarSignGroupBack.position.set(0, 0, -0.03); // Position on the back surface
dollarSignGroupBack.rotation.y = Math.PI; // Flip it so it reads correctly from the back
coinGroup.add(dollarSignGroupBack);
            
            // Remove the highlight plane - it was causing visual issues
// Instead, the coin already has sparkle particles for visual appeal
            
            // Position coin in lane, and slightly higher than obstacles for jumping
            coinGroup.position.x = lanes[laneIndex];
            coinGroup.position.y = 1.2; // Higher than obstacles for jumping
            coinGroup.position.z = -50; // Spawn far away
            
            scene.add(coinGroup);
            coins.push(coinGroup);
        }

// Create rare gradient coin - spawns very rarely, worth 100 coins
function spawnRareCoin() {
    const laneIndex = Math.floor(Math.random() * 3); // Random lane
    const rareCoinGroup = new THREE.Group();
    
    // Create coin with brilliant gradient material
    const coinGeometry = new THREE.CylinderGeometry(0.35, 0.35, 0.06, 32); // Slightly bigger
    
    // Create gradient canvas texture
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    const context = canvas.getContext('2d');
    
    // Create radial gradient (purple to blue to teal to green)
    const gradient = context.createRadialGradient(128, 128, 0, 128, 128, 128);
    gradient.addColorStop(0, '#8A2BE2');    // Purple center
    gradient.addColorStop(0.3, '#4169E1');  // Blue
    gradient.addColorStop(0.6, '#20B2AA');  // Teal
    gradient.addColorStop(1, '#32CD32');     // Green edge
    
    context.fillStyle = gradient;
    context.fillRect(0, 0, 256, 256);
    
    const gradientTexture = new THREE.CanvasTexture(canvas);
    
    const rareCoinMaterial = new THREE.MeshStandardMaterial({ 
        map: gradientTexture,
        color: 0xFFFFFF, // White to not affect texture
        metalness: 1.0,  // Fully metallic
        roughness: 0.05, // Very shiny
        emissive: 0x4169E1, // Blue glow
        emissiveIntensity: 0.3
    });
    const rareCoin = new THREE.Mesh(coinGeometry, rareCoinMaterial);
    rareCoin.rotation.x = Math.PI / 2;
    rareCoinGroup.add(rareCoin);
    
    // Add edge detail with vibrant blue-green gradient
const edgeGeometry = new THREE.TorusGeometry(0.35, 0.04, 8, 32);
const edgeMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x00CCFF, // Bright cyan edge
    metalness: 1.0, 
    roughness: 0.01, // Super shiny
    emissive: 0x0088FF,
    emissiveIntensity: 0.7 // Bright glow
});
    const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
    rareCoinGroup.add(edge);
    
    // Create the Solana-style logo using simple geometry
const chevronGroup = new THREE.Group();

// Brighter, more vibrant Solana colors
const solanaColors = [0xBB66FF, 0x00FF88, 0x00FFDD]; // Brighter Purple, Bright Green, Bright Cyan

// Create three Solana-style parallelograms using BoxGeometry (reliable)
for (let i = 0; i < 3; i++) {
    // Create parallelogram using skewed boxes
    const parallelogramGroup = new THREE.Group();
    
    // Main parallelogram body
    const mainGeometry = new THREE.BoxGeometry(0.3, 0.08, 0.02);
    const chevronMaterial = new THREE.MeshStandardMaterial({ 
        color: solanaColors[i],
        metalness: 1.0, 
        roughness: 0.02, // Extra shiny
        emissive: solanaColors[i],
        emissiveIntensity: 0.6 // Much brighter glow
    });
    
    const mainBody = new THREE.Mesh(mainGeometry, chevronMaterial);
    mainBody.rotation.z = 0.3; // Skew angle for Solana look
    parallelogramGroup.add(mainBody);
    
    // Add angled ends to create parallelogram shape
    const endGeometry = new THREE.BoxGeometry(0.06, 0.06, 0.02);
    
    const leftEnd = new THREE.Mesh(endGeometry, chevronMaterial);
    leftEnd.position.set(-0.12, -0.05, 0);
    leftEnd.rotation.z = 0.8;
    parallelogramGroup.add(leftEnd);
    
    const rightEnd = new THREE.Mesh(endGeometry, chevronMaterial);
    rightEnd.position.set(0.12, 0.05, 0);
    rightEnd.rotation.z = 0.8;
    parallelogramGroup.add(rightEnd);
    
    // Position the three parallelograms
    if (i === 0) {
        parallelogramGroup.position.set(0, 0.1, 0);
    } else if (i === 1) {
        parallelogramGroup.position.set(0, 0, 0);
    } else {
        parallelogramGroup.position.set(0, -0.1, 0);
    }
    
    chevronGroup.add(parallelogramGroup);
}
    
    // Front side chevron
    chevronGroup.position.set(0, 0, 0.035);
    rareCoinGroup.add(chevronGroup);
    
    // Back side chevron (duplicate)
    const chevronGroupBack = chevronGroup.clone();
    chevronGroupBack.position.set(0, 0, -0.035);
    chevronGroupBack.rotation.y = Math.PI;
    rareCoinGroup.add(chevronGroupBack);
    
    // Add enhanced sparkle particles with gradient colors
    for (let i = 0; i < 12; i++) {
        const sparkleGeometry = new THREE.SphereGeometry(0.03, 8, 8);
        const sparkleColors = [0x8A2BE2, 0x4169E1, 0x20B2AA, 0x32CD32]; // Gradient colors
        const sparkleColor = sparkleColors[i % sparkleColors.length];
        
        const sparkleMaterial = new THREE.MeshBasicMaterial({
            color: sparkleColor,
            transparent: true,
            opacity: 0.8
        });
        
        const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
        
        const angle = (i / 12) * Math.PI * 2;
        const radius = 0.5 + Math.random() * 0.1;
        sparkle.position.set(
            Math.cos(angle) * radius,
            0,
            Math.sin(angle) * radius
        );
        
        sparkle.userData = {
            orbitSpeed: 0.03 + Math.random() * 0.02,
            orbitRadius: radius,
            orbitAngle: angle,
            pulseSpeed: 0.08 + Math.random() * 0.05,
            pulsePhase: Math.random() * Math.PI * 2
        };
        
        rareCoinGroup.add(sparkle);
    }
    
    // Store sparkles for animation
    rareCoinGroup.userData.sparkles = rareCoinGroup.children.filter(child => 
        child.userData && child.userData.orbitSpeed !== undefined
    );
    rareCoinGroup.userData.rotationSpeed = Math.random() * 0.02 + 0.02; // Faster rotation
    
    // Position coin in lane, higher than regular coins
    rareCoinGroup.position.x = lanes[laneIndex];
    rareCoinGroup.position.y = 1.4; // Slightly higher than regular coins
    rareCoinGroup.position.z = -50; // Spawn far away
    
    scene.add(rareCoinGroup);
    rareCoins.push(rareCoinGroup);
}

        
// ==================== COLLISION SYSTEM ====================
// Collision detection, hit testing, and collision response
// Dependencies: Player Controls, Obstacle System, Power-up System
// Functions: checkCollision(), checkSimpleCollision(), collision handling logic

        // Smart collision - early exit for distant objects
function fastCollisionCheck(object1, object2, threshold = 3.0) {
    const dx = object1.position.x - object2.position.x;
    const dy = object1.position.y - object2.position.y;
    const dz = object1.position.z - object2.position.z;
    const distanceSquared = dx * dx + dy * dy + dz * dz;
    
    // Early exit if objects are too far apart
    if (distanceSquared > threshold * threshold) {
        return false;
    }
    
    // Only do expensive collision check if objects are close
    return checkCollision(object2);
}

        // Optimized collision detection with caching
function checkCollision(object) {
    // For coins and power-ups, use simple distance-based collision (faster)
    const isCoin = coins.includes(object) || rareCoins.includes(object);
    const isPowerUp = powerUps.includes(object);
    
    if (isCoin || isPowerUp) {
        return checkSimpleCollision(object, player, 1.5);
    }

    // For ancient ruins (desert pillars), only check collision with the main pillar - HANDLE FIRST
const isAncientRuin = obstacles.includes(object) && object.children.some(child => child.userData && child.userData.isMainPillar);

if (isAncientRuin) {
    // Find the main pillar specifically
    const mainPillar = object.children.find(child => child.userData && child.userData.isMainPillar);
    if (mainPillar) {
        // Get world positions to check distance first
        const playerPos = new THREE.Vector3();
        const pillarPos = new THREE.Vector3();
        player.getWorldPosition(playerPos);
        mainPillar.getWorldPosition(pillarPos);
        
        const distance = playerPos.distanceTo(pillarPos);
debug('üèõÔ∏è Ancient pillar distance check:', distance, 'Player at:', playerPos.x, 'Pillar at:', pillarPos.x);
        
        // Only check collision if player is very close to the pillar
        if (distance < 2.0) {
            // Create a smaller collision box for just the pillar core
            const pillarBox = new THREE.Box3().setFromObject(mainPillar);
            
            // Shrink the collision box to make it more forgiving
            const shrinkAmount = 0.3; // Make collision 30% smaller
            pillarBox.min.x += shrinkAmount;
            pillarBox.max.x -= shrinkAmount;
            pillarBox.min.z += shrinkAmount;
            pillarBox.max.z -= shrinkAmount;
            
            const playerBox = new THREE.Box3().setFromObject(player);
            
            // Can jump over pillars if high enough
            if (jumping && player.position.y > 1.2) {
                debug('ü¶ò Jumped over ancient pillar!');
                return false;
            }
            
            const collision = playerBox.intersectsBox(pillarBox);
            if (collision) {
                debug('üèõÔ∏è Hit ancient pillar!');
            }
            return collision;
        }
        return false; // No collision if too far from pillar
    }
}

// For quicksand, only check collision with the main pit area
const isQuicksand = obstacles.includes(object) && object.children.some(child => 
    child.geometry && child.geometry.type === 'CircleGeometry' && child.position.y < 0
);

if (isQuicksand) {
    // Find the main quicksand pit (the CircleGeometry at y = -0.1)
    const mainPit = object.children.find(child => 
        child.geometry && child.geometry.type === 'CircleGeometry' && child.position.y < 0
    );
    
    if (mainPit) {
        // Get world positions to check distance first
        const playerPos = new THREE.Vector3();
        const pitPos = new THREE.Vector3();
        player.getWorldPosition(playerPos);
        mainPit.getWorldPosition(pitPos);
        
        const distance = playerPos.distanceTo(pitPos);
        debug('üèúÔ∏è Quicksand distance check:', distance, 'Player at:', playerPos.x, 'Pit at:', pitPos.x);
        
        // Only check collision if player is close to the pit center
        if (distance < 1.0) {
            // Can jump over quicksand if high enough
            if (jumping && player.position.y > 0.8) {
                debug('ü¶ò Jumped over quicksand!');
                return false;
            }
            debug('üí• Hit quicksand pit!');
            return true;
        }
        return false; // No collision if too far from pit center
    }
}
    
    // For Monster character, use precise collision with main body only
if (currentCharacter === 'monster') {
    // Find the main body (central sphere) of the Monster
    let monsterBody = null;
    for (let i = 0; i < player.children.length; i++) {
        const child = player.children[i];
        if (child.userData && child.userData.isMainBody) {
            monsterBody = child;
            break;
        }
    }
    
    if (monsterBody) {
        // Use cached collision boundaries
        const bodyBox = getCachedCollisionBox(monsterBody);
        const objectBox = getCachedCollisionBox(object);
        
        // Check intersection between cached boxes
        return bodyBox.intersectsBox(objectBox);
    }
}

// For Dragon character, use cached collision with body only (ignore wings)
if (currentCharacter === 'dragon') {
    // Use simple distance check for performance, but verify with wings
    if (checkSimpleCollision(object, player, 2.0)) {
        // Double-check with cached bounding box if close
        const objectBox = getCachedCollisionBox(object);
        const playerBox = getCachedCollisionBox(player);
        return playerBox.intersectsBox(objectBox);
    }
    return false;
}
    
    // For UFO character, handle collision differently for coins vs obstacles
if (currentCharacter === 'ufo') {
    // Check if this is a coin (coins are in the coins array)
    const isCoin = coins.includes(object);
    
    if (isCoin) {
        // For coins, use expanded collision area
        const playerBox = new THREE.Box3().setFromObject(player);
        const objectBox = new THREE.Box3().setFromObject(object);
        
        // Expand the UFO's collision box vertically to catch coins above and below
        playerBox.min.y -= 0.3; // Extend downward
        playerBox.max.y += 0.5; // Extend upward more to catch coins
        
        return playerBox.intersectsBox(objectBox);
    } else {
        // For obstacles, create a custom bounding box excluding the tractor beam
        const customBox = new THREE.Box3();
        
        // Only include specific UFO parts (exclude the beam which is usually the last child)
        for (let i = 0; i < player.children.length; i++) {
            const child = player.children[i];
            // Skip the tractor beam (it's positioned at y = -0.6)
            if (child.position.y > -0.4) {
                const childBox = new THREE.Box3().setFromObject(child);
                if (customBox.isEmpty()) {
                    customBox.copy(childBox);
                } else {
                    customBox.union(childBox);
                }
            }
        }
        
        const objectBox = new THREE.Box3().setFromObject(object);
        return customBox.intersectsBox(objectBox);
    }
}

// For meteors, use precise lane-based collision detection
if (meteors.includes(object)) {
    // Check if meteor and player are in the same lane
    const meteorLane = object.userData ? object.userData.targetLane : -1;
    const playerLane = currentLane;
    
    // Only collide if they're in the same lane AND close enough vertically
    if (meteorLane === playerLane) {
        const playerBox = new THREE.Box3().setFromObject(player);
        const meteorBox = new THREE.Box3().setFromObject(object);
        
        // Make collision more precise - only check if meteor is at ground level
        if (object.position.y <= 1.0) { // Meteor is close to ground
            return playerBox.intersectsBox(meteorBox);
        }
    }
    
    return false; // No collision if not in same lane or meteor is too high
}

// Check if this is a fallen tree - only collide with the trunk
const isFallenTree = obstacles.includes(object) && object.children.some(child => child.userData && child.userData.isMainTrunk);

if (isFallenTree) {
    // Find the trunk specifically
    const trunk = object.children.find(child => child.userData && child.userData.isMainTrunk);
    if (trunk) {
        // Get world positions
        const playerPos = new THREE.Vector3();
        const trunkPos = new THREE.Vector3();
        player.getWorldPosition(playerPos);
        trunk.getWorldPosition(trunkPos);
        
        // Only check collision if player is close to the trunk's actual position
        const distance = playerPos.distanceTo(trunkPos);
        debug('üå≥ Fallen tree distance check:', distance, 'Player at:', playerPos.x, 'Trunk at:', trunkPos.x);
        
        // Much stricter collision - only collide if very close to trunk center
        if (distance < 1.0) {
            // Can jump over fallen trees
            if (jumping && player.position.y > 1.0) {
                debug('ü¶ò Jumped over fallen tree!');
                return false;
            }
            debug('üí• Hit fallen tree trunk!');
            return true;
        }
        return false; // No collision if too far from trunk
    }
}



// For Robot character, use collision detection ONLY for main body parts (exclude particles)
if (currentCharacter === 'robot') {
    // Create collision box only from robot's main body parts (exclude electromagnetic particles)
    const robotMainBox = new THREE.Box3();
    
    // Only include the first 7 children (body, head, eyes, arms, legs, antenna)
    // Skip the electromagnetic field particles (children 8+)
    for (let i = 0; i < Math.min(7, player.children.length); i++) {
        const child = player.children[i];
        const childBox = new THREE.Box3().setFromObject(child);
        if (robotMainBox.isEmpty()) {
            robotMainBox.copy(childBox);
        } else {
            robotMainBox.union(childBox);
        }
    }
    
    const objectBox = new THREE.Box3().setFromObject(object);
    
    // Check if this is an obstacle and player is jumping
    const isObstacle = obstacles.includes(object);
    if (isObstacle && jumping && player.position.y > 1.2) {
        debug('ü¶ò Robot jumped over obstacle at height:', player.position.y);
        return false; // No collision with obstacles when jumping high enough
    }
    
    // Robot shield - blocks obstacles (but not coins/power-ups)  
    if (robotShieldActive) {
        const isObstacle = obstacles.includes(object);
        const isStream = waterStreams.includes(object);
        const isMeteor = meteors.includes(object);
        
        if (isObstacle || isStream || isMeteor) {
            // Create shield spark effect when blocking
            createShieldSparkEffect(object.position);
            debug('ü§ñ Robot shield blocked obstacle!');
            return false; // No collision when shield is active
        }
    }
    
    return robotMainBox.intersectsBox(objectBox);
}

// For Creature character, use collision detection ONLY for main body (exclude wisps and orbs)
if (currentCharacter === 'creature') {
    // Create collision box only from creature's main body parts (exclude wisps, tentacles, etc.)
    const creatureMainBox = new THREE.Box3();
    
    // Only include the first 2 children (main body and neon core)
    // Skip the eyes, tentacles, wisps, and dark aura (children 2+)
    for (let i = 0; i < Math.min(2, player.children.length); i++) {
        const child = player.children[i];
        const childBox = new THREE.Box3().setFromObject(child);
        if (creatureMainBox.isEmpty()) {
            creatureMainBox.copy(childBox);
        } else {
            creatureMainBox.union(childBox);
        }
    }
    
    const objectBox = new THREE.Box3().setFromObject(object);
    
    // Check if this is an obstacle and player is jumping
    const isObstacle = obstacles.includes(object);
    if (isObstacle && jumping && player.position.y > 1.2) {
        debug('ü¶ò Creature jumped over obstacle at height:', player.position.y);
        return false; // No collision with obstacles when jumping high enough
    }
    
    return creatureMainBox.intersectsBox(objectBox);
}

// For other characters, use cached collision boundaries
const playerBox = getCachedCollisionBox(player);
const objectBox = getCachedCollisionBox(object);

// Check if this is an obstacle (not a coin or power-up) and player is jumping
const isObstacle = obstacles.includes(object);
if (isObstacle && jumping && player.position.y > 1.2) {
    return false; // No collision with obstacles when jumping high enough
}

// Ghost phase ability - can phase through obstacles (but not coins/power-ups)
if (currentCharacter === 'ghost' && ghostPhaseActive) {
    const isObstacle = obstacles.includes(object);
    const isStream = waterStreams.includes(object);
    
    if (isObstacle || isStream) {
        return false; // No collision when phasing
    }
}

// Robot shield - blocks obstacles (but not coins/power-ups)  
if (currentCharacter === 'robot' && robotShieldActive) {
    const isObstacle = obstacles.includes(object);
    const isStream = waterStreams.includes(object);
    const isMeteor = meteors.includes(object);
    
    if (isObstacle || isStream || isMeteor) {
        // Create shield spark effect when blocking
        createShieldSparkEffect(object.position);
        return false; // No collision when shield is active
    }
}

// Use cached collision boundaries for final check
return playerBox.intersectsBox(objectBox);
}
        
        // Create explosion effect when game over
        function createExplosion() {
            // Create explosion particles at player's position
            const numParticles = mobileExplosionCount;
            
            // Explosion colors based on the current character
            let colors = [0xff0000, 0xff7700, 0xffff00]; // Default apple colors
            
            if (currentCharacter === 'carrot') {
                colors = [0xFF8C00, 0xFFA500, 0xFF4500]; // Orange shades
            } else if (currentCharacter === 'pumpkin') {
                colors = [0xFF6600, 0xFF8800, 0xDD5500]; // Pumpkin shades
            } else if (currentCharacter === 'happyface') {
                colors = [0xFFFF00, 0xFFDD00, 0xFFCC00]; // Yellow shades
            } else if (currentCharacter === 'monster') {
                colors = [0x000000, 0x330000, 0x660000]; // Dark red/black shades
            } else if (currentCharacter === 'atom') {
                colors = [0x0088FF, 0x00FFFF, 0x0044AA]; // Blue/cyan shades
            }
            
            for (let i = 0; i < numParticles; i++) {
                // Random size for each particle
                const radius = Math.random() * 0.2 + 0.05;
                const geometry = new THREE.SphereGeometry(radius, 8, 8);
                const material = new THREE.MeshStandardMaterial({ 
                    color: colors[Math.floor(Math.random() * colors.length)],
                    emissive: colors[Math.floor(Math.random() * colors.length)],
                    emissiveIntensity: 0.5
                });
                
                const particle = new THREE.Mesh(geometry, material);
                
                // Set particle at player position
                particle.position.x = player.position.x;
                particle.position.y = player.position.y;
                particle.position.z = player.position.z;
                
                // Give random velocity in all directions
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.3,
                    Math.random() * 0.2 + 0.1,
                    (Math.random() - 0.5) * 0.3
                );
                
                // Add to scene and array
                scene.add(particle);
                explosionParticles.push(particle);
            }
            
            // Hide the player
            player.visible = false;
        }
        
        // Update explosion particles
        function updateExplosion() {
            // Update explosion particles positions based on velocity
            for (let i = explosionParticles.length - 1; i >= 0; i--) {
                const particle = explosionParticles[i];
                
                // Apply gravity and update position
                particle.userData.velocity.y -= 0.01;
                particle.position.x += particle.userData.velocity.x;
                particle.position.y += particle.userData.velocity.y;
                particle.position.z += particle.userData.velocity.z;
                
                // Make particles spin for more dynamic effect
                particle.rotation.x += 0.05;
                particle.rotation.y += 0.05;
                
                // Remove particles that fall below ground
                if (particle.position.y < -1) {
                    scene.remove(particle);
                    explosionParticles.splice(i, 1);
                }
            }
        }
        
        // Game over
function endGame() {
    playCrashSound(); // Add this line at the start
    gameState = "gameOver";
    gameOver = true;
    
    // Hide UI elements
    document.getElementById('pauseBtn').style.display = 'none';
    document.getElementById('speedIndicator').style.display = 'none';
    document.getElementById('modalOverlay').style.display = 'none';
    if (isMobile) {
        document.getElementById('swipeInstructions').style.display = 'none';
    }
    
    // INSTANT audio cutoff - stop everything immediately
    try {
        if (musicPlaying) {
            // Stop all music layers instantly
            musicLayers.forEach(layer => {
                if (layer.pattern) {
                    layer.pattern.stop(0); // Stop immediately (no fade)
                }
                if (layer.synth) {
                    layer.synth.volume.rampTo(-60, 0.01); // Instant volume cut
                }
            });
            
            // Stop transport immediately
            Tone.Transport.stop();
            Tone.Transport.cancel(); // Cancel any scheduled events
            
            musicPlaying = false;
        }
        
        // Also stop any preview music if playing
        if (window.previewMusic && window.previewMusic.playing) {
            stopPreview();
        }
        
    } catch (error) {
        debug('Audio stop error (non-critical):', error);
    }

    // Create explosion effect
    createExplosion();
    
    // Show game over screen after a short delay to see the explosion
    setTimeout(() => {
        document.getElementById('finalScore').textContent = `Score: ${score}`;
        
        // Show total coins collected this session (no bonus since coins were added in real-time)
        document.getElementById('coinsCollected').textContent = `Final Balance: ${totalCoins} coins`;
        
        // Check if it's a high score and show input form if needed
        debug('üèÜ Checking if score is high score:', score);
        const isHighScore = checkHighScore(score);
        debug('üèÜ Is high score result:', isHighScore);

        if (isHighScore) {
            debug('üèÜ Showing name entry form');
            document.getElementById('newHighScoreMessage').style.display = 'block';
        } else {
            debug('üèÜ Not a high score - hiding name entry');
            document.getElementById('newHighScoreMessage').style.display = 'none';
        }
        
        document.getElementById('gameOver').style.display = 'flex';
        
        saveGameData('game_end');
    }, 1500);
}

        // Add this function anywhere with your other game functions
function checkHighScore(currentScore) {
    let leaderboard = JSON.parse(localStorage.getItem('runningBlitzLeaderboard') || '[]');
    
    // It's a high score if leaderboard has less than 10 entries OR current score beats the lowest score
    const isHighScore = leaderboard.length < 10 || currentScore > (leaderboard[leaderboard.length - 1]?.score || 0);
    
    debug(`Checking high score: ${currentScore}, is high score: ${isHighScore}`);
    debug(`Need to beat: ${leaderboard[leaderboard.length - 1]?.score || 0}`);
    return isHighScore;
}

        // ==================== CHARACTER ABILITIES ====================
// Special character powers, abilities, and unique mechanics
// Dependencies: Character System, Audio System, Game Loop
// Functions: activateGhostPhase(), destroyObstaclesWithFire(), etc.

// Handle character-specific abilities
function handleCharacterAbilities() {
    // Update cooldowns
    if (robotShieldCooldown > 0) robotShieldCooldown--;
    if (dragonFireCooldown > 0) dragonFireCooldown--;
    if (ghostPhaseCooldown > 0) ghostPhaseCooldown--;
    
    // Robot Electromagnetic Shield (Performance Optimized)
if (currentCharacter === 'robot') {
    // Animate wireframe shield rotation
    if (player.userData && player.userData.shieldDome && robotShieldActive) {
        const shield = player.userData.shieldDome;
        shield.rotation.y += shield.userData.rotationSpeed || 0.01;
        shield.rotation.x += (shield.userData.rotationSpeed || 0.01) * 0.5;
        
        // Pulse the electromagnetic glow
        shield.material.emissiveIntensity = 0.5 + Math.sin(frameCount * 0.1) * 0.2;
    }
    
    // Auto-activate shield when obstacles are near (if not on cooldown)
    if (!robotShieldActive && robotShieldCooldown <= 0) {
        for (const obstacle of obstacles) {
            const distance = obstacle.position.distanceTo(player.position);
            if (distance < 8 && obstacle.position.z < player.position.z) {
                activateRobotShield();
                break;
            }
        }
    }
    
    // Deactivate shield after duration
    if (robotShieldActive) {
        // Shield lasts 3 seconds (180 frames)
        if (frameCount % 180 === 0) {
            deactivateRobotShield();
        }
    }
}
    
    // Dragon Fire Breath - SIMPLIFIED VERSION
if (currentCharacter === 'dragon') {
    // Auto-destroy obstacles when they get close (no visual fire effect)
    if (dragonFireCooldown <= 0) {
        for (const obstacle of obstacles) {
            // Only check obstacles that are in front of the dragon
            if (obstacle.position.z < player.position.z - 1) {
                // Check if obstacle is in the same lane as the dragon
                const obstacleX = obstacle.position.x;
                const dragonX = lanes[currentLane]; // Dragon's current lane position
                
                // Only destroy obstacles that are:
                // 1. In the exact same lane (within 0.5 units of lane center)
                // 2. Within 6 units in front of the dragon
                if (Math.abs(obstacleX - dragonX) <= 0.5 && 
                    Math.abs(obstacle.position.z - player.position.z) <= 6) {
                    
                    // Create destruction effect without fire particles
                    createObstacleDestruction(obstacle.position);
                    
                    // Remove obstacle
                    scene.remove(obstacle);
                    obstacles.splice(obstacles.indexOf(obstacle), 1);
                    
                    debug('üî• Obstacle destroyed by dragon breath in lane', currentLane);
                    dragonFireCooldown = 240; // 4 second cooldown
                    break;
                }
            }
        }
    }
}
    
    // Ghost Phase Ability
if (currentCharacter === 'ghost') {
    // Initialize charges if starting fresh
    if (ghostPhaseCharges === 0 && ghostPhaseCooldown <= 0) {
        ghostPhaseCharges = 3;
        debug('üëª Ghost starting with 3 phase charges!');
    }
    
    // Restore charges over time (one charge every 5 seconds)
    if (ghostPhaseCharges < 3 && ghostPhaseCooldown <= 0) {
        ghostPhaseCooldown = 300; // 5 seconds to restore next charge
        debug('üëª Ghost charge restoration started...');
    }
    
    // Auto-activate phase when about to hit obstacle (if charges available)
    if (!ghostPhaseActive && ghostPhaseCharges > 0) {
        for (const obstacle of obstacles) {
            const distance = obstacle.position.distanceTo(player.position);
            if (distance < 3 && obstacle.position.z < player.position.z + 1) {
                activateGhostPhase();
                break;
            }
        }
        
        // Also check for water streams
        for (const stream of waterStreams) {
            const distance = stream.position.distanceTo(player.position);
            if (distance < 4 && stream.position.z < player.position.z + 2) {
                activateGhostPhase();
                break;
            }
        }
    }
    
    // Deactivate phase after duration
    if (ghostPhaseActive) {
        // Phase lasts 1 second (60 frames)
        if (frameCount % 60 === 0) {
            deactivateGhostPhase();
        }
    }
}
}

// Robot Shield Functions
function activateRobotShield() {
    robotShieldActive = true;
    robotShieldCooldown = 600; // 10 second cooldown
    
    debug('ü§ñ Robot electromagnetic shield activated!');
    
    // Visual effect - create bright shield dome and brighten particles
    createRobotShieldDome();
    
    if (player.userData && player.userData.fieldParticles) {
        player.userData.fieldParticles.forEach(particle => {
            particle.material.opacity = 1.0; // Much brighter
            particle.material.color.setHex(0x00FFFF);
            particle.material.emissive.setHex(0x0088FF);
            particle.material.emissiveIntensity = 0.8;
        });
    }
}

function deactivateRobotShield() {
    robotShieldActive = false;
    debug('ü§ñ Robot shield deactivated - cooldown: 10 seconds');
    
    // Remove shield dome
    if (player.userData.shieldDome) {
        player.remove(player.userData.shieldDome);
        player.userData.shieldDome = null;
    }
    
    // Visual effect - dim the field particles
    if (player.userData && player.userData.fieldParticles) {
        player.userData.fieldParticles.forEach(particle => {
            particle.material.opacity = 0.3;
            particle.material.color.setHex(0x00DDFF);
            particle.material.emissive.setHex(0x004466);
            particle.material.emissiveIntensity = 0.2;
        });
    }
}

// Create electromagnetic wireframe shield for robot
function createRobotShieldDome() {
    // Remove existing dome if any
    if (player.userData.shieldDome) {
        player.remove(player.userData.shieldDome);
    }
    
    // Create electromagnetic wireframe shield
    const shieldGeometry = new THREE.SphereGeometry(1.0, 12, 12); // Slightly higher detail for better wireframe
    const shieldMaterial = new THREE.MeshBasicMaterial({
        color: 0x00FFFF,        // Bright cyan
        emissive: 0x0088FF,     // Glowing blue
        emissiveIntensity: 0.5, // Electromagnetic glow
        transparent: true,
        opacity: 0.7,           // Semi-transparent
        wireframe: true,        // WIREFRAME MODE - looks electromagnetic!
        side: THREE.DoubleSide  // Visible from inside and outside
    });
    
    const shieldDome = new THREE.Mesh(shieldGeometry, shieldMaterial);
    player.add(shieldDome);
    player.userData.shieldDome = shieldDome;
    
    // Add subtle rotation for electromagnetic field effect
    shieldDome.userData.rotationSpeed = 0.01;
}

// Create simple shield flash effect (performance optimized)
function createShieldSparkEffect(position) {
    // Simple shield flash - just brighten the shield dome briefly
    if (player.userData.shieldDome) {
        // Flash effect by temporarily increasing opacity
        const dome = player.userData.shieldDome;
        dome.material.opacity = 0.8; // Bright flash
        
        // Return to normal opacity after a brief moment
        setTimeout(() => {
            if (dome.material) {
                dome.material.opacity = 0.3; // Back to normal
            }
        }, 100);
    }
    
    // Optional: Play a sound effect instead of visual particles
    // This gives feedback without performance cost
}

// Dragon Fire Functions
function activateDragonFire() {
    dragonFireActive = true;
    dragonFireCooldown = 480; // 8 second cooldown
    
    debug('üêâ Dragon fire breath activated!');
    
    // Make fire particles visible and reset them properly
    if (player.userData && player.userData.fireParticles) {
        player.userData.fireParticles.forEach(particle => {
            particle.visible = true;
            particle.position.set(
                (Math.random() - 0.5) * 0.3,
                0.1 + Math.random() * 0.2,
                1.0
            );
            // Ensure proper opacity and scale
            if (particle.userData) {
                particle.material.opacity = particle.userData.originalOpacity;
            }
            particle.scale.setScalar(1.0);
        });
    }
}

function deactivateDragonFire() {
    dragonFireActive = false;
    debug('üêâ Dragon fire breath deactivated - cooldown: 8 seconds');
    
    // Hide and reset fire particles aggressively
    if (player.userData && player.userData.fireParticles) {
        player.userData.fireParticles.forEach(particle => {
            particle.visible = false;
            // Reset particle position back to dragon's mouth area
            particle.position.set(
                (Math.random() - 0.5) * 0.3,
                0.1 + Math.random() * 0.2,
                particle.userData.baseZ || 0.8
            );
            // Reset opacity and scale
            particle.material.opacity = particle.userData.originalOpacity || 0.7;
            particle.scale.setScalar(1.0);
        });
    }
    
    // Additional cleanup - find any stray fire particles in the scene
    const fireParticlesToRemove = [];
    scene.traverse((object) => {
        if (object.material && 
            object.material.color && 
            (object.material.color.getHex() === 0xFF4500 || 
             object.material.color.getHex() === 0xFF6600 || 
             object.material.color.getHex() === 0xFF8800 || 
             object.material.color.getHex() === 0xFFAA00) &&
            object.geometry && 
            object.geometry.parameters && 
            object.geometry.parameters.radius === 0.04) {
            // This looks like a fire particle
            if (object.parent !== player) {
                fireParticlesToRemove.push(object);
            }
        }
    });
    
    // Remove any stray fire particles
    fireParticlesToRemove.forEach(particle => {
        if (particle.parent) {
            particle.parent.remove(particle);
        } else {
            scene.remove(particle);
        }
        debug('üî• Removed stray fire particle');
    });
}

function destroyObstaclesWithFire() {
    // Destroy obstacles in front of the dragon
    for (let i = obstacles.length - 1; i >= 0; i--) {
        const obstacle = obstacles[i];
        const distance = obstacle.position.distanceTo(player.position);
        
        // Check if obstacle is in fire range (in front of dragon)
        if (distance < 4 && obstacle.position.z > player.position.z - 1 && obstacle.position.z < player.position.z + 3) {
            // Create destruction effect
            createObstacleDestruction(obstacle.position);
            
            // Remove obstacle
            scene.remove(obstacle);
            obstacles.splice(i, 1);
            
            debug('üî• Obstacle destroyed by dragon fire!');
        }
    }
}

// Ghost Phase Functions
function activateGhostPhase() {
    ghostPhaseActive = true;
    ghostPhaseCharges--;
    
    // Start cooldown only if we're out of charges
    if (ghostPhaseCharges <= 0) {
        ghostPhaseCooldown = 300; // 5 seconds to restore first charge
    }
    
    debug(`üëª Ghost phase activated! Charges remaining: ${ghostPhaseCharges}/3`);
}

function deactivateGhostPhase() {
    ghostPhaseActive = false;
    debug('üëª Ghost phase deactivated');
    
    // Start charge restoration immediately if we have no charges left
    if (ghostPhaseCharges <= 0 && ghostPhaseCooldown <= 0) {
        ghostPhaseCooldown = 300; // 5 seconds to restore next charge
        debug('üëª Starting charge restoration...');
    }
}
// Create destruction effect for dragon fire - using existing explosion system
function createObstacleDestruction(position) {
    // Use the existing createSparkle function which works properly
    createSparkle(position);
    
    // Optional: Add a simple flash effect instead of particles
    debug('üí• Obstacle destroyed with sparkle effect!');
}

// Performance helper - only animate objects near player
function shouldAnimateObject(object, maxDistance = 15) {
    return object.position.distanceTo(player.position) < maxDistance;
}
        
        // ==================== GAME LOOP & UPDATES ====================
// Main game loop, animation, and real-time updates
// Dependencies: All game systems
// Functions: updateGame(), animate(), gameLoop(), update(), etc.

        // Game animation loop
        function animate() {
    requestAnimationFrame(animate);

    // Enhanced frustum culling - only update visible objects
const frustum = new THREE.Frustum();
const cameraMatrix = new THREE.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
frustum.setFromProjectionMatrix(cameraMatrix);

// Helper function to check if object is in view
function isInCameraView(object) {
    return frustum.intersectsObject(object);
}
    
    // Update the frame counter for all animations
    frameCount++;

    // Staggered updates for performance - different systems update on different frames
    const updateSchedule = {
        weather: frameCount % 3 === 0,      // Update weather every 3rd frame
        butterflies: frameCount % 4 === 0,   // Update butterflies every 4th frame  
        scenery: frameCount % 2 === 0,       // Update scenery every 2nd frame
        particles: frameCount % 2 === 1      // Update particles on alternating frames
    };
    
    // Handle world select screen state
    if (gameState === "worldSelect") {
        // World select screen is handled by its own animation loop
        // Just render the main scene (but don't update game logic)
        renderer.render(scene, camera);
        return;
    }
    
    if (gameState === "playing" && !gameOver && !gamePaused) {
                // Update dynamic difficulty based on time
                updateDynamicDifficulty();
                
                // Update monster character's special animations if selected
if (currentCharacter === 'monster' && player.userData) {
    // Make the dark orb rotate (but don't override jump position)
    player.rotation.y += player.userData.rotateSpeed;
    
    // Only apply bobbing animation when NOT jumping
    if (!jumping) {
        player.position.y = playerY + Math.sin(frameCount * player.userData.bobSpeed) * 0.1;
    }
    
    // Animate the smoky particles
    if (player.children) {
        // Start from index 5 to skip the main body, eyes, mouth and teeth
        for (let i = 5; i < player.children.length; i++) {
            const particle = player.children[i];
            if (particle.userData && particle.userData.initialPosition) {
                // Update angle for orbital motion
                particle.userData.angle += particle.userData.rotationSpeed;
                
                // Orbit around the monster with some oscillation
                const orbitRadius = particle.userData.initialPosition.length() + 
                    Math.sin(frameCount * particle.userData.oscillationSpeed) * 
                    particle.userData.oscillationDistance;
                
                // Calculate new position based on original angle but varying distance
                const newX = orbitRadius * Math.sin(particle.userData.angle);
                const newY = particle.userData.initialPosition.y + 
                    Math.sin(frameCount * 0.1 + i) * 0.05;
                const newZ = orbitRadius * Math.cos(particle.userData.angle);
                
                particle.position.set(newX, newY, newZ);
            }
        }
    }
} 

else if (currentCharacter === 'atom') {
    // Batch atom animations - update every other frame for performance
    if (frameCount % 2 === 0) {
        // Update Atom character animations
        // Rotate all orbitals
        for (let i = 0; i < player.children.length; i++) {
            const child = player.children[i];
            
            // Orbit rotation for the atom's orbital rings
            if (i >= 2 && i <= 4) { // These are the orbital rings
                child.rotation.z += 0.02; // Slightly faster since updating every other frame
            }
            
            // Update electrons
            if (child.userData && child.userData.orbitalIndex !== undefined) {
                const electron = child;
                const orbitalIndex = electron.userData.orbitalIndex;
                const orbitalRadius = electron.userData.orbitalRadius;
                const speed = electron.userData.speed * 2; // Double speed since updating every other frame
                
                // Update electron angle
                electron.userData.angle += speed;
                
                // Position based on orbital orientation
                if (orbitalIndex === 0) {
                    electron.position.x = Math.cos(electron.userData.angle) * orbitalRadius;
                    electron.position.z = Math.sin(electron.userData.angle) * orbitalRadius;
                } else if (orbitalIndex === 1) {
                    electron.position.y = Math.cos(electron.userData.angle) * orbitalRadius;
                    electron.position.z = Math.sin(electron.userData.angle) * orbitalRadius;
                } else {
                    electron.position.x = Math.cos(electron.userData.angle) * orbitalRadius * 0.7;
                    electron.position.y = Math.cos(electron.userData.angle) * orbitalRadius * 0.7;
                    electron.position.z = Math.sin(electron.userData.angle) * orbitalRadius;
                }
            }
            
            // Pulse nucleus sparkles
            if (i === 0) { // Nucleus
                // Update sparkles inside the nucleus
                if (child.children) {
                    child.children.forEach(sparkle => {
                        if (sparkle.userData) {
                            // Pulse size of sparkle
                            const pulseScale = 0.8 + Math.sin(frameCount * sparkle.userData.pulseSpeed + sparkle.userData.pulsePhase) * 0.3;
                            sparkle.scale.set(pulseScale, pulseScale, pulseScale);
                        }
                    });
                }
            }
            
            // Pulse the glow
            if (i === 1) { // Glow sphere
                // Pulse size and opacity
                const pulseScale = 1.0 + Math.sin(frameCount * 0.05) * 0.1;
                child.scale.set(pulseScale, pulseScale, pulseScale);
                child.material.opacity = 0.3 + Math.sin(frameCount * 0.08) * 0.15;
            }
        }
        
        // Add gentle rotation if not jumping
        if (!jumping) {
            player.rotation.y += 0.04; // Double speed since updating every other frame
        }
    }
} else if (currentCharacter === 'ufo' && player.userData) {
    // Rotate the outer ring
    if (player.userData.ring) {
        player.userData.ring.rotation.y += 0.03;
    }
    
    // Pulse the lights
    if (player.userData.lights) {
        player.userData.lights.children.forEach((light, index) => {
            if (light.userData) {
                const pulse = Math.sin(frameCount * light.userData.pulseSpeed + light.userData.pulsePhase);
                light.material.emissiveIntensity = light.userData.originalIntensity + pulse * 0.5;
                
                // Occasional color flash
                if (Math.random() < 0.01) {
                    light.material.color.setHex(0xFFFFFF);
                    light.material.emissive.setHex(0xFFFFFF);
                    setTimeout(() => {
                        light.material.color.setHex(light.userData.originalColor);
                        light.material.emissive.setHex(light.userData.originalColor);
                    }, 100);
                }
            }
        });
    }
    
    // Pulse the dome
    if (player.userData.dome) {
        const domePulse = Math.sin(frameCount * 0.03) * 0.2 + 0.5;
        player.userData.dome.material.emissiveIntensity = domePulse;
    }
    
    // Animate tractor beam
    if (player.userData.beam) {
        const beamPulse = Math.sin(frameCount * 0.05) * 0.1 + 0.2;
        player.userData.beam.material.opacity = beamPulse;
        player.userData.beam.rotation.y += 0.02;
    }
    
    // Float energy particles
    if (player.userData.particles) {
        player.userData.particles.forEach(particle => {
            if (particle.userData) {
                // Orbit motion
                particle.userData.orbitAngle += particle.userData.orbitSpeed;
                const x = Math.cos(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                const z = Math.sin(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                
                // Floating motion
                const floatY = Math.sin(frameCount * particle.userData.floatSpeed + particle.userData.floatOffset) * 0.3;
                
                particle.position.set(x, floatY, z);
                
                // Particle glow pulse
                const glowPulse = Math.sin(frameCount * 0.08 + particle.userData.floatOffset) * 0.3 + 0.7;
                particle.material.opacity = glowPulse;
            }
        });
    }
    
    // Gentle hovering motion when not jumping
    if (!jumping) {
        player.position.y = playerY + Math.sin(frameCount * 0.04) * 0.08;
    }
} else if (currentCharacter === 'dragon' && player.userData) {
    // Animate dragon wings during gameplay
    if (player.userData.wings) {
        const wingFlap = Math.sin(frameCount * 0.15) * 0.3;
        player.userData.wings[0].rotation.z = Math.PI / 3 + wingFlap; // Left wing
        player.userData.wings[1].rotation.z = -Math.PI / 3 - wingFlap; // Right wing
    }
    
    // Animate fire particles when fire breath is active
    if (player.userData.fireParticles) {
        player.userData.fireParticles.forEach((particle, index) => {
            if (dragonFireActive) {
                // Show particle and animate it
                particle.visible = true;
                
                // Keep particles close to dragon mouth with flickering
                const flicker = Math.sin(frameCount * 0.2 + index) * 0.3 + 0.7;
                particle.material.opacity = particle.userData.originalOpacity * flicker;
                particle.scale.setScalar(0.8 + flicker * 0.4);
            } else {
                // Fire is not active - hide particle
                particle.visible = false;
            }
        });
    }
} else if (currentCharacter === 'robot') {
    // Robot running animation - only during gameplay
    if (gameStarted && !gameOver && !gamePaused) {
        // Running body bob - up and down motion
        if (!jumping) {
            const runBob = Math.sin(frameCount * 0.3) * 0.08; // Faster, smaller bob
            player.position.y = playerY + runBob;
        }
        
        // Animate robot arms for running motion
        if (player.children.length >= 6) { // Make sure arms exist
            const leftArm = player.children[4];  // Left arm
            const rightArm = player.children[5]; // Right arm
            
            if (leftArm && rightArm) {
                // Alternating arm swing - opposite arms move opposite directions
                const armSwing = Math.sin(frameCount * 0.3) * 0.4; // Running pace
                
                leftArm.rotation.x = armSwing;        // Left arm forward/back
                rightArm.rotation.x = -armSwing;      // Right arm opposite direction
                
                // Add slight side-to-side motion for more natural running
                leftArm.rotation.z = Math.sin(frameCount * 0.15) * 0.1;
                rightArm.rotation.z = -Math.sin(frameCount * 0.15) * 0.1;
            }
        }
        
        // Slight forward lean while running
        if (!jumping) {
            player.rotation.x = Math.sin(frameCount * 0.3) * 0.05; // Subtle forward/back lean
        }
        
        // Add slight head bob for realism
        if (player.children.length >= 2) {
            const head = player.children[1]; // Head
            if (head) {
                head.rotation.x = Math.sin(frameCount * 0.3 + Math.PI/4) * 0.08; // Slight head bob
            }
        }

// Animate robot legs for running motion
        if (player.children.length >= 8) { // Make sure legs exist
            const leftLeg = player.children[6];  // Left leg
            const rightLeg = player.children[7]; // Right leg
            
            if (leftLeg && rightLeg) {
                // Create the same armSwing calculation for legs
                const armSwing = Math.sin(frameCount * 0.3) * 0.4; // Same as arms
                
                // Forward/back leg swing (opposite to arms for natural running)
                leftLeg.rotation.x = -armSwing * 0.8;   // Left leg opposite to left arm
                rightLeg.rotation.x = armSwing * 0.8;   // Right leg opposite to right arm
                
                // Slight up/down leg movement for realistic stride
                const legLift = Math.abs(Math.sin(frameCount * 0.3)) * 0.05;
                leftLeg.position.y = -0.5 + (armSwing > 0 ? legLift : 0);  // Lift when swinging forward
                rightLeg.position.y = -0.5 + (-armSwing > 0 ? legLift : 0); // Lift when swinging forward
                
                // Add slight side-to-side leg motion for natural gait
                leftLeg.rotation.z = Math.sin(frameCount * 0.15) * 0.05;
                rightLeg.rotation.z = -Math.sin(frameCount * 0.15) * 0.05;
            }
        }

    }
} else if (!jumping && currentCharacter !== 'dragon' && currentCharacter !== 'ghost') {
    // Standard rotation for other characters when not jumping (except robot, dragon, and ghost)
    player.rotation.y += 0.02;
}

// Handle character-specific abilities
handleCharacterAbilities();
                
                // Move player to target lane
                const targetX = lanes[currentLane];
                
                // Adjust movement speed for carrot character (faster lane changes)
                const moveSpeed = currentCharacter === 'carrot' ? 0.15 : 0.1;
                player.position.x += (targetX - player.position.x) * moveSpeed;
                
                // Handle jumping with front flip animation
                if (jumping) {
                    // Apply jump speed with a moderate peak slowdown effect
                    let jumpFactor = 1.0;
                    
                    // Apply a mild slowdown effect near the peak of the jump
                    if (jumpDirection === -1) {
                        // Only slow down during the fall, and only near the top
                        const heightProgress = (player.position.y - playerY) / jumpHeight;
                        if (heightProgress > 0.7) {
                            // Apply more slowdown near the very top (max 40% slowdown)
                            jumpFactor = 0.6 + (0.4 * (1.0 - heightProgress));
                        }
                    }
                    
                    // Apply the adjusted jump speed
                    player.position.y += jumpSpeed * jumpDirection * jumpFactor;
                    
                    // Add front flip animation (but not for UFO or Dragon)
if (currentCharacter !== 'ufo' && currentCharacter !== 'dragon') {
    if (jumpDirection === 1) {
        // Going up - first half of the jump
        jumpRotation += 0.09; // Slightly slower rotation
        // Complete a full rotation (2*PI) over the jump duration
        player.rotation.x = jumpRotation;
    } else {
        // Going down - second half of the jump
        jumpRotation += 0.09; // Slightly slower rotation
        player.rotation.x = jumpRotation;
    }
}
                    
                    // Change direction at peak
                    if (player.position.y >= playerY + jumpHeight) {
                        jumpDirection = -1;
                    }
                    
                    // End jump when back on ground
if (jumpDirection === -1 && player.position.y <= playerY) {
    player.position.y = playerY;
    if (currentCharacter !== 'ufo' && currentCharacter !== 'dragon') {
        player.rotation.x = 0; // Reset rotation (but not for UFO or Dragon)
    }
    jumping = false;
                        
                        // Reset jump speed to normal in case it was modified by quickDrop
if (currentCharacter === 'pumpkin') {
    jumpSpeed = 0.08;
} else {
    jumpSpeed = 0.065;
}
                    }
                }


                
                // Update power-up timers
                if (shieldActive) {
                    powerUpTimers.shield--;
                    if (powerUpTimers.shield <= 0) {
                        shieldActive = false;
                        if (player.userData.shieldEffect) {
                            player.remove(player.userData.shieldEffect);
                            player.userData.shieldEffect = null;
                        }
                        debug('Shield deactivated!');
                    }
                }

                if (coinMultiplierActive) {
                    powerUpTimers.coinMultiplier--;
                    if (powerUpTimers.coinMultiplier <= 0) {
                        coinMultiplierActive = false;
                        debug('Coin multiplier deactivated!');
                    }
                }

                if (magnetActive) {
                    powerUpTimers.magnet--;
                    if (powerUpTimers.magnet <= 0) {
                        magnetActive = false;
                        debug('Magnet deactivated!');
                    }
                }

// Update the status bars
updatePowerUpStatusBar();
updateAbilityStatusBar();
                
                // Staggered updates for better performance
                if (updateSchedule.weather) updateWeather();
                if (updateSchedule.butterflies) updateButterfliesAndBirds();
                
                // Update water streams
                updateWaterStreams();
                
                // Move ground segments with current speed
groundSegments.forEach(segment => {
    segment.position.z += currentSpeed;
    if (segment.position.z > 55) {
        // Move it to the back
        segment.position.z = -45 * groundSegments.length / 2;
    }
});

// Move side terrain segments with current speed - perfectly synced with ground segments
for (let i = 0; i < groundSegments.length; i++) {
    const groundSegment = groundSegments[i];
    
    // Each ground segment has 4 corresponding side terrain pieces
    const startIndex = i * 4;
    const endIndex = startIndex + 4;
    
    // Sync the 4 side terrain pieces with this ground segment
    for (let j = startIndex; j < endIndex && j < sideTerrainSegments.length; j++) {
        const sideTerrain = sideTerrainSegments[j];
        sideTerrain.position.z = groundSegment.position.z; // Exact sync
    }
}
                
                // Track distance for score
                distanceTraveled += currentSpeed;
                if (Math.floor(distanceTraveled) % 10 === 0) {
                    score++;
                    updateScore();
                }

                // Clean collision cache periodically for performance
if (frameCount % 300 === 0) { // Every 5 seconds
    cleanupCollisionCache(obstacles, 'obstacle');
    cleanupCollisionCache(coins, 'coin');
    cleanupCollisionCache(powerUps, 'powerup');
}
                
                // Spawn obstacles using dynamic spawn rate
                if (frameCount % currentObstacleSpawnRate === 0) {
                    spawnObstacle();
                }

                // Spawn meteors only at Maximum Chaos level (speed level 4+)
if (currentSpeedLevel >= 4) {
    meteorSpawnCounter++;
    
    if (meteorSpawnCounter >= meteorSpawnRate) {
    debug("METEOR SPAWNING NOW!");
    createMeteor();
    meteorSpawnCounter = 0;
    // Randomize next meteor spawn time (slower)
    meteorSpawnRate = 400 + Math.floor(Math.random() * 400); // 400-800 frames (13-27 seconds)
    debug(`Next meteor in ${meteorSpawnRate} frames`);
}
    
    // Only log every 30 frames to reduce spam
    if (meteorSpawnCounter % 30 === 0) {
    debug(`Meteor spawn check - Level: ${currentSpeedLevel}, Counter: ${meteorSpawnCounter}, Rate: ${meteorSpawnRate}`);
}
}
                
                // Track stream spawning
                streamSpawnCounter++;
                streamCreated = false;
                
                // Spawn streams using dynamic spawn rate (much less frequent)
                if (frameCount % currentStreamSpawnRate === 0) {
                    spawnWaterStream();
                }
                
                // Spawn coins
if (frameCount % coinSpawnRate === 0) {
    // 2% chance of spawning rare coin instead of regular coin //RARECOIN
    if (Math.random() < 0.0075) {
        spawnRareCoin();
    } else {
        spawnCoin();
    }
}

// Spawn power-ups with collision avoidance
if (frameCount % powerUpSpawnRate === 0) {
    // Get available lanes (avoid lanes with recent power-ups)
    const availableLanes = [];
    for (let i = 0; i < 3; i++) {
        let laneBlocked = false;
        // Check if any power-up is in this lane and still close
        for (const powerUp of powerUps) {
            if (Math.abs(powerUp.position.x - lanes[i]) < 0.5 && powerUp.position.z > -20) {
                laneBlocked = true;
                break;
            }
        }
        if (!laneBlocked) {
            availableLanes.push(i);
        }
    }
    
    // Only spawn if we have available lanes
    if (availableLanes.length > 0) {
        const powerUpType = Math.random();
        debug("Spawning power-up at frame:", frameCount, "Available lanes:", availableLanes);
        
        if (powerUpType < 0.33) {
            spawnShieldPowerUpInLane(availableLanes);
            debug("Shield power-up spawned");
        } else if (powerUpType < 0.66) {
            spawnCoinMultiplierPowerUpInLane(availableLanes);
            debug("Coin multiplier power-up spawned");
        } else {
            spawnMagnetPowerUpInLane(availableLanes);
            debug("Magnet power-up spawned");
        }
    } else {
        debug("No available lanes for power-up spawn");
    }
}


                
                // Spawn scenery objects (stays constant)
                if (frameCount % scenerySpawnRate === 0) {
                    spawnScenery();
                }
                
                // Move and animate coins with current speed
for (let i = coins.length - 1; i >= 0; i--) {
    const coin = coins[i];
    coin.position.z += currentSpeed;
    
    // Rotate coin for visual appeal
    coin.rotation.y += 0.05;
    
    // Highlight removed - no longer needed
    
    // Animate sparkles only for nearby coins (performance optimization)
if (coin.userData.sparkles && coin.position.distanceTo(player.position) < 10) {
    coin.userData.sparkles.forEach(sparkle => {
        // Orbit around the coin
        sparkle.userData.orbitAngle += sparkle.userData.orbitSpeed;
        sparkle.position.x = Math.cos(sparkle.userData.orbitAngle) * sparkle.userData.orbitRadius;
        sparkle.position.z = Math.sin(sparkle.userData.orbitAngle) * sparkle.userData.orbitRadius;
        
        // Pulse the sparkle size and opacity
        const pulseScale = 0.5 + Math.sin(frameCount * sparkle.userData.pulseSpeed + sparkle.userData.pulsePhase) * 0.5;
        sparkle.scale.set(pulseScale, pulseScale, pulseScale);
        sparkle.material.opacity = 0.6 + Math.sin(frameCount * sparkle.userData.pulseSpeed * 1.5 + sparkle.userData.pulsePhase) * 0.4;
    });
}
                    
                    // Magnet effect - attract coins to player
if (magnetActive) {
    const distance = coin.position.distanceTo(player.position);
    if (distance < 5) { // Magnet range
        const direction = new THREE.Vector3().subVectors(player.position, coin.position).normalize();
        coin.position.add(direction.multiplyScalar(0.2)); // Pull towards player
    }
}

// Check if collected - only if coin is actually near player
const coinDistance = coin.position.distanceTo(player.position);
if (coinDistance < 1.5 && checkCollision(coin)) {
    // Coin collected!
    playCoinSound();
    createSparkle(coin.position.clone());
    scene.remove(coin);
    coins.splice(i, 1);
    
    // Apply coin multiplier to both score and coin balance
    const coinValue = coinMultiplierActive ? 20 : 10; // 2x when multiplier active
    const actualCoins = coinMultiplierActive ? 2 : 1; // 2x coins when multiplier active
    
    score += coinValue;
    totalCoins += actualCoins; // Add coins to balance immediately
    
    updateScore();
    updateTotalCoins(); // Update coin display immediately
    

    
    if (coinMultiplierActive) {
        debug('Coin collected with 2x multiplier!');
    }
}
                    
                    // Remove coins that have passed the player
                    else if (coin.position.z > 5) {
                        scene.remove(coin);
                        coins.splice(i, 1);
                    }
                }

// Move and animate rare coins
                for (let i = rareCoins.length - 1; i >= 0; i--) {
                    const rareCoin = rareCoins[i];
                    rareCoin.position.z += playerSpeed; // Use the existing playerSpeed variable
                    
                    // Rotate rare coin faster for visual appeal
                    rareCoin.rotation.y += rareCoin.userData.rotationSpeed;
                    
                    // Animate sparkles around the rare coin
                    if (rareCoin.userData.sparkles) {
                        rareCoin.userData.sparkles.forEach(sparkle => {
                            // Orbit around the coin
                            sparkle.userData.orbitAngle += sparkle.userData.orbitSpeed;
                            sparkle.position.x = Math.cos(sparkle.userData.orbitAngle) * sparkle.userData.orbitRadius;
                            sparkle.position.z = Math.sin(sparkle.userData.orbitAngle) * sparkle.userData.orbitRadius;
                            
                            // Pulse the sparkle
                            const pulseScale = 0.5 + Math.sin(frameCount * sparkle.userData.pulseSpeed + sparkle.userData.pulsePhase) * 0.5;
                            sparkle.scale.set(pulseScale, pulseScale, pulseScale);
                            sparkle.material.opacity = 0.6 + Math.sin(frameCount * sparkle.userData.pulseSpeed * 1.5 + sparkle.userData.pulsePhase) * 0.4;
                        });
                    }
                    
                    // Magnet effect for rare coins too
if (magnetActive) {
    const distance = rareCoin.position.distanceTo(player.position);
    if (distance < 5) { // Magnet range
        const direction = new THREE.Vector3().subVectors(player.position, rareCoin.position).normalize();
        rareCoin.position.add(direction.multiplyScalar(0.2)); // Pull towards player
    }
}

// Check if collected
if (checkCollision(rareCoin)) {
    // Rare coin collected! Big reward!
    playRareCoinSound(); // Add this line
    createSparkle(rareCoin.position.clone());
    scene.remove(rareCoin);
    rareCoins.splice(i, 1);
    
    // Apply multiplier to rare coins too
    const rareScoreBonus = coinMultiplierActive ? 200 : 100;
    const rareCoinBonus = coinMultiplierActive ? 200 : 100;
    
    score += rareScoreBonus;
    totalCoins += rareCoinBonus;
    updateScore();
    updateTotalCoins();
    
    
    debug(`RARE COIN COLLECTED! +${rareCoinBonus} coins!`);
    if (coinMultiplierActive) {
        debug('Rare coin got 2x multiplier bonus!');
    }
}
                    
                    // Remove rare coins that have passed the player
                    else if (rareCoin.position.z > 5) {
                        scene.remove(rareCoin);
                        rareCoins.splice(i, 1);
                    }
                }

                // Move and animate power-ups
                for (let i = powerUps.length - 1; i >= 0; i--) {
                    const powerUp = powerUps[i];
                    
                    
                    
                    powerUp.position.z += currentSpeed; // Use same speed as other objects
                    
                    // Rotate power-up for visual appeal
                    powerUp.rotation.y += 0.03;
                    
                    // Animate specific power-up effects
                    if (powerUp.userData.type === 'shield' && powerUp.userData.particles) {
                        // Animate shield particles
                        powerUp.userData.particles.forEach(particle => {
                            particle.userData.orbitAngle += particle.userData.orbitSpeed;
                            particle.position.x = Math.cos(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                            particle.position.y = Math.sin(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                        });
                    } else if (powerUp.userData.type === 'magnet' && powerUp.userData.fieldParticles) {
                        // Animate magnet field particles
                        powerUp.userData.fieldParticles.forEach(particle => {
                            particle.userData.orbitAngle += particle.userData.orbitSpeed;
                            particle.position.x = Math.cos(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                            particle.position.y = Math.sin(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                        });
                    }
                    
                    // Check for collision with player using simple distance
const distance = powerUp.position.distanceTo(player.position);

if (distance < 1.5) { // Simple distance-based collision
    activatePowerUp(powerUp.userData.type);
    scene.remove(powerUp);
    powerUps.splice(i, 1);
}
                    
                    // Remove power-ups that have passed the player
                    else if (powerUp.position.z > 5) {
                        debug(`Removing power-up ${powerUp.userData.type} that passed player`);
                        scene.remove(powerUp);
                        powerUps.splice(i, 1);
                    }
                }
                
                // Move obstacles with current speed
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    const obstacle = obstacles[i];
                    obstacle.position.z += currentSpeed;
                    
// Check for collision
if (checkCollision(obstacle)) {
    // Collision detected
    
    if (shieldActive) {
        // Shield protects - remove obstacle instead
        scene.remove(obstacle);
        obstacles.splice(i, 1);
        debug('Shield blocked collision!');
    } else {
        endGame();
    }
}
                    
                    // Remove obstacles that have passed the player
                    if (obstacle.position.z > 5) {
                        scene.remove(obstacle);
                        obstacles.splice(i, 1);
                    }
                }
                
                // Move scenery objects with current speed - only animate nearby objects
for (let i = sceneryObjects.length - 1; i >= 0; i--) {
    const scenery = sceneryObjects[i];
    scenery.position.z += currentSpeed;
    
    // Only run complex animations for nearby scenery
    if (!shouldAnimateObject(scenery, 20)) {
        // Skip animations for distant objects
        if (scenery.position.z > 20) {
            scene.remove(scenery);
            sceneryObjects.splice(i, 1);
        }
        continue;
    }
    
    // Animate forest-specific scenery
    if (currentWorld === 'forest') {
        scenery.children.forEach(child => {
            // Animate ferns swaying
            if (child.userData && child.userData.swaySpeed) {
                child.rotation.z = Math.sin(frameCount * child.userData.swaySpeed + child.userData.swayOffset) * child.userData.swayAmount;
            }
            
            // Animate fireflies floating
            if (child.userData && child.userData.floatSpeed) {
                child.userData.floatAngle += child.userData.floatSpeed;
                const floatX = Math.cos(child.userData.floatAngle) * child.userData.floatRadius;
                const floatY = Math.sin(child.userData.floatAngle * 0.7) * child.userData.floatRadius * 0.5;
                
                child.position.x = child.userData.basePosition.x + floatX;
                child.position.y = child.userData.basePosition.y + floatY;
                
                // Pulse brightness
                const pulse = Math.sin(frameCount * child.userData.pulseSpeed + child.userData.pulsePhase) * 0.5 + 0.5;
                child.material.opacity = 0.4 + pulse * 0.6;
            }
            
            // Animate magical orbs around ancient oaks
            if (child.userData && child.userData.orbitSpeed) {
                child.userData.orbitAngle += child.userData.orbitSpeed;
                child.position.x = Math.cos(child.userData.orbitAngle) * child.userData.orbitRadius;
                child.position.z = Math.sin(child.userData.orbitAngle) * child.userData.orbitRadius;
                
                // Gentle floating motion
                const float = Math.sin(frameCount * child.userData.pulseSpeed) * 0.3;
                child.position.y = child.userData.baseHeight + float;
                
                // Pulse the magical orbs
                const orbPulse = Math.sin(frameCount * child.userData.pulseSpeed) * 0.4 + 0.6;
                child.material.opacity = orbPulse;
                child.scale.setScalar(0.8 + orbPulse * 0.4);
            }
        });
    }
    
    // Remove scenery that has passed the player
    if (scenery.position.z > 20) {
        scene.remove(scenery);
        sceneryObjects.splice(i, 1);
    }
}

// Update meteors
for (let i = meteors.length - 1; i >= 0; i--) {
    const meteor = meteors[i];
    
    
    
    // Move meteor down and sync with player's movement
meteor.position.y -= meteor.userData.fallSpeed;
// Move at exactly the same speed as the game world so it crashes right where player is
meteor.position.z += currentSpeed; // Same speed as scene - will hit player's position

// Keep meteor aligned to its target lane (no drift)
meteor.position.x = lanes[meteor.userData.targetLane];
    
    // Rotate meteor
    meteor.rotation.x += meteor.userData.rotationSpeed;
    meteor.rotation.y += meteor.userData.rotationSpeed * 0.7;
    meteor.rotation.z += meteor.userData.rotationSpeed * 0.5;
    
    // Animate floating chunks
    if (meteor.userData.chunks) {
        meteor.userData.chunks.forEach(chunk => {
            chunk.userData.orbitAngle += chunk.userData.orbitSpeed;
            const newX = Math.cos(chunk.userData.orbitAngle) * chunk.userData.orbitRadius;
            const newZ = Math.sin(chunk.userData.orbitAngle) * chunk.userData.orbitRadius;
            chunk.position.x = newX;
            chunk.position.z = newZ;
        });
    }
    
    // Animate fire trail
    if (meteor.userData.trailParticles) {
        meteor.userData.trailParticles.forEach(particle => {
            const flicker = Math.sin(frameCount * particle.userData.flickerSpeed) * 0.3 + 0.7;
            particle.material.opacity = particle.userData.originalOpacity * flicker;
            particle.scale.setScalar(0.8 + flicker * 0.4);
        });
    }
    
    // Check for collision with player (only if meteor is at ground level and same lane)
const meteorLane = meteor.userData.targetLane;
const playerLane = currentLane;

if (meteorLane === playerLane && meteor.position.y <= 1.0 && checkCollision(meteor)) {
    endGame();
}
    
    // Remove meteor if it hits the ground or goes too far ahead
if (meteor.position.y < -1 || meteor.position.z > player.position.z + 15) {
    // Create impact effect when hitting ground
    if (meteor.position.y < -1) {
        createMeteorImpact(meteor.position);
    }
    
    scene.remove(meteor);
    meteors.splice(i, 1);
}
}
                
                // Update sparkle animations
                updateSparkles();
// Update background music intensity
                updateBackgroundMusic();


            } else if (gameOver) {
                // Update explosion animation if game is over
                updateExplosion();
                // Continue updating sparkles even in game over state
                updateSparkles();
                // Continue updating weather in game over state
                updateWeather();
                updateButterfliesAndBirds();
            }
            
            renderer.render(scene, camera);
        }
        
        // Initialize on load
        document.addEventListener('DOMContentLoaded', init);

        // ==================== AUTOMATIC SAVE SYSTEM ====================
// Save game data when page closes or periodically

// Save every 30 seconds during gameplay
let autoSaveInterval;

function startAutoSave() {
    if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
    }
    
    autoSaveInterval = setInterval(() => {
        if (gameState === "playing" && !gamePaused) {
            debug('üîÑ Auto-saving game progress...');
            saveGameData();
        }
    }, 30000); // Every 30 seconds
}

function stopAutoSave() {
    if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
        autoSaveInterval = null;
    }
}

// Save when page is about to close
window.addEventListener('beforeunload', function(event) {
    debug('üíæ Saving game data before page closes...');
    saveGameData();
});

// Save when page becomes hidden (mobile/tab switching)
document.addEventListener('visibilitychange', function() {
    if (document.hidden) {
        debug('üíæ Saving game data (page hidden)...');
        saveGameData();
    }
});

// Save when window loses focus
window.addEventListener('blur', function() {
    debug('üíæ Saving game data (window lost focus)...');
    saveGameData();
});

// Start auto-save when game starts
startAutoSave();
    </script>
</body>
</html>