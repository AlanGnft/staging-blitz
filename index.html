<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Endless Runner</title>

    <link rel="manifest" href="manifest.json">

    <!-- PWA Meta Tags -->
<meta name="theme-color" content="#4CAF50">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Running Blitz">
<link rel="apple-touch-icon" href="icon-192.png">


<!-- Firebase Scripts -->
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>

<script>
// Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyDr_qv6W6AxuXGWG49bTdr0j2DvmMZObnA",
  authDomain: "running-blitz.firebaseapp.com",
  databaseURL: "https://running-blitz-default-rtdb.firebaseio.com",
  projectId: "running-blitz",
  storageBucket: "running-blitz.firebasestorage.app",
  messagingSenderId: "511589639020",
  appId: "1:511589639020:web:a0c3cbc26e293a00834949"
};

// Initialize Firebase
firebase.initializeApp(firebaseConfig);

// Add debug logging
console.log('üî• Firebase initialized, starting save system...');

// Force initialize save system after page loads
setTimeout(() => {
    if (typeof initializeSaveSystem === 'function') {
        console.log('‚úÖ initializeSaveSystem function found, calling...');
        initializeSaveSystem();
    } else {
        console.error('‚ùå initializeSaveSystem function not found! Retrying...');
        // Try again after more delay
        setTimeout(() => {
            if (typeof initializeSaveSystem === 'function') {
                console.log('‚úÖ initializeSaveSystem function found on retry, calling...');
                initializeSaveSystem();
            } else {
                console.error('‚ùå initializeSaveSystem function still not found after retry!');
            }
        }, 2000);
    }
}, 1000);
</script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #000;
            touch-action: none; /* Disable browser's default touch actions */
        }
        #score {
    position: absolute;
    top: 20px;
    right: 20px;
    color: white;
    font-size: 24px;
    z-index: 100;
    text-align: right;
}
        #totalCoins {
    position: absolute;
    top: 55px;
    right: 20px;
    color: gold;
    font-size: 20px;
    z-index: 100;
    text-align: right;
}
        #pauseBtn {
    position: absolute;
    top: 95px;
    right: 70px;
    width: 44px;
    height: 44px;
    background: rgba(0, 0, 0, 0.7);
    border: 2px solid rgba(255, 255, 255, 0.8);
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    color: white;
    cursor: pointer;
    z-index: 100;
    transition: all 0.2s ease;
    backdrop-filter: blur(10px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    padding: 0;
}

#pauseBtn:hover {
    background: rgba(255, 255, 255, 0.9);
    color: #333;
    transform: scale(1.05);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
}

#pauseBtn:active {
    transform: scale(0.95);
}

#skipBtn {
    position: absolute;
    top: 95px;
    right: 20px;
    width: 44px;
    height: 44px;
    background: rgba(0, 0, 0, 0.7);
    border: 2px solid rgba(255, 255, 255, 0.8);
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    color: white;
    cursor: pointer;
    z-index: 100;
    transition: all 0.2s ease;
    backdrop-filter: blur(10px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    padding: 0;
}

#skipBtn:hover {
    background: rgba(76, 175, 80, 0.9);
    color: white;
    transform: scale(1.05);
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
    border-color: rgba(76, 175, 80, 1);
}

/* Reset hover state quickly on mobile */
#skipBtn:not(:hover) {
    transition: all 0.3s ease;
}

#skipBtn:active {
    transform: scale(0.95);
}

/* SVG icons inherit color from parent */
#pauseBtn svg, #skipBtn svg {
    pointer-events: none;
}
        
        #speedIndicator {
    position: absolute;
    top: 20px;
    left: 20px;
    padding: 12px 20px;
    background-color: rgba(255, 255, 255, 0.3);
    border-radius: 25px;
    color: white;
    font-size: 18px;
    font-weight: bold;
    z-index: 100;
    border: 2px solid rgba(255, 255, 255, 0.5);
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
    transition: all 0.5s ease;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    min-width: 200px;
    white-space: nowrap;
    text-align: center;
}


    
    /* Mobile responsive adjustments */
@media screen and (max-width: 768px) {
    #score {
        font-size: 20px;
        top: 15px;
        right: 15px;
    }
    
    #totalCoins {
        font-size: 18px;
        top: 45px;
        right: 15px;
    }
    
    #pauseBtn {
    width: 38px;
    height: 38px;
    font-size: 16px;
    top: 80px;
    right: 60px;
}

#skipBtn {
    width: 38px;
    height: 38px;
    font-size: 16px;
    top: 80px;
    right: 15px;
}
    
    #speedIndicator {
    top: 15px;
    left: 15px;
    font-size: 12px;
    padding: 6px 12px;
    min-width: 180px;
    max-width: none;
}
}

/* Speed level animations */
.speed-level-1 {
    background: linear-gradient(45deg, rgba(135, 206, 235, 0.8), rgba(100, 149, 237, 0.8));
    border-color: rgba(135, 206, 235, 0.8);
    box-shadow: 0 0 15px rgba(135, 206, 235, 0.5);
}

.speed-level-2 {
    background: linear-gradient(45deg, rgba(255, 215, 0, 0.8), rgba(255, 165, 0, 0.8));
    border-color: rgba(255, 215, 0, 0.8);
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
    animation: pulse-yellow 1s infinite alternate;
}

.speed-level-3 {
    background: linear-gradient(45deg, rgba(255, 69, 0, 0.8), rgba(255, 140, 0, 0.8));
    border-color: rgba(255, 69, 0, 0.8);
    box-shadow: 0 0 25px rgba(255, 69, 0, 0.7);
    animation: pulse-orange 0.8s infinite alternate;
    border-radius: 15px;
}

.speed-level-4 {
    background: linear-gradient(45deg, rgba(220, 20, 60, 0.9), rgba(255, 0, 0, 0.9));
    border-color: rgba(220, 20, 60, 0.9);
    box-shadow: 0 0 30px rgba(220, 20, 60, 0.8), inset 0 0 10px rgba(255, 0, 0, 0.3);
    animation: intense-flame 0.6s infinite alternate;
    border-radius: 10px;
}

.speed-level-5 {
    background: linear-gradient(45deg, rgba(139, 0, 139, 0.9), rgba(75, 0, 130, 0.9));
    border-color: rgba(139, 0, 139, 0.9);
    box-shadow: 0 0 35px rgba(139, 0, 139, 0.9), inset 0 0 15px rgba(75, 0, 130, 0.4);
    animation: chaos-mode 0.4s infinite;
    border-radius: 5px;
}

@keyframes pulse-yellow {
    0% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.6); }
    100% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.8); }
}

@keyframes pulse-orange {
    0% { box-shadow: 0 0 25px rgba(255, 69, 0, 0.7); }
    100% { box-shadow: 0 0 35px rgba(255, 69, 0, 0.9); }
}

@keyframes intense-flame {
    0% { 
        box-shadow: 0 0 30px rgba(220, 20, 60, 0.8), inset 0 0 10px rgba(255, 0, 0, 0.3);
    }
    100% { 
        box-shadow: 0 0 40px rgba(220, 20, 60, 1.0), inset 0 0 20px rgba(255, 0, 0, 0.5);
    }
}

@keyframes chaos-mode {
    0% { 
        box-shadow: 0 0 35px rgba(139, 0, 139, 0.9), inset 0 0 15px rgba(75, 0, 130, 0.4);
    }
    25% { 
        box-shadow: 0 0 45px rgba(255, 0, 255, 1.0), inset 0 0 25px rgba(138, 43, 226, 0.6);
    }
    50% { 
        box-shadow: 0 0 40px rgba(75, 0, 130, 1.0), inset 0 0 20px rgba(139, 0, 139, 0.5);
    }
    100% { 
        box-shadow: 0 0 50px rgba(139, 0, 139, 1.0), inset 0 0 30px rgba(75, 0, 130, 0.7);
    }
}
        #pauseScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 150;
        }
        #pauseScreen h2 {
            color: white;
            font-size: 48px;
            margin-bottom: 20px;
        }
        #pauseScreen p {
            color: white;
            font-size: 24px;
            margin-bottom: 20px;
        }
        #resumeButton {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 10px;
        }
        #gameOver {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 150;
    text-align: center;
    color: white;
    font-size: 24px;
    padding: 20px;
    box-sizing: border-box;
}
        
        #startScreen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 200;
}
        #startScreen h1 {
            color: white;
            font-size: 48px;
            margin-bottom: 20px;
        }
        #startButton {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .game-button {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
        }
        #settingsScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            background-color: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 150;
            border-radius: 10px;
            padding: 20px;
            overflow-y: auto;
        }
        #settingsScreen h2 {
            color: white;
            font-size: 36px;
            margin-bottom: 20px;
        }
        .settings-section {
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            width: 100%;
            margin-bottom: 20px;
            padding: 15px;
            box-sizing: border-box;
        }
        .settings-section h3 {
            color: white;
            margin-top: 0;
            text-align: center;
        }
        .character-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            width: 100%;
        }
        .character-option {
            display: flex;
            align-items: center;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
        }
        .character-option.selected {
            background-color: rgba(76, 175, 80, 0.3);
        }
        .character-preview {
            width: 60px;
            height: 60px;
            margin-right: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
        }
        .character-info {
            flex-grow: 1;
            color: white;
        }
        .character-action {
            padding: 5px 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .character-action.disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        .mod-option {
            display: flex;
            align-items: center;
            margin: 15px 0;
        }
        .mod-option.enabled {
            background-color: rgba(76, 175, 80, 0.3);
        }
        .mod-info {
            flex-grow: 1;
            color: white;
        }
        .mod-action {
            padding: 8px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .mod-password {
            padding: 10px;
            margin: 10px 0;
            border: none;
            border-radius: 5px;
            width: 100%;
        }
        #closeSettingsButton {
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #333;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #touchArea {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 80%; /* Increased touch area height */
            z-index: 50;
            display: none;
        }
        #swipeInstructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 16px;
            text-align: center;
            z-index: 100;
            display: none;
        }
        /* Modal overlay for clicking outside to close */
        #modalOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 140;
            display: none;
        }
        /* Leaderboard styles */
        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            color: white;
        }
        .leaderboard-table th, 
        .leaderboard-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        .leaderboard-table th {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .leaderboard-table tr:nth-child(even) {
            background-color: rgba(255, 255, 255, 0.05);
        }
        .leaderboard-table tr:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .tab-buttons {
            display: flex;
            margin-bottom: 15px;
            width: 100%;
        }
        .tab-button {
            flex: 1;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .tab-button:first-child {
            border-top-left-radius: 5px;
            border-bottom-left-radius: 5px;
        }
        .tab-button:last-child {
            border-top-right-radius: 5px;
            border-bottom-right-radius: 5px;
        }
        .tab-button.active {
            background-color: rgba(76, 175, 80, 0.5);
        }
        .tab-content {
            display: none;
            width: 100%;
        }
        .tab-content.active {
            display: block;
        }

        /* Jukebox Styles */
.track-option {
    display: flex;
    align-items: center;
    padding: 12px;
    margin-bottom: 8px;
    background-color: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 2px solid transparent;
}

.track-option:hover {
    background-color: rgba(255, 255, 255, 0.1);
    transform: translateX(5px);
}

.track-option.selected {
    background-color: rgba(76, 175, 80, 0.2);
    border-color: rgba(76, 175, 80, 0.6);
    box-shadow: 0 0 15px rgba(76, 175, 80, 0.3);
}

.track-info {
    flex-grow: 1;
    color: white;
}

.track-name {
    font-size: 18px;
    font-weight: bold;
    margin-bottom: 4px;
}

.track-description {
    font-size: 14px;
    opacity: 0.8;
    font-style: italic;
}

.track-icon {
    font-size: 24px;
    margin-right: 15px;
    filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.3));
}

.track-status {
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: bold;
    text-transform: uppercase;
}

.track-playing {
    background: linear-gradient(45deg, #4CAF50, #8BC34A);
    color: white;
    animation: pulse-playing 1.5s infinite;
}

.track-selected {
    background: linear-gradient(45deg, #FF9800, #FFC107);
    color: white;
}

@keyframes pulse-playing {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.05); opacity: 0.8; }
    100% { transform: scale(1); opacity: 1; }
}

        #playerNameInput {
            padding: 10px;
            margin: 10px 0;
            width: 100%;
            border: none;
            border-radius: 5px;
            box-sizing: border-box;
            background-color: rgba(255, 255, 255, 0.8);
        }
        #saveScoreButton {
            padding: 10px 20px;
            margin-top: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

/* Audio control checkboxes */
.audio-checkbox {
    position: relative;
    display: inline-block;
    cursor: pointer;
    font-size: 18px;
    user-select: none;
}

/* Compact audio setting rows */
.audio-setting-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    max-width: 100%;
}

.audio-setting-row:last-child {
    border-bottom: none;
}

.audio-label {
    color: white;
    font-size: 16px;
    font-weight: normal;
    flex-grow: 1;
}

/* Adjust checkbox size for compact layout and keep it contained */
.audio-setting-row .audio-checkbox {
    margin-left: 10px;
    flex-shrink: 0;
}

.audio-setting-row .audio-checkbox .checkmark {
    height: 20px;
    width: 20px;
}

.audio-setting-row .audio-checkbox .checkmark:after {
    left: 6px;
    top: 2px;
    width: 5px;
    height: 10px;
}

.audio-setting-row .audio-checkbox .checkmark:after {
    left: 6px;
    top: 2px;
    width: 5px;
    height: 10px;
}

.audio-checkbox input {
    position: absolute;
    opacity: 0;
    cursor: pointer;
    height: 0;
    width: 0;
}

.checkmark {
    position: absolute;
    top: 0;
    left: 0;
    height: 25px;
    width: 25px;
    background-color: rgba(255, 255, 255, 0.2);
    border: 2px solid rgba(255, 255, 255, 0.5);
    border-radius: 5px;
    transition: all 0.3s ease;
}

.audio-checkbox:hover input ~ .checkmark {
    background-color: rgba(255, 255, 255, 0.3);
}

.audio-checkbox input:checked ~ .checkmark {
    background-color: #4CAF50;
    border-color: #4CAF50;
}

.checkmark:after {
    content: "";
    position: absolute;
    display: none;
}

.audio-checkbox input:checked ~ .checkmark:after {
    display: block;
}

.audio-checkbox .checkmark:after {
    left: 8px;
    top: 4px;
    width: 6px;
    height: 12px;
    border: solid white;
    border-width: 0 3px 3px 0;
    transform: rotate(45deg);
}

/* Power-up Status Bar */
#powerUpStatusBar {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 20px;
    z-index: 100;
    background: rgba(0, 0, 0, 0.5);
    padding: 10px 20px;
    border-radius: 25px;
    backdrop-filter: blur(10px);
}

.powerup-icon {
    position: relative;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.3);
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    transition: all 0.3s ease;
}

.powerup-icon.inactive {
    opacity: 0.3;
    transform: scale(0.9);
}

.powerup-icon.active {
    opacity: 1;
    transform: scale(1.1);
    box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
}

.powerup-symbol {
    font-size: 24px;
    z-index: 2;
    position: relative;
    filter: drop-shadow(0 0 5px rgba(0, 0, 0, 0.8));
}

.powerup-fill {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 0%;
    background: linear-gradient(to top, 
        rgba(76, 175, 80, 0.8) 0%,
        rgba(76, 175, 80, 0.6) 50%,
        rgba(76, 175, 80, 0.4) 100%
    );
    transition: height 0.1s ease-out;
    border-radius: 50%;
}

/* Specific colors for each power-up */
#shieldIcon .powerup-fill {
    background: linear-gradient(to top, 
        rgba(0, 170, 255, 0.8) 0%,
        rgba(0, 170, 255, 0.6) 50%,
        rgba(0, 170, 255, 0.4) 100%
    );
}

#shieldIcon.active {
    border-color: rgba(0, 170, 255, 0.8);
    box-shadow: 0 0 20px rgba(0, 170, 255, 0.6);
}

#multiplierIcon .powerup-fill {
    background: linear-gradient(to top, 
        rgba(255, 215, 0, 0.8) 0%,
        rgba(255, 215, 0, 0.6) 50%,
        rgba(255, 215, 0, 0.4) 100%
    );
}

#multiplierIcon.active {
    border-color: rgba(255, 215, 0, 0.8);
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
}

#magnetIcon .powerup-fill {
    background: linear-gradient(to top, 
        rgba(255, 100, 100, 0.8) 0%,
        rgba(100, 100, 255, 0.6) 50%,
        rgba(255, 100, 100, 0.4) 100%
    );
}

#magnetIcon.active {
    border-color: rgba(255, 100, 100, 0.8);
    box-shadow: 0 0 20px rgba(255, 100, 100, 0.6);
}

/* Character Ability Status */
.ability-icon {
    position: relative;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.3);
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    transition: all 0.3s ease;
}

.ability-icon.ready {
    opacity: 1;
    transform: scale(1.1);
    border-color: rgba(255, 69, 0, 0.8);
    box-shadow: 0 0 20px rgba(255, 69, 0, 0.6);
}

.ability-icon.cooldown {
    opacity: 0.3;
    transform: scale(0.9);
}

.ability-symbol {
    font-size: 24px;
    z-index: 2;
    position: relative;
    filter: drop-shadow(0 0 5px rgba(0, 0, 0, 0.8));
}

.ability-fill {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 0%;
    background: linear-gradient(to top, 
        rgba(255, 69, 0, 0.8) 0%,
        rgba(255, 140, 0, 0.6) 50%,
        rgba(255, 215, 0, 0.4) 100%
    );
    transition: height 0.1s ease-out;
    border-radius: 50%;
}

/* Ensure power-up bar stays horizontal */
#powerUpStatusBar {
    position: fixed !important;
    bottom: 20px !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    display: flex !important;
    flex-direction: row !important; /* Force horizontal layout */
    gap: 20px !important;
    z-index: 100 !important;
    background: rgba(0, 0, 0, 0.5);
    padding: 10px 20px;
    border-radius: 25px;
    backdrop-filter: blur(10px);
}

/* Mobile adjustments for power-up bar */
@media (max-width: 768px) {
    #powerUpStatusBar {
        bottom: 15px !important;
        gap: 15px !important;
        padding: 8px 15px !important;
    }
    
    .powerup-icon {
        width: 45px !important;
        height: 45px !important;
    }
    
    .powerup-symbol {
        font-size: 20px !important;
    }
}

/* Mobile Character Select Title */
@media (max-width: 768px) {
    #characterSelectScreen h2 {
        font-size: 28px !important;
        margin-bottom: 15px !important;
        padding: 0 20px !important;
        text-align: center !important;
    }
}

@media (max-width: 480px) {
    #characterSelectScreen h2 {
        font-size: 24px !important;
        margin-bottom: 10px !important;
    }
}

/* ==================== TITLE SCREEN PARTICLES ==================== */
/* Beautiful floating particle animation for the title screen */

.particle-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    pointer-events: none;
    z-index: 1;
}

.particle {
    position: absolute;
    border-radius: 50%;
    background: linear-gradient(45deg, #00a2ff, #0070f3);
    opacity: 0.6;
    animation: float-up 8s infinite linear;
    box-shadow: 0 0 20px rgba(0, 162, 255, 0.5);
}

.particle:nth-child(odd) {
    background: linear-gradient(45deg, #ff6b6b, #ff8e53);
    box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
    animation-duration: 12s;
}

.particle:nth-child(3n) {
    background: linear-gradient(45deg, #4ecdc4, #44a08d);
    box-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
    animation-duration: 10s;
}

.particle:nth-child(4n) {
    background: linear-gradient(45deg, #ffd93d, #ff8f00);
    box-shadow: 0 0 20px rgba(255, 217, 61, 0.5);
    animation-duration: 14s;
}

.particle:nth-child(5n) {
    background: linear-gradient(45deg, #a8edea, #fed6e3);
    box-shadow: 0 0 20px rgba(168, 237, 234, 0.5);
    animation-duration: 9s;
}

@keyframes float-up {
    0% {
        transform: translateY(100vh) scale(0);
        opacity: 0;
    }
    10% {
        opacity: 0.6;
    }
    90% {
        opacity: 0.6;
    }
    100% {
        transform: translateY(-100vh) scale(1);
        opacity: 0;
    }
}

/* Pulsing title enhancement */
.title-logo {
    animation: title-pulse 3s ease-in-out infinite;
    text-shadow: 0 0 30px rgba(0, 162, 255, 0.8);
}

@keyframes title-pulse {
    0%, 100% {
        transform: scale(1);
        text-shadow: 0 0 30px rgba(0, 162, 255, 0.8);
    }
    50% {
        transform: scale(1.05);
        text-shadow: 0 0 40px rgba(0, 162, 255, 1);
    }
}

/* Enhanced start button */
.start-button {
    transition: all 0.3s ease;
    box-shadow: 0 0 20px rgba(0, 162, 255, 0.3);
}

.start-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 10px 30px rgba(0, 162, 255, 0.5);
}

/* Hide character column on mobile to prevent horizontal scrolling */
@media (max-width: 768px) {
    #settings-leaderboard th:last-child,
    #settings-leaderboard td:last-child {
        display: none;
    }
}



    </style>
</head>
<body>

<div id="titleScreen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 300; background: linear-gradient(to bottom, #000428, #004e92); overflow: hidden;">
    <!-- Particle Animation Background -->
    <div class="particle-container" id="particleContainer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; pointer-events: none; z-index: 1;"></div>
    
    <!-- Title Canvas for 3D Character Orbits -->
    <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" id="titleCanvas"></div>
    
    <!-- Enhanced title with pulsing animation -->
    <h1 class="title-logo" style="color: white; font-size: 72px; margin-bottom: 20px; text-shadow: 0 0 10px #00a2ff, 0 0 20px #00a2ff; position: relative; z-index: 10; animation: title-pulse 3s ease-in-out infinite;">Dash Blitz</h1>
    

    <!-- Enhanced start button with hover effects -->
    <button id="titleStartButton" class="game-button start-button" style="font-size: 28px; padding: 15px 40px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; position: relative; z-index: 10; animation: pulse 1.5s infinite; transition: all 0.3s ease; box-shadow: 0 0 20px rgba(0, 162, 255, 0.3); width: 240px;">START</button>
    
<!-- Add this AFTER your START button -->
<div id="titleScreenAuth" style="text-align: center; margin: 20px 0; position: relative; z-index: 1000;">
    <!-- Google Sign-In Button (matches START button width) -->
    <button onclick="signInWithGoogle()" id="googleSignInBtn" 
        style="
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 12px auto;
            background: white;
            color: #757575;
            border: 1px solid #dadce0;
            border-radius: 8px;
            padding: 14px 20px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            min-width: 240px;
            width: 240px;
            position: relative;
            z-index: 1001;
        "
        onmouseover="this.style.boxShadow='0 4px 12px rgba(0,0,0,0.2)'; this.style.backgroundColor='#f8f9fa'; this.style.transform='translateY(-1px)';"
        onmouseout="this.style.boxShadow='0 2px 8px rgba(0,0,0,0.15)'; this.style.backgroundColor='white'; this.style.transform='translateY(0)';">
        
        <!-- Google Logo SVG (slightly larger) -->
        <svg width="20" height="20" viewBox="0 0 18 18" style="margin-right: 12px;">
            <path fill="#4285F4" d="M16.51 8H8.98v3h4.3c-.18 1-.74 1.48-1.6 2.04v2.01h2.6a7.8 7.8 0 0 0 2.38-5.88c0-.57-.05-.66-.15-1.18z"/>
            <path fill="#34A853" d="M8.98 17c2.16 0 3.97-.72 5.3-1.94l-2.6-2.04a4.8 4.8 0 0 1-7.18-2.53H1.83v2.07A8 8 0 0 0 8.98 17z"/>
            <path fill="#FBBC05" d="M4.5 10.49a4.8 4.8 0 0 1 0-3.07V5.35H1.83a8 8 0 0 0 0 7.28l2.67-2.14z"/>
            <path fill="#EA4335" d="M8.98 3.58c1.32 0 2.5.45 3.44 1.35l2.54-2.59a7.81 7.81 0 0 0-5.98-2.26 8 8 0 0 0-7.15 4.42l2.67 2.14c.63-1.89 2.39-3.06 4.48-3.06z"/>
        </svg>
        
        Sign in with Google
    </button>
    
            <!-- Subtle subtitle -->
        <p style="
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            margin: 8px 0 0 0;
            font-style: italic;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            font-weight: 300;
        ">
            (for cloud saves across devices!)
</p>
</div>

    <style>
        /* Keep your existing pulse animation */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        /* Enhanced title pulse animation */
        @keyframes title-pulse {
            0%, 100% {
                transform: scale(1);
                text-shadow: 0 0 10px #00a2ff, 0 0 20px #00a2ff;
            }
            50% {
                transform: scale(1.02);
                text-shadow: 0 0 15px #00a2ff, 0 0 30px #00a2ff, 0 0 40px #00a2ff;
            }
        }
        
        /* Particle styles */
        .particle {
            position: absolute;
            border-radius: 50%;
            background: linear-gradient(45deg, #00a2ff, #0070f3);
            opacity: 0.6;
            animation: float-up 8s infinite linear;
            box-shadow: 0 0 20px rgba(0, 162, 255, 0.5);
        }

        .particle:nth-child(odd) {
            background: linear-gradient(45deg, #ff6b6b, #ff8e53);
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
            animation-duration: 12s;
        }

        .particle:nth-child(3n) {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.5);
            animation-duration: 10s;
        }

        .particle:nth-child(4n) {
            background: linear-gradient(45deg, #ffd93d, #ff8f00);
            box-shadow: 0 0 20px rgba(255, 217, 61, 0.5);
            animation-duration: 14s;
        }

        .particle:nth-child(5n) {
            background: linear-gradient(45deg, #a8edea, #fed6e3);
            box-shadow: 0 0 20px rgba(168, 237, 234, 0.5);
            animation-duration: 9s;
        }

        @keyframes float-up {
            0% {
                transform: translateY(100vh) scale(0);
                opacity: 0;
            }
            10% {
                opacity: 0.6;
            }
            90% {
                opacity: 0.6;
            }
            100% {
                transform: translateY(-100vh) scale(1);
                opacity: 0;
            }
        }

        /* Enhanced start button hover */
        .start-button:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 10px 30px rgba(76, 175, 80, 0.5);
            background-color: #45a049;
        }

        /* Mobile World Select Optimizations */
@media (max-width: 768px) {
    #worldSelectTitle {
        font-size: 32px !important;
        margin-bottom: 15px !important;
    }
    
    #worldNavigation {
        flex-direction: column !important;
        align-items: center !important;
        gap: 15px !important;
    }
    
    #worldNavigation button {
        font-size: 20px !important;
        padding: 8px 16px !important;
        margin: 0 10px !important;
    }
    
    #worldDisplay {
        width: 85vw !important;
        max-width: 350px !important;
        height: 180px !important;
        margin: 0 !important;
    }
    
    #worldName {
        font-size: 24px !important;
        margin-bottom: 8px !important;
    }
    
    #worldDescription {
        font-size: 16px !important;
        padding: 0 15px !important;
    }
    
    #worldUnlockStatus {
        font-size: 14px !important;
    }
    
    #startGameFromWorldButton {
        font-size: 24px !important;
        padding: 12px 30px !important;
        margin-top: 10px !important;
    }
}

@media (max-width: 480px) {
    #worldSelectTitle {
        font-size: 28px !important;
    }
    
    #worldDisplay {
        width: 90vw !important;
        height: 160px !important;
    }
    
    #worldName {
        font-size: 20px !important;
    }
    
    #worldDescription {
        font-size: 14px !important;
    }
    
    #startGameFromWorldButton {
        font-size: 20px !important;
        padding: 10px 25px !important;
    }
}
    </style>
</div>

<!-- Main Menu Screen -->
<div id="mainMenuScreen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 300; background: linear-gradient(to bottom, #000428, #004e92); overflow: hidden;">
    <!-- Background particles (reuse same container) -->
    <div class="particle-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; pointer-events: none; z-index: 1;"></div>
    
    <!-- Main Menu Title -->
    <h1 style="color: white; font-size: 56px; margin-bottom: 40px; text-shadow: 0 0 10px #00a2ff, 0 0 20px #00a2ff; position: relative; z-index: 10; text-align: center;">Main Menu</h1>
    
    <!-- Menu Options -->
    <div style="display: flex; flex-direction: column; gap: 20px; position: relative; z-index: 10; width: 300px;">
        <button id="runButton" class="game-button" style="font-size: 24px; padding: 15px 30px; background-color: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.3s ease;">
            üèÉ RUN
        </button>
        
        <button id="charactersButton" class="game-button" style="font-size: 24px; padding: 15px 30px; background-color: #2196F3; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.3s ease;">
            üë§ CHARACTERS
        </button>
        
        <button id="shopButton" class="game-button" style="font-size: 24px; padding: 15px 30px; background-color: #FF9800; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.3s ease;">
            üõí SHOP
        </button>
        
        <button id="mainMenuSettingsButton" class="game-button" style="font-size: 24px; padding: 15px 30px; background-color: #9C27B0; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.3s ease;">
            ‚öôÔ∏è SETTINGS
        </button>
        
        <button id="profileButton" class="game-button" style="font-size: 24px; padding: 15px 30px; background-color: #607D8B; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.3s ease;">
            üìä PROFILE
        </button>
    </div>
</div>

<!--------- BUTTONS & UI SECTION--------->
<!--==============================-->
<!--==============================-->





<!-- Main Menu Settings Screen -->
<div id="mainMenuSettingsScreen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; z-index: 400; background: linear-gradient(to bottom, #000428, #004e92); overflow: hidden;">
    
    <!-- Settings Container - Centered with max width -->
    <div style="max-width: 800px; width: 100%; margin: 0 auto; display: flex; flex-direction: column; height: 100%;">
    
        <!-- Settings Header -->
        <div style="padding: 15px 20px; text-align: center; position: relative; flex-shrink: 0;">
        <!-- Back Button -->
        <button id="backToMainMenuFromSettings" style="position: absolute; top: 15px; left: 15px; background: #666; color: white; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 14px;">‚Üê Back</button>
        
        <!-- Settings Title -->
        <h2 style="color: white; margin: 0; text-shadow: 0 2px 4px rgba(0,0,0,0.5); font-size: 24px;">‚öôÔ∏è Settings</h2>
    </div>
    
    <!-- Settings Tabs -->
    <div style="display: flex; justify-content: center; margin: 0 20px 15px 20px; flex-shrink: 0;">
        <button class="settings-tab active" data-tab="general" style="background: #2196F3; color: white; border: none; padding: 10px 15px; border-radius: 8px 0 0 8px; cursor: pointer; font-size: 13px; border-right: 1px solid #fff; flex: 1; max-width: 120px;">üîä General</button>
        <button class="settings-tab" data-tab="leaderboard" style="background: #666; color: white; border: none; padding: 10px 15px; cursor: pointer; font-size: 13px; border-right: 1px solid #fff; flex: 1; max-width: 120px;">üèÜ Global</button>
        <button class="settings-tab" data-tab="mods" style="background: #666; color: white; border: none; padding: 10px 15px; border-radius: 0 8px 8px 0; cursor: pointer; font-size: 13px; border-left: 1px solid #fff; flex: 1; max-width: 120px;">üîß Mods</button>
    </div>
    
        <!-- Settings Content Area -->
        <div style="flex: 1; overflow-y: auto; padding: 0 20px 20px 20px;">
        
        <!-- General Tab Content -->
        <div id="settings-general" class="settings-tab-content active">
            
            <!-- Audio Settings Section -->
            <div style="margin-bottom: 20px; padding: 15px; background: rgba(255, 255, 255, 0.05); border-radius: 12px; border: 1px solid rgba(255, 255, 255, 0.1);">
                <h3 style="color: white; margin: 0 0 15px 0; font-size: 18px;">üîä Audio Settings</h3>
                
                <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                    <input type="checkbox" id="mainMenuMusicCheckbox" style="margin-right: 12px; transform: scale(1.2);">
                    <span style="font-size: 16px; color: white;">üéµ Background Music</span>
                </label>
                
                <label style="display: flex; align-items: center; margin: 10px 0; cursor: pointer;">
                    <input type="checkbox" id="mainMenuSoundCheckbox" style="margin-right: 12px; transform: scale(1.2);">
                    <span style="font-size: 16px; color: white;">üîä Sound Effects</span>
                </label>
            </div>
            
            <!-- Save System Section -->
            <div style="margin-bottom: 20px; padding: 15px; background: rgba(255, 255, 255, 0.05); border-radius: 12px; border: 1px solid rgba(255, 255, 255, 0.1);">
                <h3 style="color: white; margin: 0 0 15px 0; font-size: 18px;">üíæ Save System</h3>
                
                <div id="authStatusDisplay" style="margin-bottom: 15px; text-align: center; font-size: 14px;">
                    <!-- Will be populated by JavaScript -->
                </div>
                
                <div style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: center;">
                    <button id="generateSaveCodeBtn" style="background: #34C759; color: white; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; flex: 1; min-width: 90px;">üì± Get Code</button>
                    <button id="restoreSaveCodeBtn" style="background: #FF9500; color: white; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; flex: 1; min-width: 90px;">üì• Use Code</button>
                    <button id="googleAuthBtn" style="background: #4285f4; color: white; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; flex: 1; min-width: 90px;">üîó Google</button>
                </div>
            </div>
            
        </div>

        <!-- Global Leaderboard Tab Content -->
        <div id="settings-leaderboard" class="settings-tab-content" style="display: none;">
            
            <!-- Global Leaderboard Section -->
            <div style="margin-bottom: 20px; padding: 15px; background: rgba(255, 255, 255, 0.05); border-radius: 12px; border: 1px solid rgba(255, 255, 255, 0.1);">
                <h3 style="color: white; margin: 0 0 15px 0; font-size: 18px; text-align: center;">üåç Global Leaderboard</h3>
                
                <!-- Player's Global Rank Display -->
                <div id="settingsPlayerRank" style="text-align: center; margin-bottom: 15px; padding: 12px; background: rgba(255, 215, 0, 0.1); border-radius: 8px; border: 1px solid rgba(255, 215, 0, 0.3);">
                    <p style="color: #FFD700; margin: 0; font-size: 14px;" id="settingsGlobalRankText">üèÜ Loading your rank...</p>
                </div>
                
                <!-- Global Leaderboard Table -->
                <div style="max-height: 300px; overflow-y: auto; border-radius: 8px; background: rgba(0, 0, 0, 0.2);">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead style="background: rgba(0, 20, 40, 0.95); backdrop-filter: blur(10px); position: sticky; top: 0; z-index: 10; border-bottom: 2px solid rgba(255, 255, 255, 0.3);">
                            <tr>
                                <th style="padding: 10px 8px; text-align: left; color: white; font-size: 14px; border-bottom: 1px solid rgba(255, 255, 255, 0.2);">Rank</th>
                                <th style="padding: 10px 8px; text-align: left; color: white; font-size: 14px; border-bottom: 1px solid rgba(255, 255, 255, 0.2);">Player</th>
                                <th style="padding: 10px 8px; text-align: right; color: white; font-size: 14px; border-bottom: 1px solid rgba(255, 255, 255, 0.2);">Score</th>
                                <th style="padding: 10px 8px; text-align: center; color: white; font-size: 14px; border-bottom: 1px solid rgba(255, 255, 255, 0.2);">Character</th>
                            </tr>
                        </thead>
                        <tbody id="settingsGlobalLeaderboardBody">
                            <!-- Will be populated by JavaScript -->
                        </tbody>
                    </table>
                </div>
                
                <!-- Refresh Button -->
                <div style="text-align: center; margin-top: 15px;">
                    <button onclick="refreshSettingsGlobalLeaderboard()" style="background: #4CAF50; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 14px; transition: background 0.2s ease;" onmouseover="this.style.background='#45a049'" onmouseout="this.style.background='#4CAF50'">
                        üîÑ Refresh Leaderboard
                    </button>
                </div>
            </div>
            
        </div>
        
        <!-- Mod Options Tab Content -->
        <div id="settings-mods" class="settings-tab-content" style="display: none;">
            
            <!-- Mod Options Section -->
            <div style="margin-bottom: 20px; padding: 15px; background: rgba(255, 255, 255, 0.05); border-radius: 12px; border: 1px solid rgba(255, 255, 255, 0.1);">
                <h3 style="color: white; margin: 0 0 15px 0; font-size: 18px;">üîß Mod Options</h3>
                
                <div style="margin: 15px 0;">
                    <h4 style="color: white; margin: 0 0 8px 0; font-size: 16px;">Mod Mode</h4>
                    <p style="color: #ccc; margin: 0 0 10px 0; font-size: 14px;">Unlock all content temporarily</p>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <input type="password" id="mainMenuModPassword" placeholder="Enter password" style="padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; flex: 1;">
                        <button id="mainMenuModModeBtn" style="background: #9C27B0; color: white; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 14px;">Enable</button>
                    </div>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4 style="color: white; margin: 0 0 8px 0; font-size: 16px;">Reset Game Data</h4>
                    <p style="color: #ccc; margin: 0 0 10px 0; font-size: 14px;">Clear all saved progress</p>
                    <button id="mainMenuResetDataBtn" style="background: #F44336; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; width: 100%;">üóëÔ∏è Reset All Data</button>
                </div>
            </div>
            
        </div>
        
        </div> <!-- End settings content area -->
    </div> <!-- End centered container -->
</div> <!-- End settings screen -->

<!-- Shop Screen -->
<div id="shopScreen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; z-index: 400; background: linear-gradient(to bottom, #000428, #004e92); overflow: hidden;">
    
    <!-- Shop Container - Centered with max width -->
    <div style="max-width: 1000px; width: 100%; margin: 0 auto; display: flex; flex-direction: column; height: 100%;">
    
        <!-- Shop Header -->
        <div style="padding: 20px; text-align: center; position: relative; flex-shrink: 0;">
        <!-- Back Button -->
        <button id="backToMainMenuFromShop" style="position: absolute; top: 20px; left: 20px; background: #666; color: white; border: none; padding: 10px 15px; border-radius: 6px; cursor: pointer; font-size: 16px;">‚Üê Back</button>
        
        <!-- Shop Title -->
        <h2 style="color: white; margin: 0; text-shadow: 0 2px 4px rgba(0,0,0,0.5); font-size: 28px;">üõí Shop</h2>
        
        <!-- Current Coins Display -->
        <div style="margin-top: 15px; padding: 10px 20px; background: rgba(255, 215, 0, 0.1); border-radius: 10px; border: 1px solid rgba(255, 215, 0, 0.3); display: inline-block;">
            <span style="color: #FFD700; font-size: 20px; font-weight: bold;">üí∞ <span id="shopCoinsDisplay">0</span> Coins</span>
        </div>
    </div>
    
    <!-- Shop Tabs -->
    <div style="display: flex; justify-content: center; margin: 0 20px 20px 20px;">
        <button class="shop-tab active" data-tab="characters" style="background: #2196F3; color: white; border: none; padding: 12px 24px; border-radius: 8px 0 0 8px; cursor: pointer; font-size: 16px; border-right: 1px solid #fff;">üë§ Characters</button>
        <button class="shop-tab" data-tab="worlds" style="background: #666; color: white; border: none; padding: 12px 24px; cursor: pointer; font-size: 16px;">üåç Worlds</button>
        <button class="shop-tab" data-tab="drip" style="background: #666; color: white; border: none; padding: 12px 24px; border-radius: 0 8px 8px 0; cursor: pointer; font-size: 16px; border-left: 1px solid #fff;">üéÅ DRiP</button>
    </div>
    
        <!-- Shop Content Area -->
        <div style="flex: 1; overflow-y: auto; padding: 0 20px 20px 20px;">
        
        <!-- Characters Tab Content -->
        <div id="shop-characters" class="shop-tab-content active" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px; max-height: 100%;">
            <!-- Will be populated by JavaScript -->
        </div>
        
        <!-- Worlds Tab Content -->
        <div id="shop-worlds" class="shop-tab-content" style="display: none; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px; max-height: 100%;">
            <!-- Will be populated by JavaScript -->
        </div>
        
        <!-- DRiP Tab Content -->
        <div id="shop-drip" class="shop-tab-content" style="display: none; padding: 20px; overflow-y: auto;">
            
            <!-- DRiP Rewards Section -->
            <div style="background: rgba(255, 255, 255, 0.05); border-radius: 15px; padding: 20px; margin: 0 auto 20px auto; text-align: center; max-width: 600px;">
                <h3 style="color: white; margin: 0 0 15px 0; font-size: 20px;">üéÅ DRiP Rewards</h3>
                <p style="color: #ccc; margin: 0 0 15px 0; line-height: 1.4; font-size: 14px;">Exclusive unlockables coming soon! Connect your wallet to verify CNFTs and unlock rare characters, worlds, and special items.</p>
                <div style="background: rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 12px;">
                    <p style="color: #FFD700; margin: 0; font-weight: bold; font-size: 14px;">üöÄ Coming Soon!</p>
                </div>
            </div>
            
            <!-- Support Creator Section -->
            <div style="background: rgba(255, 255, 255, 0.05); border-radius: 15px; padding: 20px; text-align: center; max-width: 600px; margin: 0 auto;">
                <h3 style="color: white; margin: 0 0 15px 0; font-size: 20px;">üíß Support the Creator</h3>
                <p style="color: #ccc; margin: 0 0 15px 0; line-height: 1.4; font-size: 14px;">Thank me on DRiP.haus and discover more of my creations!</p>
                
                <!-- DRiP Preview Container - Optimized for your image -->
                <div id="dripPreviewContainer" style="
                    width: 100%; 
                    max-width: 400px;
                    margin: 0 auto;
                    aspect-ratio: 1;
                    border-radius: 15px; 
                    overflow: hidden; 
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    background: #1a1a1a;
                    position: relative;
                    cursor: pointer;
                    transition: transform 0.2s ease;
                " onclick="window.open('https://drip.haus/alangnft/home', '_blank')" 
                onmouseover="this.style.transform='scale(1.02)'" 
                onmouseout="this.style.transform='scale(1)'">
                    
                    <!-- Screenshot Preview -->
                    <img id="dripScreenshot" src="assets/images/DRiPscreenshot.png" 
                    alt="DRiP Channel Preview" 
                    style="
                        width: 100%; 
                        height: 100%; 
                        object-fit: cover;
                        border-radius: 10px;
                    " 
                    onerror="this.style.display='none'; document.getElementById('dripPreviewFallback').style.display='flex';">
                    
                    <!-- Fallback content if image fails -->
                    <div id="dripPreviewFallback" style="
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: linear-gradient(135deg, #9C27B0, #7B1FA2);
                        display: none;
                        flex-direction: column;
                        justify-content: center;
                        align-items: center;
                        color: white;
                        text-align: center;
                        padding: 20px;
                        box-sizing: border-box;
                    ">
                        <div style="font-size: 48px; margin-bottom: 15px;">üè¥‚Äç‚ò†Ô∏è</div>
                        <div style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">DRiPlanet</div>
                        <div style="font-size: 16px; margin-bottom: 5px;">@alangNFT</div>
                        <div style="font-size: 14px; opacity: 0.8;">Click to visit profile</div>
                    </div>
                    
                    <!-- Click overlay effect -->
                    <div style="
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(255, 255, 255, 0.1);
                        opacity: 0;
                        transition: opacity 0.2s ease;
                        border-radius: 10px;
                        pointer-events: none;
                    " id="dripClickOverlay"></div>
                    
                </div>
                
                <!-- Direct link fallback -->
                <div style="margin-top: 15px;">
                    <a href="https://drip.haus/alangnft/home" target="_blank" style="
                        display: inline-block;
                        background: linear-gradient(135deg, #47C6D5, #207079);
                        color: white;
                        text-decoration: none;
                        padding: 10px 20px;
                        border-radius: 8px;
                        font-size: 14px;
                        font-weight: bold;
                        transition: transform 0.2s ease;
                    " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        üîó Visit My DRiP Profile
                    </a>
                </div>
            </div>
            
        </div>
        
        </div> <!-- End shop content area -->
    </div> <!-- End centered container -->
</div> <!-- End shop screen -->

<!-- Profile Screen -->
<div id="profileScreen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; z-index: 400; background: linear-gradient(to bottom, #000428, #004e92); overflow: hidden;">
    
    <!-- Profile Header -->
    <div style="padding: 15px 20px; text-align: center; position: relative; flex-shrink: 0;">
        <!-- Back Button -->
        <button id="backToMainMenuFromProfile" style="position: absolute; top: 15px; left: 15px; background: #666; color: white; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 14px;">‚Üê Back</button>
        
        <!-- Profile Title -->
        <h2 style="color: white; margin: 0; text-shadow: 0 2px 4px rgba(0,0,0,0.5); font-size: 24px;">üìä Profile</h2>
    </div>
    
    <!-- Profile Content -->
    <div style="flex: 1; overflow-y: auto; padding: 0 20px 20px 20px; display: flex; flex-direction: column; align-items: center;">
        
<!-- Profile Info -->
        <div style="text-align: center; margin-bottom: 20px;">
            <!-- Avatar with upload functionality -->
            <div style="position: relative; display: inline-block; margin-bottom: 12px;">
                <div id="profileAvatar" style="width: 80px; height: 80px; background: linear-gradient(45deg, #4CAF50, #2196F3); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 36px; cursor: pointer; transition: transform 0.2s ease; overflow: hidden; border: 3px solid rgba(255, 255, 255, 0.2);" onclick="triggerAvatarUpload()">
                    <span id="avatarEmoji">üèÉ</span>
                    <img id="avatarImage" style="width: 100%; height: 100%; object-fit: cover; display: none;" alt="Profile Avatar">
                </div>
                <!-- Upload overlay -->
                <div style="position: absolute; bottom: -5px; right: -5px; width: 24px; height: 24px; background: #4CAF50; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; cursor: pointer; border: 2px solid white;" onclick="triggerAvatarUpload()">
                    üì∑
                </div>
                <!-- Hidden file input -->
                <input type="file" id="avatarUpload" accept="image/*" style="display: none;" onchange="handleAvatarUpload(event)">
            </div>
            
            <!-- Username with edit functionality -->
            <div style="margin-bottom: 5px;">
                <h3 id="profilePlayerName" style="color: white; margin: 0; font-size: 20px; cursor: pointer; padding: 5px 10px; border-radius: 8px; transition: background 0.2s ease; display: inline-block;" onclick="editUsername()">Anonymous Runner</h3>
                <button style="background: none; border: none; color: #00a2ff; font-size: 14px; cursor: pointer; margin-left: 8px;" onclick="editUsername()">‚úèÔ∏è</button>
            </div>
            <p style="color: #ccc; margin: 0; font-size: 14px;">Dash Blitz Player</p>
            
            <!-- Username edit modal (hidden by default) -->
            <div id="usernameEditModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 6000; justify-content: center; align-items: center;">
                <div style="background: rgba(0, 20, 40, 0.95); padding: 25px; border-radius: 15px; max-width: 400px; width: 90%; text-align: center; border: 1px solid rgba(255, 255, 255, 0.2);">
                    <h3 style="color: white; margin: 0 0 15px 0;">Edit Username</h3>
                    <input type="text" id="usernameInput" placeholder="Enter username" maxlength="20" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #ccc; font-size: 16px; margin-bottom: 15px; box-sizing: border-box;">
                    <div style="color: #ccc; font-size: 12px; margin-bottom: 15px;">Username will appear on leaderboards</div>
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <button onclick="saveUsername()" style="background: #4CAF50; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer;">Save</button>
                        <button onclick="closeUsernameModal()" style="background: #666; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer;">Cancel</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Stats Grid -->
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 20px; width: 100%; max-width: 300px;">
            <div style="background: rgba(255, 255, 255, 0.05); padding: 12px; border-radius: 8px; text-align: center;">
                <div style="font-size: 20px; color: #FFD700; font-weight: bold;" id="profileHighScore">0</div>
                <div style="color: #ccc; font-size: 12px;">High Score</div>
            </div>
            <div style="background: rgba(255, 255, 255, 0.05); padding: 12px; border-radius: 8px; text-align: center;">
                <div style="font-size: 20px; color: #4CAF50; font-weight: bold;" id="profileTotalCoins">0</div>
                <div style="color: #ccc; font-size: 12px;">Total Coins</div>
            </div>
            <div style="background: rgba(255, 255, 255, 0.05); padding: 12px; border-radius: 8px; text-align: center;">
                <div style="font-size: 20px; color: #2196F3; font-weight: bold;" id="profileCharactersUnlocked">1</div>
                <div style="color: #ccc; font-size: 12px;">Characters</div>
            </div>
            <div style="background: rgba(255, 255, 255, 0.05); padding: 12px; border-radius: 8px; text-align: center;">
                <div style="font-size: 20px; color: #FF9800; font-weight: bold;" id="profileWorldsUnlocked">1</div>
                <div style="color: #ccc; font-size: 12px;">Worlds</div>
            </div>
        </div>
        
        <!-- Coming Soon Features -->
        <div style="width: 100%; max-width: 350px; padding: 15px; background: rgba(255, 255, 255, 0.05); border-radius: 12px; border: 1px solid rgba(255, 255, 255, 0.1);">
            <h3 style="color: white; margin: 0 0 12px 0; font-size: 16px; text-align: center;">üöÄ Coming Soon</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; color: #ccc; font-size: 14px;">
                <div>üèÜ Achievements</div>
                <div>üìà Statistics</div>
                <div>üé® Customization</div>
                <div>üë• Friends</div>
                <div>üéØ Challenges</div>
                <div>üåü Rankings</div>
            </div>
        </div>
        
    </div>
</div>

<div id="characterSelectScreen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 300; background: linear-gradient(to bottom, #000428, #004e92);">
    <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" id="characterSelectCanvas"></div>
    <h2 style="color: white; font-size: 48px; margin-bottom: 20px; text-shadow: 0 0 10px #00a2ff, 0 0 20px #00a2ff; position: relative; z-index: 10; text-align: center;">Select Your Character</h2>
    <div style="display: flex; align-items: center; margin-bottom: 30px; position: relative; z-index: 10;">
        <button id="prevCharacterBtn" class="game-button" style="font-size: 24px; padding: 10px 20px; margin-right: 20px;">‚Üê</button>
<div id="characterDisplay" style="width: 180px; height: 180px;"></div>
        <button id="nextCharacterBtn" class="game-button" style="font-size: 24px; padding: 10px 20px; margin-left: 20px;">‚Üí</button>
    </div>
    <div id="characterInfo" style="color: white; text-align: center; margin-bottom: 20px; position: relative; z-index: 10;">
        <h3 id="characterName" style="font-size: 32px; margin-bottom: 10px;">Apple</h3>
        <p id="characterDescription" style="font-size: 18px;">Classic runner</p>
        <p id="characterUnlockStatus" style="font-size: 16px; color: #4CAF50;">Unlocked</p>
    </div>
<div style="display: flex; gap: 15px; position: relative; z-index: 10; justify-content: center; width: 100%; max-width: 400px; margin: 0 auto;">
        <button id="backToMainMenuFromCharacters" class="game-button" style="font-size: 18px; padding: 10px 20px; background-color: #666; color: white; border: none; border-radius: 5px; cursor: pointer; flex: 1; max-width: 120px;">‚Üê BACK</button>
        <button id="selectCharacterButton" class="game-button" style="font-size: 20px; padding: 12px 25px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; animation: pulse 1.5s infinite; flex: 2; max-width: 200px;">SELECT</button>
    </div>
</div>
<!-- World Select Screen -->
<div id="worldSelectScreen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 300; background: linear-gradient(to bottom, #000428, #004e92); padding: 20px; box-sizing: border-box;">
    <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" id="worldSelectCanvas"></div>
    <h2 id="worldSelectTitle" style="color: white; font-size: 48px; margin-bottom: 20px; text-shadow: 0 0 10px #00a2ff, 0 0 20px #00a2ff; position: relative; z-index: 10; text-align: center;">Select Your World</h2>
    <div id="worldNavigation" style="display: flex; align-items: center; margin-bottom: 30px; position: relative; z-index: 10; width: 100%; max-width: 500px; justify-content: center;">
        <button id="prevWorldBtn" class="game-button" style="font-size: 24px; padding: 10px 20px; margin-right: 20px; flex-shrink: 0;">‚Üê</button>
        <div id="worldDisplay" style="width: 300px; height: 200px; max-width: calc(100vw - 140px); background-color: rgba(0, 0, 0, 0.3); border-radius: 15px; display: flex; justify-content: center; align-items: center; box-shadow: 0 0 20px rgba(0, 162, 255, 0.5); position: relative; overflow: hidden;">
            <div id="worldPreview" style="width: 100%; height: 100%; border-radius: 15px;"></div>
        </div>
        <button id="nextWorldBtn" class="game-button" style="font-size: 24px; padding: 10px 20px; margin-left: 20px; flex-shrink: 0;">‚Üí</button>
    </div>
    <div id="worldInfo" style="color: white; text-align: center; margin-bottom: 20px; position: relative; z-index: 10; width: 100%; max-width: 400px;">
        <h3 id="worldName" style="font-size: 32px; margin-bottom: 10px; word-wrap: break-word;">Classic Plains</h3>
        <p id="worldDescription" style="font-size: 18px; word-wrap: break-word; padding: 0 10px;">Rolling green hills and peaceful meadows</p>
        <p id="worldUnlockStatus" style="font-size: 16px; color: #4CAF50;">Unlocked</p>
    </div>
    <div style="display: flex; gap: 20px; position: relative; z-index: 10; flex-wrap: wrap; justify-content: center;">
        <button id="backToMainMenuFromWorld" class="game-button" style="font-size: 24px; padding: 12px 25px; background-color: #666; color: white; border: none; border-radius: 5px; cursor: pointer;">‚Üê BACK</button>
        <button id="startGameFromWorldButton" class="game-button" style="font-size: 32px; padding: 15px 50px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; animation: pulse 1.5s infinite; max-width: calc(100vw - 120px); word-wrap: break-word;">START ADVENTURE!</button>
    </div>
</div>

<!-- Game Over Screen -->
<div id="score">Score: 0</div>
    <div id="totalCoins">Coins: 0</div>
    <button id="pauseBtn">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <rect x="6" y="4" width="4" height="16" rx="1"/>
            <rect x="14" y="4" width="4" height="16" rx="1"/>
        </svg>
    </button>
    <button id="skipBtn">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <polygon points="5,4 15,12 5,20"/>
            <rect x="17" y="4" width="2" height="16"/>
        </svg>
    </button>
    <div id="speedIndicator">Speed: 1x</div>
    <div id="gameOver">
    <h2 style="margin-top: 0;">Game Over</h2>
    <span id="finalScore" style="font-size: 24px;"></span><br>
    <span id="coinsCollected" style="font-size: 20px; margin-bottom: 15px; display: inline-block;"></span><br>
    <div class="game-buttons" style="display: flex; flex-direction: column; gap: 10px; width: 100%; max-width: 250px; margin: 0 auto;">
        <button id="restartButton" class="game-button">Restart</button>
        <button id="gameOverMainMenuBtn" class="game-button">Main Menu</button>
        <button id="gameOverSettingsBtn" class="game-button">Settings</button>
    </div>
</div>
    <div id="startScreen">
        <h1>3D Endless Runner</h1>
        <p style="color: white; margin-bottom: 20px;">
            Use ‚Üê ‚Üí to move and ‚Üë or SPACE to jump. Press ‚Üì to drop quickly!<br>
            Press P to pause the game. Jump over streams and avoid obstacles.<br>
            <span id="mobileInstructions" style="display: none;">On mobile, swipe left/right to move, swipe up to jump, and swipe down to drop quickly.</span>
        </p>
        <button id="startButton">Start Game</button>
    </div>

    <!-- Pause Screen -->
    <div id="pauseScreen">
    <h2>Paused</h2>
    <p>Press P or tap to resume</p>
    <div class="game-buttons" style="display: flex; flex-direction: column; gap: 10px; width: 100%; max-width: 250px; margin: 0 auto;">
        <button id="resumeButton" class="game-button">Resume Game</button>
        <button id="pauseRestartButton" class="game-button">Restart</button>
        <button id="pauseMainMenuBtn" class="game-button">Main Menu</button>
        <button id="pauseSettingsBtn" class="game-button">Settings</button>
    </div>
</div>

    <!-- Settings Menu Tabs -->
    <div id="modalOverlay"></div>
<div id="settingsScreen">
    <h2>Settings</h2>
    
    <div class="tab-buttons">
        <button class="tab-button active" data-tab="settings-tab">‚öôÔ∏è Game Settings</button>
        <button class="tab-button" data-tab="leaderboard-tab">üèÜ Leaderboard</button>
        <button class="tab-button" data-tab="global-leaderboard-tab">üåç Global</button>
    </div>
        
        <div id="settings-tab" class="tab-content active">
    <div class="settings-section">
    <h3>Audio Settings</h3>
    <div class="audio-setting-row">
        <span class="audio-label">Sound Effects</span>
        <label class="audio-checkbox">
            <input type="checkbox" id="soundEffectsCheckbox" checked>
            <span class="checkmark"></span>
        </label>
    </div>
    <div class="audio-setting-row">
        <span class="audio-label">Background Music</span>
        <label class="audio-checkbox">
            <input type="checkbox" id="backgroundMusicCheckbox" checked>
            <span class="checkmark"></span>
        </label>
    </div>
</div>

<div class="settings-section">
    <h3>üéµ Jukebox</h3>
    <p style="color: white; font-size: 14px; margin-bottom: 15px; opacity: 0.8;">Choose your soundtrack for the ultimate running experience!</p>
    
    <!-- Shuffle Mode Toggle -->
    <div style="margin-bottom: 15px;">
        <button id="shuffleToggleBtn" class="game-button" style="padding: 8px 16px; font-size: 16px; width: 100%;">üîÄ Shuffle: OFF</button>
    </div>
    
    <!-- Track Selection (only shown when shuffle is off) -->
    <div id="manualTrackSelection">
        <label for="trackSelector" style="color: white; font-size: 14px; display: block; margin-bottom: 8px;">Select Track:</label>
        <select id="trackSelector" class="game-button" style="width: 100%; padding: 10px; font-size: 16px; margin-bottom: 15px;">
            <!-- Options will be populated by JavaScript -->
        </select>
        <button id="applyTrackBtn" class="game-button" style="padding: 8px 16px; font-size: 16px; width: 100%;">‚úÖ Apply Track</button>
    </div>
</div>
    
    <div class="settings-section">
        <h3>Mod Options</h3>
        <div class="mod-option" id="mod-mode-option">
            <div class="mod-info">
                <h4>Mod Mode</h4>
                <p>Unlock all content</p>
            <input type="password" class="mod-password" id="modPassword" placeholder="Enter password">
        </div>
        <button class="mod-action" id="modModeButton">Enable</button>
    </div>
    <div class="mod-option" id="difficulty-override-option" style="display: none;">
        <div class="mod-info">
            <h4>Force Difficulty Level</h4>
            <p>Override speed level for testing</p>
            <select id="difficultyOverride" style="padding: 5px; margin: 5px 0; border-radius: 3px; border: none;">
                <option value="-1">Normal (Time-Based)</option>
                <option value="0">Level 1 - Cruise</option>
                <option value="1">Level 2 - Accelerating</option>
                <option value="2">Level 3 - Intense</option>
                <option value="3">Level 4 - Blazing</option>
                <option value="4">Level 5 - Maximum Chaos</option>
            </select>
        </div>
        <button class="mod-action" id="applyDifficultyButton">Apply</button>
    </div>
    <div class="mod-option" id="reset-data-option">
        <div class="mod-info">
            <h4>Reset Game Data</h4>
            <p>Clear all saved progress</p>
        </div>
        <button class="mod-action" id="resetDataButton">Reset</button>
    </div>
</div>
        </div>
        
       
        <!-- LEADERBOARD TAB -->
        <div id="leaderboard-tab" class="tab-content">
            <div class="settings-section">
                <h3>Top Scores</h3>
                <table class="leaderboard-table">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Name</th>
                            <th>Score</th>
                            <th>Date</th>
                        </tr>
                    </thead>
                    <tbody id="leaderboardBody">
                        <!-- Leaderboard entries will be added here -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- GLOBAL LEADERBOARD TAB -->
<div id="global-leaderboard-tab" class="tab-content">
    <div class="settings-section">
        <h3>üåç Global Leaderboard</h3>
        <table class="leaderboard-table">
            <thead>
                <tr>
                    <th>Rank</th>
                    <th>Player</th>
                    <th>Score</th>
                    <th>Character</th>
                </tr>
            </thead>
            <tbody id="globalLeaderboardBody">
                <!-- Global leaderboard entries will be added here -->
            </tbody>
        </table>
        
        <div style="text-align: center; margin-top: 15px;">
            <p id="globalPlayerRank" style="color: #FFD700; font-size: 14px; margin: 10px 0;"></p>
            <button onclick="updateGlobalLeaderboardDisplay()" class="game-button" 
                style="padding: 8px 16px; font-size: 14px; background: #4CAF50;">
                üîÑ Refresh Global Scores
            </button>
        </div>
    </div>
</div>

        <button id="closeSettingsButton">Close</button>
    </div>
    <div id="touchArea"></div>
    <div id="swipeInstructions">Swipe ‚Üê ‚Üí to move ‚Ä¢ Swipe ‚Üë to jump ‚Ä¢ Swipe ‚Üì to drop</div>

<!-- Power-up Status Bar -->
<div id="powerUpStatusBar">
    <div class="powerup-icon" id="shieldIcon">
        <div class="powerup-symbol">üõ°Ô∏è</div>
        <div class="powerup-fill"></div>
    </div>
    <div class="powerup-icon" id="multiplierIcon">
        <div class="powerup-symbol">üí∞</div>
        <div class="powerup-fill"></div>
    </div>
    <div class="powerup-icon" id="magnetIcon">
        <div class="powerup-symbol">üß≤</div>
        <div class="powerup-fill"></div>
    </div>
    <!-- Character Ability Icon (hidden by default) -->
    <div class="powerup-icon ability-icon" id="characterAbilityIcon" style="display: none;">
        <div class="powerup-symbol ability-symbol">üî•</div>
        <div class="powerup-fill ability-fill"></div>
    </div>
</div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- ADD THIS LINE - GLTFExporter -->
<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/exporters/GLTFExporter.js"></script>

<!-- Add this line after your THREE.js script -->
<script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/GLTFLoader.js"></script>


 

<!-- Character System - New Modular Approach -->
<script src="characters/shared.js"></script>
<script src="characters/installed/happyface.js"></script>
<script src="characters/installed/ghost.js"></script>
<script src="characters/installed/robot.js"></script>
<script src="characters/installed/dragon.js"></script>
<script src="characters/installed/ufo.js"></script>
<script src="characters/installed/atom.js"></script>
<script src="characters/installed/slime.js"></script>
<script src="characters/installed/apple.js"></script>
<script src="characters/installed/carrot.js"></script>
<script src="characters/installed/pumpkin.js"></script>
<script src="characters/installed/monster.js"></script>
<script src="characters/installed/creature.js"></script>
<!-- CHARACTER INJECTION POINT - Additional characters will be loaded here -->
<script src="worlds/forest.js"></script>
<script src="worlds/desert.js"></script>
<script src="worlds/underwater.js"></script>
<script src="systems/obstacles.js"></script>
<!----   <script src="obstacle-pack-converter.js"></script>   !--OBSTACLE GLB CONVERTER -->
<!----   <script src="scenery-pack-converter.js"></script>    !--SCENERY GLB CONVERTER -->
<script src="systems/audio.js"></script>
<script src="systems/powerups.js"></script>



    <script>

// Game variables
        let scene, camera, renderer, player, obstacles = [], coins = [], ground;
        let waterStreams = [];
        let rareCoins = []; // Array for rare gradient coins
        let powerUps = []; // Array for power-ups
        let activePowerUps = {}; // Track active power-ups
        let powerUpTimers = {}; // Track power-up durations
        let explosionParticles = [];
        let sparkleParticles = [];
        let sceneryObjects = [];
        let meteors = []; // Array to store falling meteors
        let meteorSpawnCounter = 0; // Counter for meteor spawning
        let meteorSpawnRate = 600; // Frames between meteor spawns (much slower - about every 20 seconds)
        let score = 0;
        let totalCoins = 0;
        let gameStarted = false;
        let gameOver = false;
        let gamePaused = false;
        let playerSpeed = 0.2;

// Power-up states
let shieldActive = false;
let coinMultiplierActive = false;
let magnetActive = false;
let powerUpSpawnRate = 1200; // Power-ups spawn every 20 seconds (1200 frames at 60fps)

// Character ability states
let robotShieldActive = false;
let robotShieldCooldown = 0;
let dragonFireActive = false;
let dragonFireCooldown = 0;
let ghostPhaseActive = false;
let ghostPhaseCharges = 0;
let ghostPhaseCooldown = 0;


        
        // Dynamic difficulty variables (time-based)
        let baseSpeed = 0.25;                    // Starting speed
        let currentSpeed = 0.25;                 // Current game speed
        let maxSpeed = 0.65;                     // Maximum speed cap (increased for 4th level)
        let speedIncrement = 0.1;                // Speed increase per interval
        let currentSpeedMultiplier = 1.0;        // Visual speed indicator
        
        // Time-based speed progression
        let gameStartTime = 0;                   // When the game started
        let speedIncreaseIntervals = [20000, 50000, 100000, 160000]; // 20s, 50s more, 50s more, 60s more (in milliseconds)
        let currentSpeedLevel = 0;               // Which speed level we're at
        
        // Spawn rate variables - start with more obstacles, get more frequent with speed
        let baseObstacleSpawnRate = 80;          // Starting frames between obstacles (more frequent)
        let currentObstacleSpawnRate = 80;       // Current spawn rate
        let minObstacleSpawnRate = 40;           // Minimum spawn rate (very frequent)
        
        let baseStreamSpawnRate = 800;           // Starting frames between streams (very rare)
        let currentStreamSpawnRate = 800;        // Current stream spawn rate
        let minStreamSpawnRate = 500;            // Minimum stream spawn rate (still rare)
        
        let streamSpawnCounter = 0;              // Counter for tracking when to force spawn a stream
        let forcedStreamInterval = 800;          // Force spawn a stream after this many frames (rare)
        let coinSpawnRate = 40;                  // Frames between coin spawns (stays constant)
        let scenerySpawnRate = 25;               // Frames between scenery spawns (stays constant)
        
        let frameCount = 0;
        let lanes = [-2, 0, 2]; // Left, center, right
        let currentLane = 1; // Start in center (index 1)
        let jumping = false;
        let playerY = 0.5; // Player's base Y position (height is 1)
        let jumpHeight = 2;
        let jumpSpeed = 0.1;
        let jumpDirection = 1; // 1 = up, -1 = down
        let jumpRotation = 0; // For front flip animation
        let distanceTraveled = 0;
        let isMobile = false; // Flag for mobile device detection
        let groundSegments = []; // Store ground segments for texture updates
let sideTerrainSegments = []; // Store side terrain segments for movement
        let groundIndex = 0; // Index for tracking ground segments
        let streamCreated = false; // Flag to track if a stream was created on this frame
        
        // Leaderboard variables
        let leaderboard = [];
        let currentHighScore = 0;
        let pendingScore = 0;
        const MAX_LEADERBOARD_ENTRIES = 10;
        
        // Environment variables
        let skyLight;
        let ambientLight;  // ADD THIS LINE
        let time = 0; // Time of day (0-1), 0 = day, 0.5 = sunset, 1 = night
        let timeCycleSpeed = 0.0001; // How fast time cycles
        let butterflyGroups = [];
        let birds = [];
        let currentSkyColor = new THREE.Color(0x87CEEB); // Starting sky color
        let targetSkyColor = new THREE.Color(0x87CEEB); // Target sky color for transitions

// Game state variables (simplified - no title character models needed)
let gameState = "title"; // title, characterSelect, playing, paused, gameOver
let titleCharacterModels = []; // Store character models for the title screen
let characterSelectModels = []; // Store character models for the selection screen
let selectedCharacterIndex = 0; // Index of the currently selected character
let characterNames = [
    // CHARACTER ROSTER INJECTION POINT - Package manager will modify this array
    "apple", "carrot", "pumpkin", "happyface", "monster", "atom", "slime", "ufo", "robot", "dragon", "ghost", "creature"
    // END CHARACTER ROSTER INJECTION POINT
];


// ==================== GLB OBSTACLE SYSTEM ====================
// Add this with your other game variables at the top

// GLB Obstacle Loading System
const obstacleModels = new Map();
const worldObstaclePacks = {
    classic: 'assets/obstacles/obstacles_classic_mobile.glb',
    forest: 'assets/obstacles/obstacles_forest_mobile.glb',
    desert: 'assets/obstacles/obstacles_desert_mobile.glb',
    underwater: 'assets/obstacles/obstacles_underwater_mobile.glb'  // ADD THIS
};
let currentWorldObstaclesLoaded = false;

// Load obstacle pack for a specific world
async function loadWorldObstacles(worldName) {
    console.log(`üì¶ Loading ${worldName} obstacles...`);
    
    // Clear previous obstacles from cache
    obstacleModels.clear();
    currentWorldObstaclesLoaded = false;
    
    return new Promise((resolve, reject) => {
        const loader = new THREE.GLTFLoader();
        const packPath = worldObstaclePacks[worldName] || worldObstaclePacks.classic;
        
        loader.load(
            packPath,
            function(gltf) {
                console.log(`‚úÖ Loaded ${worldName} obstacle pack`);

                // Debug the GLB structure
console.log('=== GLB STRUCTURE ===');
console.log('Root scene:', gltf.scene);
console.log('Direct children of scene:', gltf.scene.children.map(child => ({
    name: child.name,
    type: child.type,
    childCount: child.children?.length || 0
})));

// Look for groups that contain the actual obstacles
gltf.scene.children.forEach(child => {
    if (child.isGroup && child.children.length > 0) {
        console.log(`Group "${child.name}" contains:`, child.children.map(c => c.name));
    }
});
console.log('=== END STRUCTURE ===');
                
                // First, let's see the exact structure
console.log('=== DETAILED GLB STRUCTURE ===');
console.log(`World: ${worldName}`);
console.log('Scene children:', gltf.scene.children);

// Clear any previous obstacles
obstacleModels.clear();

// For the exporter structure, obstacles might be organized differently
// Let's look for the main obstacle container
const obstacleContainer = gltf.scene.children.find(child => 
    child.name.includes('_obstacles') || child.name === 'Scene' || child.isGroup
);

if (obstacleContainer && obstacleContainer.children.length > 0) {
    console.log(`Found obstacle container: ${obstacleContainer.name} with ${obstacleContainer.children.length} children`);
    
    // Each child of the container should be a complete obstacle
    obstacleContainer.children.forEach(obstacle => {
        if (obstacle.name && !obstacle.name.includes('_mesh')) {
            // This is a main obstacle group
            obstacleModels.set(obstacle.name, obstacle);
            console.log(`üì¶ Cached complete obstacle: ${obstacle.name}`);
        }
    });
} else {
    // Fallback: look for obstacles at scene level
    gltf.scene.children.forEach(child => {
        // Only cache groups that represent complete obstacles
        if (child.isGroup && child.name && 
            (child.name === 'rock' || 
             child.name === 'treeStump' || 
             child.name === 'log' || 
             child.name === 'bush' || 
             child.name === 'spikes' || 
             child.name === 'fallenTree' ||
             child.name === 'treeRoot' ||
             child.name === 'thornBush' ||
             child.name === 'fallenBranch' ||
             child.name === 'mushroomRing' ||
             child.name === 'puddlePatch' ||
             child.name === 'cactus' ||
             child.name === 'sandDune' ||
             child.name === 'quicksand' ||
             child.name === 'ancientRuin')) {
            obstacleModels.set(child.name, child);
            console.log(`üì¶ Cached obstacle: ${child.name}`);
        }
    });
}

console.log(`Total obstacles cached for ${worldName}:`, obstacleModels.size);
console.log('Cached obstacles:', Array.from(obstacleModels.keys()));
// Validate that only correct obstacles are loaded for each world
const validObstacles = {
    classic: ['rock', 'treeStump', 'log', 'bush', 'spikes'],
    forest: ['treeRoot', 'thornBush', 'fallenBranch', 'mushroomRing', 'puddlePatch'],
    desert: ['cactus', 'sandDune', 'quicksand', 'ancientRuin'],
    underwater: ['coralReef', 'giantClam', 'seaweedTangle', 'sunkenAnchor', 'rockFormation']  // ADD THIS
};

const expectedObstacles = validObstacles[worldName] || [];
const loadedObstacles = Array.from(obstacleModels.keys());

// Remove any obstacles that don't belong to this world
loadedObstacles.forEach(obstacleName => {
    if (!expectedObstacles.includes(obstacleName)) {
        console.warn(`‚ö†Ô∏è Removing invalid obstacle "${obstacleName}" from ${worldName} world`);
        obstacleModels.delete(obstacleName);
    }
});

console.log(`‚úÖ Validated obstacles for ${worldName}:`, Array.from(obstacleModels.keys()));

console.log('=== END DETAILED STRUCTURE ===');
                
                currentWorldObstaclesLoaded = true;
                resolve();
            },
            function(progress) {
                // Progress callback
                if (progress.total > 0) {
                    const percent = (progress.loaded / progress.total * 100).toFixed(0);
                    console.log(`Loading ${worldName} obstacles: ${percent}%`);
                }
            },
            function(error) {
                console.error(`Failed to load ${worldName} obstacles:`, error);
                currentWorldObstaclesLoaded = false;
                reject(error);
            }
        );
    });
}

// Get a clone of a specific obstacle type
function getObstacleFromGLB(obstacleType) {
    const model = obstacleModels.get(obstacleType);
    if (model) {
        const clone = model.clone();
        // Ensure material is also cloned for independent manipulation
        if (clone.material) {
            clone.material = clone.material.clone();
        }
        return clone;
    }
    console.warn(`Obstacle type "${obstacleType}" not found in pack`);
    return null;
}

// ==================== GLB SCENERY SYSTEM ====================
// GLB-based scenery loading for better performance

// Scenery model cache
const sceneryModels = new Map();
const worldSceneryPacks = {
    classic: 'assets/scenery/scenery_classic_mobile.glb',
    forest: 'assets/scenery/scenery_forest_mobile.glb',
    desert: 'assets/scenery/scenery_desert_mobile.glb',
    underwater: 'assets/scenery/scenery_underwater_mobile.glb'  // ADD THIS
};

// Track if scenery is loaded for current world
let currentWorldSceneryLoaded = false;

// Load scenery for a specific world
async function loadWorldScenery(worldName) {
    const packPath = worldSceneryPacks[worldName] || worldSceneryPacks.classic;
    
    console.log(`üå≥ Loading ${worldName} scenery...`);
    
    return new Promise((resolve, reject) => {
            const loader = new THREE.GLTFLoader();
            loader.load(
            packPath,
            (gltf) => {
                console.log(`‚úÖ Loaded ${worldName} scenery pack`);
                
                // Clear any previous scenery
                sceneryModels.clear();
                
                // Debug the structure
                console.log('=== SCENERY GLB STRUCTURE ===');
                console.log(`World: ${worldName}`);
                console.log('Scene children:', gltf.scene.children);
                
                // Look for scenery container
                const sceneryContainer = gltf.scene.children.find(child => 
                    child.name.includes('_scenery') || child.name === 'Scene' || child.isGroup
                );
                
                if (sceneryContainer && sceneryContainer.children.length > 0) {
                    console.log(`Found scenery container: ${sceneryContainer.name} with ${sceneryContainer.children.length} children`);
                    
                    // Cache each scenery item
                    sceneryContainer.children.forEach(sceneryItem => {
                        if (sceneryItem.name && !sceneryItem.name.includes('_mesh')) {
                            sceneryModels.set(sceneryItem.name, sceneryItem);
                            console.log(`üå≤ Cached scenery: ${sceneryItem.name}`);
                        }
                    });
                } else {
                    // Fallback: look at scene level
                    gltf.scene.children.forEach(child => {
                        if (child.isGroup && child.name) {
                            sceneryModels.set(child.name, child);
                            console.log(`üå≤ Cached scenery: ${child.name}`);
                        }
                    });
                }
                
                console.log(`Total scenery cached for ${worldName}:`, sceneryModels.size);
                console.log('Cached scenery:', Array.from(sceneryModels.keys()));
                console.log('=== END SCENERY STRUCTURE ===');
                
                currentWorldSceneryLoaded = true;
                resolve();
            },
            (progress) => {
                // Progress callback
            },
            (error) => {
                console.error('Error loading scenery GLB:', error);
                reject(error);
            }
        );
    });
}

// Get scenery from GLB with proper cloning
function getSceneryFromGLB(sceneryType) {
    const model = sceneryModels.get(sceneryType);
    if (!model) {
        console.warn(`Scenery type "${sceneryType}" not found in GLB`);
        return null;
    }
    
    // Clone the model
    const sceneryClone = model.clone();
    
    // Clone materials to avoid shared material issues
    sceneryClone.traverse((child) => {
        if (child.isMesh && child.material) {
            if (Array.isArray(child.material)) {
                child.material = child.material.map(mat => mat.clone());
            } else {
                child.material = child.material.clone();
            }
        }
    });
    
    // Preserve any animation data from the original
    if (model.userData) {
        sceneryClone.userData = { ...model.userData };
    }
    
    return sceneryClone;
}



// ==================== DEBUG SYSTEM ====================
// Control all console logging from one place
let DEBUG_MODE = false; // Set to true only when debugging

function debug(message, ...args) {
    if (DEBUG_MODE) {
        debug(message, ...args);
    }
}

function debugWarn(message, ...args) {
    if (DEBUG_MODE) {
        debugWarn(message, ...args);
    }
}

function debugError(message, ...args) {
    // Always show errors
    console.error(message, ...args);
}

// World system variables
let currentWorld = "classic";
let selectedWorldIndex = 0;
let worldNames = ["classic"];
let unlockedWorlds = {
    classic: true
};
let worldCosts = {};

// World definitions
let availableWorlds = [
    {
        id: 'classic',
        name: 'Classic Plains',
        description: 'Rolling green hills and peaceful meadows',
        cost: 0,
        colors: {
            sky: 0x87CEEB,
            fog: 0xB0E0E6,
            ground: 0x4CAF50
        },
        lighting: {
            ambient: { color: 0xffffff, intensity: 0.6 },
            directional: { color: 0xffffff, intensity: 0.8 }
        }
    },
    {
        id: 'forest',
        name: 'Enchanted Forest',
        description: 'Mystical woodland with towering trees and magical creatures',
        cost: 5000,
        colors: {
            sky: 0x228B22,
            fog: 0x90EE90,
            ground: 0x2F4F2F
        },
        lighting: {
            ambient: { color: 0x404040, intensity: 0.4 },
            directional: { color: 0xFFFFE0, intensity: 0.6 }
        }
    },
    {
        id: 'desert',
        name: 'Desert Mirage',
        description: 'Scorching sand dunes with mysterious mirages and ancient secrets',
        cost: 10000,
        colors: {
            sky: 0xFFE4B5,
            fog: 0xDEB887,
            ground: 0xF4A460
        },
        lighting: {
            ambient: { color: 0xFFE4B5, intensity: 0.7 },
            directional: { color: 0xFFF8DC, intensity: 1.0 }
        }
    },
    {  // ADD THIS UNDERWATER WORLD
        id: 'underwater',
        name: 'Ocean Depths',
        description: 'Explore the mysterious underwater realm with coral reefs and sea creatures',
        cost: 15000,
        colors: {
            sky: 0x004466,
            fog: 0x003355,
            ground: 0x334455
        },
        lighting: {
            ambient: { color: 0x224466, intensity: 0.5 },
            directional: { color: 0x88BBDD, intensity: 0.4 }
        }
    }
];

let worldSelectModels = [];
let worldSelectScene, worldSelectCamera, worldSelectRenderer;


        
        // Mod mode variables
let modModeEnabled = false;
const MOD_PASSWORD = "5050";
let difficultyOverride = -1; // -1 = normal, 0-4 = force specific level

// Audio control variables
let soundEffectsEnabled = true;
let backgroundMusicEnabled = true;

// Jukebox system variables
// TRACK INJECTION POINT: Add new tracks here in this format:
// { id: 'filename-without-extension', name: 'Display Name', description: 'Short description', artist: 'Artist Name (optional)' }
let availableTracks = [
    { id: 'lofi', name: 'Coffee Shop', description: 'Chill lofi beats', artist: 'Alan G.' },
    { id: 'electronic', name: 'Cybershock', description: 'Futuristic electronic beats', artist: 'Alan G.' },
    { id: 'ambient', name: 'Field of Memories', description: 'Dreamy ethereal lofi vibes', artist: 'Alan G.' },
    { id: 'BitCrushed', name: 'Bit Crushed', description: 'Retro arcade vibes', artist: 'ArtForFartSake' },
    { id: 'SolandianVibes', name: 'Solandian Vibes', description: 'Lofi goodness', artist: 'ArtForFartSake' }
  //  { id: 'slot6', name: 'Field of Memories', description: 'Dreamy ethereal lofi vibes', artist: 'Alan G.' }
  //  { id: 'slot7', name: 'Field of Memories', description: 'Dreamy ethereal lofi vibes', artist: 'Alan G.' }
  //  { id: 'slot8', name: 'Field of Memories', description: 'Dreamy ethereal lofi vibes', artist: 'Alan G.' }
  //  { id: 'slot9', name: 'Field of Memories', description: 'Dreamy ethereal lofi vibes', artist: 'Alan G.' }
  //  { id: 'slot10', name: 'Field of Memories', description: 'Dreamy ethereal lofi vibes', artist: 'Alan G.' }
  //  { id: 'slot11', name: 'Field of Memories', description: 'Dreamy ethereal lofi vibes', artist: 'Alan G.' }
];

// Make availableTracks accessible to audio system
window.availableTracks = availableTracks;

let currentTrack = 'ambient'; // Default to ambient music
let selectedTrack = 'ambient'; // Track selected in jukebox

// Object pools for performance optimization
let sparklePool = [];
let explosionPool = [];
let poolSize = 50; // Maximum pooled objects

// ==================== OBJECT POOL SYSTEM ====================
// Performance optimization - pre-created objects for reuse
// Dependencies: None
// Functions: initializeObjectPools(), getSparkleFromPool(), returnSparkleToPool(), etc.

// Shared materials for performance
const SharedMaterials = {
    coin: null,
    coinEdge: null,
    obstacle: null,
    
    init() {
        this.coin = new THREE.MeshStandardMaterial({ 
            color: 0xFFD700,
            metalness: 1.0,
            roughness: 0.05,
            emissive: 0xFFD700,
            emissiveIntensity: 0.4
        });
        
        this.coinEdge = new THREE.MeshStandardMaterial({ 
            color: 0xFFD700,
            metalness: 1.0, 
            roughness: 0.03,
            emissive: 0xFFD700,
            emissiveIntensity: 0.3
        });
        
        this.obstacle = new THREE.MeshStandardMaterial({
            color: 0xff0000,
            roughness: 0.8
        });
    }
};

// Initialize shared materials
SharedMaterials.init();

// Initialize object pools
function initializeObjectPools() {
    // Pre-create sparkle particles
    for (let i = 0; i < poolSize; i++) {
        const sparkleGeometry = new THREE.SphereGeometry(0.05, 8, 8);
        const sparkleMaterial = new THREE.MeshStandardMaterial({
            color: 0xFFD700,
            emissive: 0xFFFFFF,
            emissiveIntensity: 1,
            transparent: true,
            opacity: 0
        });
        const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
        sparkle.visible = false;
        sparklePool.push(sparkle);
    }
    
    // Pre-create explosion particles
    for (let i = 0; i < poolSize; i++) {
        const explosionGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const explosionMaterial = new THREE.MeshStandardMaterial({
            color: 0xff0000,
            emissive: 0xff0000,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0
        });
        const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
        explosion.visible = false;
        explosionPool.push(explosion);
    }
}

// Coin pool for performance
let coinPool = [];
let coinPoolSize = 20;

function initializeCoinPool() {
    for (let i = 0; i < coinPoolSize; i++) {
        const coin = createCoinObject();
        coin.visible = false;
        coinPool.push(coin);
    }
}

function getCoinFromPool() {
    for (let i = 0; i < coinPool.length; i++) {
        if (!coinPool[i].visible) {
            coinPool[i].visible = true;
            return coinPool[i];
        }
    }
    // Pool exhausted, create new coin
    return createCoinObject();
}

function returnCoinToPool(coin) {
    coin.visible = false;
    coin.position.set(0, 0, -100);
    coin.rotation.set(0, 0, 0);
}

// Get sparkle from pool
function getSparkleFromPool() {
    for (let i = 0; i < sparklePool.length; i++) {
        if (!sparklePool[i].visible) {
            return sparklePool[i];
        }
    }
    return null; // Pool exhausted
}

// Return sparkle to pool
function returnSparkleToPool(sparkle) {
    sparkle.visible = false;
    sparkle.material.opacity = 0;
    sparkle.scale.set(1, 1, 1);
    sparkle.position.set(0, 0, 0);
    if (sparkle.userData) {
        sparkle.userData.age = 0;
        sparkle.userData.lifespan = 0;
    }
}

// Get explosion particle from pool
function getExplosionFromPool() {
    for (let i = 0; i < explosionPool.length; i++) {
        if (!explosionPool[i].visible) {
            return explosionPool[i];
        }
    }
    return null; // Pool exhausted
}

// Return explosion particle to pool
function returnExplosionToPool(explosion) {
    explosion.visible = false;
    explosion.material.opacity = 0;
    explosion.scale.set(1, 1, 1);
    explosion.position.set(0, 0, 0);
    if (explosion.userData) {
        explosion.userData.age = 0;
        explosion.userData.lifespan = 0;
    }
}

// Collision boundary cache for performance
let collisionCache = new Map();
let cacheUpdateThreshold = 0.5; // Update cache if object moved more than this distance

// Get cached or calculate collision boundary
function getCachedCollisionBox(object) {
    const objectId = object.uuid;
    const currentPos = object.position.clone();
    
    // Check if we have cached data
    if (collisionCache.has(objectId)) {
        const cached = collisionCache.get(objectId);
        const distance = cached.lastPosition.distanceTo(currentPos);
        
        // If object hasn't moved much, use cached boundary
        if (distance < cacheUpdateThreshold) {
            // Update the cached box position without recalculating
            const offset = new THREE.Vector3().subVectors(currentPos, cached.lastPosition);
            cached.boundingBox.translate(offset);
            cached.lastPosition = currentPos;
            return cached.boundingBox.clone();
        }
    }
    
    // Calculate new bounding box
    const boundingBox = new THREE.Box3().setFromObject(object);
    
    // Cache it
    collisionCache.set(objectId, {
        boundingBox: boundingBox.clone(),
        lastPosition: currentPos
    });
    
    return boundingBox;
}

// Clean up collision cache for removed objects
function cleanupCollisionCache(objectsArray, cacheKey) {
    const activeIds = new Set(objectsArray.map(obj => obj.uuid));
    for (const [id, cached] of collisionCache.entries()) {
        if (id.startsWith(cacheKey) && !activeIds.has(id)) {
            collisionCache.delete(id);
        }
    }
}

// Simplified distance-based collision for coins and power-ups
function checkSimpleCollision(object, player, threshold = 1.5) {
    return object.position.distanceTo(player.position) < threshold;
}
        
        // Character variables
        let currentCharacter = "happyface";
        let unlockedCharacters = {
    apple: true,
    carrot: false,
    pumpkin: false,
    happyface: false,
    monster: false,
    atom: false,
    slime: false,
    ufo: false,
    robot: false,
    dragon: false,
    ghost: false,
    creature: false
};
        let characterCosts = {
    carrot: 200,
    pumpkin: 500,
    happyface: 1000,
    monster: 5000,
    atom: 10000,
    slime: 15000,
    ufo: 20000,
    robot: 25000,
    dragon: 30000,
    ghost: 40000,
    creature: 50000
};
        
        // Touch/swipe variables
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;
        let swipeThreshold = 40; // Reduced threshold for easier swipe detection
        let jumpSwipeThreshold = 30; // Even lower threshold for jump
        
        // Textures
        let grassTexture;
        let waterTexture;
        
        // Time-based difficulty adjustment function
        function updateDynamicDifficulty() {
            // Check if we should increase speed based on time
            const currentTime = Date.now();
            const gameTime = currentTime - gameStartTime;
            
            // Check if we're using difficulty override
if (difficultyOverride >= 0) {
    // Use the forced difficulty level
    currentSpeedLevel = difficultyOverride;
} else {
    // Use normal time-based progression
    // Check each speed interval
    for (let i = currentSpeedLevel; i < speedIncreaseIntervals.length; i++) {
        if (gameTime >= speedIncreaseIntervals[i]) {
            // Time to increase speed!
            currentSpeedLevel = i + 1;
                    currentSpeed = Math.min(baseSpeed + (currentSpeedLevel * speedIncrement), maxSpeed);
                    
                    // Adjust obstacle spawn rates - more aggressive at higher speeds
let speedProgress = currentSpeedLevel / speedIncreaseIntervals.length;

// Make the progression more dramatic for higher speeds
if (currentSpeedLevel >= 3) {
    // At level 3 and 4, make it much more intense
    speedProgress = 0.7 + (currentSpeedLevel - 3) * 0.15; // 0.7, 0.85, 1.0+
}

currentObstacleSpawnRate = Math.floor(Math.max(
    baseObstacleSpawnRate - (speedProgress * (baseObstacleSpawnRate - minObstacleSpawnRate)),
    currentSpeedLevel >= 4 ? 25 : minObstacleSpawnRate // Even more frequent at max level
));
                    
                    // Adjust stream spawn rate - reduce streams at higher speeds since obstacles are more frequent
if (currentSpeedLevel >= 3) {
    // At high speeds, reduce streams since obstacles are much more frequent
    currentStreamSpawnRate = Math.floor(baseStreamSpawnRate * 1.2);
} else {
    currentStreamSpawnRate = Math.floor(Math.max(
        baseStreamSpawnRate - (speedProgress * 0.2 * (baseStreamSpawnRate - minStreamSpawnRate)),
        minStreamSpawnRate
    ));
}
                    
                    // Update speed multiplier for display
                    currentSpeedMultiplier = currentSpeed / baseSpeed;
                    updateSpeedIndicator();
                    
                    // Debug log to see what's happening
                    debug(`Speed Level: ${currentSpeedLevel}, Speed: ${currentSpeed.toFixed(2)}, Obstacle Rate: ${currentObstacleSpawnRate}, Stream Rate: ${currentStreamSpawnRate}`);
                }
            }
        }
    } // Close the else statement for normal progression
        
        // Update speed indicator display with dynamic theming
function updateSpeedIndicator() {
    const speedIndicator = document.getElementById('speedIndicator');
    
    // Remove all existing speed level classes
    speedIndicator.className = '';
    
    // Apply visual theme based on speed level
    if (currentSpeedLevel === 0) {
        speedIndicator.classList.add('speed-level-1');
    } else if (currentSpeedLevel === 1) {
        speedIndicator.classList.add('speed-level-2');
    } else if (currentSpeedLevel === 2) {
        speedIndicator.classList.add('speed-level-3');
    } else if (currentSpeedLevel === 3) {
        speedIndicator.classList.add('speed-level-4');
    } else if (currentSpeedLevel >= 4) {
        speedIndicator.classList.add('speed-level-5');
    }
    
    // Show only the level names
    let levelText = '';
    if (currentSpeedLevel === 0) {
        levelText = 'CRUISE';
    } else if (currentSpeedLevel === 1) {
        levelText = 'ACCELERATING';
    } else if (currentSpeedLevel === 2) {
        levelText = 'INTENSE';
    } else if (currentSpeedLevel === 3) {
        levelText = 'BLAZING';
    } else if (currentSpeedLevel >= 4) {
        levelText = 'MAXIMUM CHAOS';
    }
    
    // Set only the level name without speed multiplier
    speedIndicator.textContent = levelText;
    
    // Ensure consistent font size for all levels
    speedIndicator.style.fontSize = '18px';
}
        
        // Reset difficulty to starting values
        function resetDynamicDifficulty() {
            gameStartTime = Date.now(); // Reset the timer
            currentSpeedLevel = 0;      // Reset speed level
            currentSpeed = baseSpeed;
            currentObstacleSpawnRate = baseObstacleSpawnRate;
            currentStreamSpawnRate = baseStreamSpawnRate;
            currentSpeedMultiplier = 1.0;
            streamSpawnCounter = 0;
            streamCreated = false;
            updateSpeedIndicator();
            
            // Debug log to confirm reset
            debug(`Game Reset - Speed: ${currentSpeed}, Obstacle Rate: ${currentObstacleSpawnRate}, Stream Rate: ${currentStreamSpawnRate}`);
        }
        
        // Check if it's a mobile device
        function checkMobile() {
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (isMobile) {
                // Show mobile instructions
                document.getElementById('mobileInstructions').style.display = 'inline';
                document.getElementById('touchArea').style.display = 'block';
                document.getElementById('swipeInstructions').style.display = 'block';
                
                // Adjust jump threshold based on screen size for better responsiveness
                const screenHeight = window.innerHeight;
                jumpSwipeThreshold = Math.max(20, Math.min(30, screenHeight / 40));
                swipeThreshold = Math.max(30, Math.min(40, screenHeight / 30));
            }
        }

// Mobile performance settings - define after checkMobile() is called
        let mobileSparkleCount = isMobile ? 8 : 20;        // Fewer sparkles on mobile
        let mobileExplosionCount = isMobile ? 15 : 30;     // Fewer explosion particles
        let mobileButterflyLimit = isMobile ? 3 : 10;      // Fewer butterflies
        let mobileBirdsLimit = isMobile ? 2 : 5;           // Fewer birds


// ==================== MOBILE CONTROLS ====================
// Touch controls, swipe gestures, and mobile input handling
// Dependencies: Game Loop, Player Controls
// Functions: setupMobileControls(), handleTouch(), etc.

        
        // Setup mobile touch controls with swipe gestures
        function setupMobileControls() {
            const touchArea = document.getElementById('touchArea');
            
            // Simplified swipe detection to prevent freezing
            let lastTouchY = 0;
            
            touchArea.addEventListener('touchstart', function(e) {
                if (!gameStarted || gameOver || gamePaused) return;
                
                e.preventDefault();
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                lastTouchY = touchStartY;
                touchStartTime = Date.now();
            });
            
            touchArea.addEventListener('touchend', function(e) {
                if (!gameStarted || gameOver || gamePaused) return;
                
                e.preventDefault();
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                const touchTime = Date.now() - touchStartTime;
                
                // Simple, reliable swipe detection
                if (touchTime < 300) { // Short swipe = faster response
                    const deltaX = touchEndX - touchStartX;
                    const deltaY = touchStartY - touchEndY; // Note: reversed for Y
                    
                    // Simple thresholds
                    const minSwipeDistance = 30;
                    
                    // Determine primary direction of swipe
                    if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > minSwipeDistance) {
                        // Horizontal swipe
                        if (deltaX > 0) {
                            moveRight();
                        } else {
                            moveLeft();
                        }
                    } 
                    else if (Math.abs(deltaY) > Math.abs(deltaX) && Math.abs(deltaY) > minSwipeDistance) {
                        // Vertical swipe
                        if (deltaY > 0 && !jumping) {
                            // Swipe up to jump (only if not already jumping)
                            jump();
                        } else if (deltaY < 0) {
                            // Swipe down to quick drop
                            quickDrop();
                        }
                    }
                }
            });
        }
        
// ==================== GAME INITIALIZATION ====================
// Core game setup and initialization functions
// Dependencies: THREE.js, Audio System, Object Pools
// Functions: init(), setupGame(), initializeGameElements(), etc.

        // Initialize the game
        function init() {
            // Check if it's a mobile device FIRST
            checkMobile();

// Initialize audio system
    initializeAudio();

// Background music system
let backgroundMusic = null;
let musicPlaying = false;
let musicLayers = [];
let currentMusicIntensity = 0;
let targetMusicIntensity = 0;

    // Set initial game state
    gameState = "title";
    
    // Hide the original start screen
    document.getElementById('startScreen').style.display = 'none';
    
    // Show the title screen
document.getElementById('titleScreen').style.display = 'flex';
debug('Title screen should be visible now'); // Debug log

// Initialize the title screen
initTitleScreen();
debug('Title screen initialized'); // Debug log
            
            // Initialize new save system
initializeSaveSystem();

// Initialize world system
selectedWorldIndex = availableWorlds.findIndex(w => w.id === currentWorld);
if (selectedWorldIndex === -1) selectedWorldIndex = 0;

// Legacy: Load leaderboard data (will be migrated to profiles)
loadLeaderboard();

// Initialize object pools for performance
initializeObjectPools();

// ADD THIS: Load obstacles for the default world
loadWorldObstacles(currentWorld || 'classic').then(() => {
    console.log('‚úÖ Initial obstacles loaded');
}).catch(error => {
    console.error('Failed to load initial obstacles:', error);
    // Game can continue without obstacles in case of error
});

// Load initial scenery
loadWorldScenery(currentWorld).then(() => {
    console.log('‚úÖ Initial scenery loaded');
}).catch(error => {
    console.error('Failed to load initial scenery:', error);
});
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue background
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 5);
            camera.lookAt(0, 0, -10);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            // Add lights
            ambientLight = new THREE.AmbientLight(0xffffff, 0.6);  // Remove 'const' to use global variable
            scene.add(ambientLight);
            
            // Add directional light (sunlight)
            skyLight = new THREE.DirectionalLight(0xffffff, 0.8);
            skyLight.position.set(10, 20, 10);
            skyLight.castShadow = true;
            scene.add(skyLight);
            
            // Load textures
            loadTextures();
            
            // Create ground with grass texture
            createGround();
            
            // Create background scenery
            createBackground();
            
            // Create player based on selected character
            createPlayer();
        
            
            // Initialize dynamic difficulty
            resetDynamicDifficulty();
            
            // Add event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);
            
            // Setup click outside to close settings
            document.getElementById('modalOverlay').addEventListener('click', closeSettingsScreen);
            
            // Setup tab switching in settings
            document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', function() {
                    // Remove active class from all tabs
                    document.querySelectorAll('.tab-button').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    
                    // Add active class to clicked tab
                    this.classList.add('active');
                    const tabId = this.getAttribute('data-tab');
                    document.getElementById(tabId).classList.add('active');
                });
            });
            
            // Update leaderboard display
            updateLeaderboardDisplay();
            
            

            // Setup settings UI
            setupSettingsUI();
            
            // Use onclick instead of addEventListener for more reliability
            document.getElementById('startButton').onclick = startGame;
            document.getElementById('restartButton').onclick = restartGame;
            document.getElementById('gameOverMainMenuBtn').onclick = showMainMenuFromGameOver;
            document.getElementById('gameOverSettingsBtn').onclick = toggleSettingsFromGameOver;
            document.getElementById('resumeButton').onclick = togglePause;
            document.getElementById('pauseRestartButton').onclick = restartFromPause;
            document.getElementById('pauseMainMenuBtn').onclick = showMainMenuFromPause;
            document.getElementById('pauseSettingsBtn').onclick = toggleSettingsFromPause;
            document.getElementById('pauseBtn').onclick = togglePause;
            document.getElementById('closeSettingsButton').onclick = closeSettingsScreen;
            document.getElementById('modModeButton').onclick = toggleModMode;
            document.getElementById('resetDataButton').onclick = resetGameData;
            document.getElementById('applyDifficultyButton').onclick = applyDifficultyOverride;

document.getElementById('soundEffectsCheckbox').addEventListener('change', function() {
    soundEffectsEnabled = this.checked;
    saveGameData('settings_change');
});

// Skip button
const skipBtn = document.getElementById('skipBtn');
if (skipBtn) {
    skipBtn.addEventListener('click', () => {
        if (window.skipToNextTrack) {
            window.skipToNextTrack();
        } else if (window.AudioSystem && window.AudioSystem.skipToNextTrack) {
            window.AudioSystem.skipToNextTrack();
        }
    });
    
    // Hide skip button when not in shuffle mode
    const updateSkipButton = () => {
        const isShuffleMode = window.shuffleMode || (window.AudioSystem && window.AudioSystem.getShuffleMode && window.AudioSystem.getShuffleMode());
        skipBtn.style.display = isShuffleMode ? 'inline-block' : 'none';
        skipBtn.style.opacity = isShuffleMode ? '1' : '0.5';
    };
    
    updateSkipButton();
    setInterval(updateSkipButton, 1000);
}


document.getElementById('backgroundMusicCheckbox').addEventListener('change', function() {
    backgroundMusicEnabled = this.checked;
    if (!backgroundMusicEnabled && musicPlaying) {
        stopBackgroundMusic();
    } else if (backgroundMusicEnabled && gameStarted && !gameOver && !gamePaused) {
        startBackgroundMusic();
    }
    saveGameData('settings_change');
});
            
            // Add mobile touch controls if needed
            if (isMobile) {
                setupMobileControls();
            }
            
            // Update the total coins display
            updateTotalCoins();

            
            // Start animation loop
            animate();
        }
        
// ==================== SETTINGS & UI SYSTEM ====================
// Settings menu, UI controls, and user interface management
// Dependencies: Character System, World System
// Functions: setupSettingsUI(), updateCharactersInSettings(), toggleSettings(), etc.

        // Setup settings UI
function setupSettingsUI() {
    // Initialize jukebox
    initializeJukebox();
    
    // Initialize shuffle mode by default (wait a bit for audio system to load)
    setTimeout(() => {
        if (window.AudioSystem) {
            // Initialize shuffle queue since we're starting in shuffle mode
            if (window.AudioSystem.toggleShuffleMode) {
                // Shuffle is already true by default, just need to initialize the queue
                if (window.shuffleMode && typeof initializeShuffleQueue === 'function') {
                    // The function is in audio.js, so call it through the audio system
                    window.AudioSystem.initializeShuffleQueue?.();
                }
            }
        }
    }, 100);

    // Update mod mode UI based on CURRENT state
    if (modModeEnabled) {
        document.getElementById('mod-mode-option').classList.add('enabled');
        document.getElementById('modModeButton').textContent = 'Disable';
        
        // Show difficulty override option since mod mode is active
        const difficultyOption = document.getElementById('difficulty-override-option');
        if (difficultyOption) {
            difficultyOption.style.display = 'flex';
        }
    } else {
        document.getElementById('mod-mode-option').classList.remove('enabled');
        document.getElementById('modModeButton').textContent = 'Enable';
        
        // Hide difficulty override option since mod mode is inactive
        const difficultyOption = document.getElementById('difficulty-override-option');
        if (difficultyOption) {
            difficultyOption.style.display = 'none';
        }
    }
}

        // Initialize jukebox system
function initializeJukebox() {

    // Ensure audio system is available
        if (!window.AudioSystem) {
            console.warn('Audio system not yet loaded, retrying jukebox init...');
            setTimeout(initializeJukebox, 100);
            return;
        }

    const trackSelector = document.getElementById('trackSelector');
    const manualSelection = document.getElementById('manualTrackSelection');
    
    // Clear and populate track selector
    if (trackSelector) {
        trackSelector.innerHTML = '';
        
        // INJECTION POINT: availableTracks array will automatically populate this dropdown
        availableTracks.forEach(track => {
            const option = document.createElement('option');
            option.value = track.id;
            option.textContent = `${track.name} - ${track.description}`;
            if (track.id === selectedTrack) {
                option.selected = true;
            }
            trackSelector.appendChild(option);
        });
        
        // Add change listener
        trackSelector.addEventListener('change', (e) => {
            selectedTrack = e.target.value;
            debug(`üéµ Selected track: ${selectedTrack}`);
        });
    }
    
  // Initialize shuffle button
const shuffleBtn = document.getElementById('shuffleToggleBtn');
if (shuffleBtn) {
    shuffleBtn.addEventListener('click', () => {
        if (window.toggleShuffleMode) {
            window.toggleShuffleMode();
        } else if (window.AudioSystem && window.AudioSystem.toggleShuffleMode) {
            window.AudioSystem.toggleShuffleMode();
        }
        // Small delay to ensure state is updated
        setTimeout(updateShuffleUI, 50);
    });
    updateShuffleUI();
}
    
    // Show/hide manual selection based on shuffle mode
    if (manualSelection) {
        manualSelection.style.display = shuffleMode ? 'none' : 'block';
    }
    
    // Add apply button listener
    const applyBtn = document.getElementById('applyTrackBtn');
    if (applyBtn) {
        applyBtn.addEventListener('click', applySelectedTrack);
    }
    
    debug('üéµ Jukebox system initialized!');
}

// Apply the selected track
function applySelectedTrack() {
    if (shuffleMode) {
        debug('üîÄ In shuffle mode - tracks change automatically');
        return;
    }
    
    if (selectedTrack === currentTrack) {
        debug('üéµ Track already playing!');
        return;
    }
    
    debug(`üéµ Switching from ${currentTrack} to ${selectedTrack}`);
    
    // Stop current music
    if (musicPlaying) {
        stopBackgroundMusic();
    }
    
    // Update current track
    currentTrack = selectedTrack;
    
    // Start new music if game is playing and music is enabled
    if (gameStarted && !gameOver && !gamePaused && backgroundMusicEnabled) {
        startBackgroundMusic();
    }
    
    // Save preference
    if (typeof saveGameData === 'function') {
        saveGameData('settings_change');
    }
    
    debug(`‚úÖ Successfully switched to: ${availableTracks.find(t => t.id === currentTrack)?.name}`);
}

// Update jukebox UI when shuffle mode changes
function updateJukeboxUI() {
    const manualSelection = document.getElementById('manualTrackSelection');
    if (manualSelection) {
        manualSelection.style.display = shuffleMode ? 'none' : 'block';
    }
    updateShuffleUI();
}

// Call this function when shuffle mode changes
function updateShuffleUI() {
    // Get shuffle mode from audio system (check both sources)
    const currentShuffleMode = window.AudioSystem ? (window.AudioSystem.getShuffleMode ? window.AudioSystem.getShuffleMode() : window.shuffleMode) : false;
    
    const shuffleBtn = document.getElementById('shuffleToggleBtn');
    if (shuffleBtn) {
        shuffleBtn.textContent = currentShuffleMode ? 'üîÄ Shuffle: ON' : 'üîÄ Shuffle: OFF';
        shuffleBtn.style.background = currentShuffleMode ? 'rgba(0, 255, 0, 0.3)' : 'rgba(255, 255, 255, 0.1)';
        
        // Add hover effect styles to make it more reactive
        shuffleBtn.style.transition = 'all 0.2s ease';
        shuffleBtn.style.cursor = 'pointer';
        
        // Add active/pressed styling
        shuffleBtn.onmousedown = () => {
            shuffleBtn.style.transform = 'scale(0.95)';
            shuffleBtn.style.background = currentShuffleMode ? 'rgba(0, 200, 0, 0.5)' : 'rgba(255, 255, 255, 0.2)';
        };
        
        shuffleBtn.onmouseup = shuffleBtn.onmouseleave = () => {
            shuffleBtn.style.transform = 'scale(1)';
            shuffleBtn.style.background = currentShuffleMode ? 'rgba(0, 255, 0, 0.3)' : 'rgba(255, 255, 255, 0.1)';
        };
    }
    
    // Update manual selection visibility
    const manualSelection = document.getElementById('manualTrackSelection');
    if (manualSelection) {
        manualSelection.style.display = currentShuffleMode ? 'none' : 'block';
    }
}
        
// Leaderboard functions - Updated with data preservation
function mergeLeaderboards() {
    // Get data from both keys
    const oldLeaderboard = JSON.parse(localStorage.getItem('endlessRunnerLeaderboard') || '[]');
    const newLeaderboard = JSON.parse(localStorage.getItem('runningBlitzLeaderboard') || '[]');
    
    // Combine both arrays
    const combinedLeaderboard = [...oldLeaderboard, ...newLeaderboard];
    
    // Remove duplicates and sort by score
    const uniqueLeaderboard = combinedLeaderboard
        .filter((entry, index, self) => 
            index === self.findIndex(e => e.name === entry.name && e.score === entry.score && e.date === entry.date)
        )
        .sort((a, b) => b.score - a.score)
        .slice(0, 10); // Keep only top 10
    
    // Save to both keys for compatibility
    localStorage.setItem('runningBlitzLeaderboard', JSON.stringify(uniqueLeaderboard));
    localStorage.setItem('endlessRunnerLeaderboard', JSON.stringify(uniqueLeaderboard));
    
    debug('Leaderboards merged:', uniqueLeaderboard);
    return uniqueLeaderboard;
}

function loadLeaderboard() {
    // First merge any existing data
    const mergedData = mergeLeaderboards();
    leaderboard = mergedData;
    
    // Get current high score
    if (leaderboard.length > 0) {
        currentHighScore = leaderboard[0].score;
    }
}

function saveLeaderboard() {
    // Save to both keys for compatibility
    localStorage.setItem('runningBlitzLeaderboard', JSON.stringify(leaderboard));
    localStorage.setItem('endlessRunnerLeaderboard', JSON.stringify(leaderboard));
}

function updateLeaderboardDisplay() {
    // Always merge fresh data when displaying
    const currentLeaderboard = mergeLeaderboards();
    
    const leaderboardBody = document.getElementById('leaderboardBody');
    leaderboardBody.innerHTML = '';
    
    if (currentLeaderboard.length === 0) {
        const row = document.createElement('tr');
        row.innerHTML = `<td colspan="4" style="text-align: center;">No high scores yet!</td>`;
        leaderboardBody.appendChild(row);
        return;
    }
    
    currentLeaderboard.forEach((entry, index) => {
        const row = document.createElement('tr');
        
        // Get avatar for this entry (use current player's avatar if it's their score)
        let avatarHtml = 'üèÉ'; // Default emoji
        if (entry.name === (currentProfile.username || 'Anonymous')) {
            // This is the current player's score - use their avatar
            if (currentProfile.avatarType === 'image' && currentProfile.avatarData) {
                avatarHtml = `<img src="${currentProfile.avatarData}" style="width: 24px; height: 24px; border-radius: 50%; object-fit: cover; vertical-align: middle;">`;
            } else {
                avatarHtml = currentProfile.avatarData || 'üèÉ';
            }
        } else if (entry.avatar) {
            // Entry has stored avatar data
            if (entry.avatarType === 'image' && entry.avatar) {
                avatarHtml = `<img src="${entry.avatar}" style="width: 24px; height: 24px; border-radius: 50%; object-fit: cover; vertical-align: middle;">`;
            } else {
                avatarHtml = entry.avatar || 'üèÉ';
            }
        }
        
        row.innerHTML = `
            <td>${index + 1}</td>
            <td style="display: flex; align-items: center; gap: 8px;">
                <span style="font-size: 20px;">${avatarHtml}</span>
                <span>${entry.name}</span>
            </td>
            <td>${entry.score}</td>
            <td>${entry.character || 'Unknown'}</td>
        `;
        leaderboardBody.appendChild(row);
    });
}

function formatDate(dateString) {
    const date = new Date(dateString);
    return date.toLocaleDateString();
}


        
        function saveHighScore() {
    // Use profile username instead of manual input
    const playerName = currentProfile.username || 'Anonymous';
    const currentScore = score;
    
    // Remove the name input requirement
    const nameInput = document.getElementById('playerNameInput');

    
    if (nameInput) nameInput.style.display = 'none';
    if (saveButton) saveButton.textContent = 'Saving...';
    
    // Get existing leaderboard
    let leaderboard = JSON.parse(localStorage.getItem('runningBlitzLeaderboard') || '[]');
    
// Add new score with avatar data
    leaderboard.push({
        name: playerName,
        score: currentScore,
        character: currentCharacter,
        date: new Date().toLocaleDateString(),
        avatar: currentProfile.avatarData || 'üèÉ',
        avatarType: currentProfile.avatarType || 'emoji'
    });
    
    // Sort by score (highest first)
    leaderboard.sort((a, b) => b.score - a.score);
    
    // Keep only top 10
    leaderboard = leaderboard.slice(0, 10);
    
    // Save back to localStorage
    localStorage.setItem('runningBlitzLeaderboard', JSON.stringify(leaderboard));

    // Update profile high score if this is a new personal best
    if (currentScore > (currentProfile.highScore || 0)) {
        currentProfile.highScore = currentScore;
        debug('üèÜ New personal best recorded:', currentScore);
    }
    
    // Hide name entry section
    document.getElementById('newHighScoreMessage').style.display = 'none';
    
    debug('üíæ Saving high score for:', playerName);
    debug('Score saved to leaderboard!', leaderboard);

    // Submit to global leaderboard
    submitToGlobalLeaderboard(playerName, currentScore, currentCharacter);
    
    // Save profile with high score reason - THIS WILL SHOW THE SAVE INDICATOR
    saveGameData('high_score');
    
    // Show beautiful confirmation notification
    showHighScoreNotification(playerName, currentScore);

    
}

// Auto-save high score (called automatically when game ends)
function autoSaveHighScore(currentScore) {
    const playerName = currentProfile.username || 'Anonymous';
    
    // Get existing leaderboard
    let leaderboard = JSON.parse(localStorage.getItem('runningBlitzLeaderboard') || '[]');
    
    // Add new score with avatar data
    leaderboard.push({
        name: playerName,
        score: currentScore,
        character: currentCharacter,
        date: new Date().toLocaleDateString(),
        avatar: currentProfile.avatarData || 'üèÉ',
        avatarType: currentProfile.avatarType || 'emoji'
    });
    
    // Sort by score (highest first)
    leaderboard.sort((a, b) => b.score - a.score);
    
    // Keep only top 10
    leaderboard = leaderboard.slice(0, 10);
    
    // Save back to localStorage
    localStorage.setItem('runningBlitzLeaderboard', JSON.stringify(leaderboard));
    
    debug('üíæ Auto-saved high score for:', playerName, 'Score:', currentScore);

    // Submit to global leaderboard
    submitToGlobalLeaderboard(playerName, currentScore, currentCharacter);
    
    // Save profile with high score reason
    saveGameData('high_score');
    
    // Only show "New High Score" notification if it's actually a personal best
    const isPersonalBest = currentScore > (currentProfile.highScore || 0);
    if (isPersonalBest) {
        showHighScoreNotification(playerName, currentScore);
    } else {
        // Show a different notification for leaderboard saves that aren't personal bests
        showLeaderboardSaveNotification(playerName, currentScore);
    }
}

// Show high score saved notification
function showHighScoreNotification(playerName, score) {
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        background: linear-gradient(135deg, #FFD700, #FFA500);
        color: #333;
        padding: 25px 35px;
        border-radius: 18px;
        font-size: 18px;
        font-weight: bold;
        text-align: center;
        z-index: 5000;
        box-shadow: 0 12px 40px rgba(255, 215, 0, 0.4);
        border: 3px solid rgba(255, 255, 255, 0.3);
        backdrop-filter: blur(10px);
        transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        pointer-events: none;
        max-width: 350px;
    `;
    
    notification.innerHTML = `
        <div style="font-size: 48px; margin-bottom: 12px;">üèÜ</div>
        <div style="font-size: 20px; margin-bottom: 8px; color: #333;">High Score Saved!</div>
        <div style="font-size: 16px; color: #555; margin-bottom: 5px;">${playerName}</div>
        <div style="font-size: 24px; font-weight: bold; color: #333;">${score.toLocaleString()} Points</div>
    `;
    
    document.body.appendChild(notification);
    
    // Animate in
    requestAnimationFrame(() => {
        notification.style.transform = 'translate(-50%, -50%) scale(1)';
        notification.style.opacity = '1';
    });
    
    // Animate out and remove
    setTimeout(() => {
        notification.style.transform = 'translate(-50%, -50%) scale(0.8)';
        notification.style.opacity = '0';
        
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 400);
    }, 2500);
}

// Show notification for leaderboard save (not necessarily a personal best)
function showLeaderboardSaveNotification(playerName, currentScore) {
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        background: linear-gradient(135deg, #4CAF50, #45a049);
        color: white;
        padding: 25px 30px;
        border-radius: 16px;
        font-size: 16px;
        font-weight: bold;
        text-align: center;
        z-index: 5000;
        box-shadow: 0 12px 40px rgba(76, 175, 80, 0.4);
        border: 2px solid rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(10px);
        transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        pointer-events: none;
        max-width: 350px;
    `;
    
    notification.innerHTML = `
        <div style="font-size: 42px; margin-bottom: 12px;">üìä</div>
        <div style="font-size: 18px; margin-bottom: 8px; text-shadow: 0 2px 4px rgba(0,0,0,0.3);">Score Saved!</div>
        <div style="font-size: 14px; opacity: 0.9; line-height: 1.4;">${playerName}: ${currentScore.toLocaleString()} points</div>
    `;
    
    document.body.appendChild(notification);
    
    // Animate in
    requestAnimationFrame(() => {
        notification.style.transform = 'translate(-50%, -50%) scale(1)';
        notification.style.opacity = '1';
    });
    
    // Animate out and remove
    setTimeout(() => {
        notification.style.transform = 'translate(-50%, -50%) scale(0.8)';
        notification.style.opacity = '0';
        
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 400);
    }, 3000);
}

// Show mod mode notification
function showModModeNotification(enabled, wrongPassword = false) {
    const notification = document.createElement('div');
    
    let backgroundColor, emoji, title, message;
    
    if (wrongPassword) {
        backgroundColor = 'linear-gradient(135deg, #F44336, #D32F2F)';
        emoji = '‚ùå';
        title = 'Incorrect Password';
        message = 'Please try again';
    } else if (enabled) {
        backgroundColor = 'linear-gradient(135deg, #4CAF50, #388E3C)';
        emoji = 'üîì';
        title = 'Mod Mode Enabled';
        message = 'All content unlocked!';
    } else {
        backgroundColor = 'linear-gradient(135deg, #FF9800, #F57C00)';
        emoji = 'üîí';
        title = 'Mod Mode Disabled';
        message = 'Content locked again';
    }
    
    notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        background: ${backgroundColor};
        color: white;
        padding: 25px 30px;
        border-radius: 16px;
        font-size: 18px;
        font-weight: bold;
        text-align: center;
        z-index: 5000;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3);
        border: 2px solid rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(10px);
        transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        pointer-events: none;
        max-width: 300px;
    `;
    
    notification.innerHTML = `
        <div style="font-size: 42px; margin-bottom: 12px;">${emoji}</div>
        <div style="font-size: 20px; margin-bottom: 6px; text-shadow: 0 2px 4px rgba(0,0,0,0.3);">${title}</div>
        <div style="font-size: 14px; opacity: 0.9; text-shadow: 0 1px 2px rgba(0,0,0,0.3);">${message}</div>
    `;
    
    document.body.appendChild(notification);
    
    // Animate in
    requestAnimationFrame(() => {
        notification.style.transform = 'translate(-50%, -50%) scale(1)';
        notification.style.opacity = '1';
    });
    
    // Animate out and remove
    setTimeout(() => {
        notification.style.transform = 'translate(-50%, -50%) scale(0.8)';
        notification.style.opacity = '0';
        
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 400);
    }, wrongPassword ? 2000 : 2500);
}


// ===== GLOBAL LEADERBOARD SYSTEM =====
let globalLeaderboard = [];
let playerGlobalRank = null;

// Submit score to global leaderboard
function submitToGlobalLeaderboard(playerName, score, character) {
    if (!cloudSaveEnabled || !playerId) {
        debug('‚ö†Ô∏è Cannot submit to global leaderboard - cloud save not available');
        return;
    }
    
    const globalEntry = {
        playerId: playerId,
        playerName: playerName,
        score: score,
        character: character,
        timestamp: Date.now(),
        date: new Date().toLocaleDateString(),
        country: 'Unknown', // We'll add geolocation later
        avatar: currentProfile.avatarData || 'üèÉ',
        avatarType: currentProfile.avatarType || 'emoji'
    };
    
    // Submit to Firebase global leaderboard
    firebase.database().ref('globalLeaderboard').push(globalEntry)
        .then(() => {
            debug('üèÜ Score submitted to global leaderboard!');
            loadGlobalLeaderboard(); // Refresh to see new rankings
        })
        .catch((error) => {
            console.error('‚ùå Failed to submit to global leaderboard:', error);
        });
}

// Load global leaderboard from Firebase
function loadGlobalLeaderboard() {
    if (!cloudSaveEnabled) return;
    
    firebase.database().ref('globalLeaderboard')
        .orderByChild('score')
        .limitToLast(100) // Get top 100 scores
        .once('value')
        .then((snapshot) => {
            const data = snapshot.val();
            
            if (data) {
                // Convert to array and sort by score (highest first)
                globalLeaderboard = Object.values(data)
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 50); // Keep top 50
                
                debug(`üåç Loaded ${globalLeaderboard.length} global scores`);
                
                // Find player's rank
                findPlayerGlobalRank();
            } else {
                globalLeaderboard = [];
                debug('üåç No global scores found - be the first!');
            }
        })
        .catch((error) => {
            console.error('‚ùå Failed to load global leaderboard:', error);
        });
}

// Find current player's rank in global leaderboard
function findPlayerGlobalRank() {
    if (!playerId) return;
    
    playerGlobalRank = null;
    
    for (let i = 0; i < globalLeaderboard.length; i++) {
        if (globalLeaderboard[i].playerId === playerId) {
            playerGlobalRank = i + 1; // Rank is index + 1
            break;
        }
    }
    
    if (playerGlobalRank) {
        debug(`üèÜ Your global rank: #${playerGlobalRank}`);
    }
}

// Show global leaderboard popup
function showGlobalLeaderboard() {
    loadGlobalLeaderboard(); // Refresh data first
    
    setTimeout(() => { // Wait for data to load
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center;
            z-index: 10000; font-family: Arial, sans-serif;
        `;
        
        let leaderboardHTML = `
            <div style="
                background: rgba(0, 20, 40, 0.95);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.2);
                padding: 30px;
                border-radius: 20px;
                max-width: 500px;
                max-height: 80vh;
                overflow-y: auto;
                text-align: center;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            ">
                <h2 style="color: white; margin-bottom: 20px; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">
                    üåç Global Leaderboard
                </h2>
        `;
        
        if (globalLeaderboard.length === 0) {
            leaderboardHTML += `
                <p style="color: white; font-size: 18px; margin: 40px 0;">
                    üèÜ Be the first player on the global leaderboard!<br>
                    <small style="color: #ccc;">Play a game and your score will appear here!</small>
                </p>
            `;
        } else {
            // Show player's rank if they have one
            if (playerGlobalRank) {
                leaderboardHTML += `
                    <div style="background: rgba(255, 215, 0, 0.2); border: 1px solid #FFD700; border-radius: 10px; padding: 15px; margin-bottom: 20px;">
                        <p style="color: #FFD700; font-size: 16px; margin: 0;">
                            üèÜ Your Global Rank: #${playerGlobalRank}
                        </p>
                    </div>
                `;
            }
            
            leaderboardHTML += `
                <div style="text-align: left; max-height: 400px; overflow-y: auto;">
            `;
            
            // Display top scores
            globalLeaderboard.slice(0, 20).forEach((entry, index) => {
                const rank = index + 1;
                const isCurrentPlayer = entry.playerId === playerId;
                
                let rankEmoji = 'üèÖ';
                if (rank === 1) rankEmoji = 'ü•á';
                else if (rank === 2) rankEmoji = 'ü•à';
                else if (rank === 3) rankEmoji = 'ü•â';
                
                const bgColor = isCurrentPlayer ? 'rgba(0, 255, 0, 0.1)' : 'rgba(255, 255, 255, 0.05)';
                const textColor = isCurrentPlayer ? '#00FF00' : 'white';
                
// Get avatar for this entry
                let avatarHtml = 'üèÉ'; // Default emoji
                if (entry.avatar) {
                    if (entry.avatarType === 'image' && entry.avatar) {
                        avatarHtml = `<img src="${entry.avatar}" style="width: 24px; height: 24px; border-radius: 50%; object-fit: cover; margin-right: 8px; vertical-align: middle;">`;
                    } else {
                        avatarHtml = `<span style="font-size: 20px; margin-right: 8px;">${entry.avatar || 'üèÉ'}</span>`;
                    }
                }

                leaderboardHTML += `
                    <div style="
                        background: ${bgColor};
                        border: 1px solid rgba(255, 255, 255, 0.1);
                        border-radius: 8px;
                        padding: 12px;
                        margin: 8px 0;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    ">
                        <div style="display: flex; align-items: center; color: ${textColor}; font-weight: bold;">
                            ${avatarHtml}
                            <span>${rankEmoji} #${rank} ${entry.playerName || 'Anonymous'}</span>
                        </div>
                        <div style="text-align: right;">
                            <div style="color: ${textColor}; font-size: 18px; font-weight: bold;">
                                ${entry.score.toLocaleString()}
                            </div>
                            <div style="color: #ccc; font-size: 12px;">
                                ${entry.character} ‚Ä¢ ${entry.date}
                            </div>
                        </div>
                    </div>
                `;
            });
            
            leaderboardHTML += `</div>`;
            
            // Show total players
            leaderboardHTML += `
                <p style="color: #ccc; font-size: 14px; margin-top: 20px;">
                    üåç ${globalLeaderboard.length} players competing worldwide!
                </p>
            `;
        }
        
        leaderboardHTML += `
                <button onclick="this.parentElement.parentElement.remove()" 
                    style="background: #007AFF; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 16px; margin-top: 20px;">
                    Close
                </button>
            </div>
        `;
        
        modal.innerHTML = leaderboardHTML;
        document.body.appendChild(modal);
    }, 1000); // Give time for data to load
}

        
        // Update character display in settings
        function updateCharactersInSettings() {
            // Reset all selections
            document.querySelectorAll('#characterSelect .character-option').forEach(option => {
                option.classList.remove('selected');
            });
            
            // Mark current character as selected
            document.getElementById(`${currentCharacter}-option`).classList.add('selected');
            
            // Update cost displays
            for (const character in characterCosts) {
                const costElement = document.getElementById(`${character}-cost`);
                if (costElement) {
                    if (unlockedCharacters[character]) {
                        costElement.textContent = 'Unlocked';
                    } else {
                        costElement.textContent = `Cost: ${characterCosts[character]} coins`;
                    }
                }
            }
        }

        // Update existing global leaderboard entries with new avatar data
function updateGlobalLeaderboardAvatar() {
    if (!cloudSaveEnabled || !playerId) {
        debug('‚ö†Ô∏è Cannot update global avatar - cloud save not available');
        return;
    }
    
    const playerName = currentProfile.username || 'Anonymous';
    const newAvatar = currentProfile.avatarData || 'üèÉ';
    const newAvatarType = currentProfile.avatarType || 'emoji';
    
    debug('üîÑ Updating global leaderboard entries with new avatar...');
    
    // Get all global leaderboard entries
    firebase.database().ref('globalLeaderboard')
        .orderByChild('playerId')
        .equalTo(playerId)
        .once('value')
        .then((snapshot) => {
            const userEntries = snapshot.val();
            
            if (userEntries) {
                const updates = {};
                let updateCount = 0;
                
                // Update each entry for this player
                Object.keys(userEntries).forEach(entryKey => {
                    const entry = userEntries[entryKey];
                    
                    // Only update if avatar data is different or missing
                    if (!entry.avatar || entry.avatar !== newAvatar || 
                        !entry.avatarType || entry.avatarType !== newAvatarType) {
                        
                        updates[`globalLeaderboard/${entryKey}/avatar`] = newAvatar;
                        updates[`globalLeaderboard/${entryKey}/avatarType`] = newAvatarType;
                        
                        // Also update username if it changed
                        if (entry.playerName !== playerName) {
                            updates[`globalLeaderboard/${entryKey}/playerName`] = playerName;
                        }
                        
                        updateCount++;
                    }
                });
                
                if (updateCount > 0) {
                    // Apply all updates at once
                    firebase.database().ref().update(updates)
                        .then(() => {
                            debug(`‚úÖ Updated ${updateCount} global leaderboard entries with new avatar`);
                            
                            // Refresh the global leaderboard display
                            loadGlobalLeaderboard();
                            
                            // Show a quick notification
                            showProfileNotification(`Updated ${updateCount} leaderboard entries!`, 'üèÜ');
                        })
                        .catch((error) => {
                            console.error('‚ùå Failed to update global leaderboard entries:', error);
                        });
                } else {
                    debug('‚ÑπÔ∏è No global leaderboard entries need updating');
                }
            } else {
                debug('‚ÑπÔ∏è No existing global leaderboard entries found for this player');
            }
        })
        .catch((error) => {
            console.error('‚ùå Failed to check existing global leaderboard entries:', error);
        });
}

// Update global leaderboard in settings tab
function updateSettingsGlobalLeaderboard() {
    const tbody = document.getElementById('settingsGlobalLeaderboardBody');
    const rankDisplay = document.getElementById('settingsGlobalRankText');
    
    if (!tbody) return;
    
    // Clear existing content
    tbody.innerHTML = '';
    
    if (globalLeaderboard.length === 0) {
        tbody.innerHTML = `
            <tr>
                <td colspan="4" style="text-align: center; padding: 30px; color: white;">
                    üèÜ Be the first on the global leaderboard!<br>
                    <small style="color: #ccc;">Complete a game to see your score here!</small>
                </td>
            </tr>
        `;
        if (rankDisplay) {
            rankDisplay.textContent = "üåç No global scores yet - be the first!";
        }
        return;
    }
    
    // Add top 15 scores
    globalLeaderboard.slice(0, 15).forEach((entry, index) => {
        const rank = index + 1;
        const isCurrentPlayer = entry.playerId === playerId;
        
        let rankDisplay = `#${rank}`;
        if (rank === 1) rankDisplay = 'ü•á';
        else if (rank === 2) rankDisplay = 'ü•à';
        else if (rank === 3) rankDisplay = 'ü•â';
        
        const rowStyle = isCurrentPlayer ? 'background: rgba(0, 255, 0, 0.1);' : '';
        const textColor = isCurrentPlayer ? '#00FF00' : 'white';
        
        // Get avatar for this entry
        let avatarHtml = 'üèÉ'; // Default emoji
        if (entry.avatar) {
            if (entry.avatarType === 'image' && entry.avatar) {
                avatarHtml = `<img src="${entry.avatar}" style="width: 20px; height: 20px; border-radius: 50%; object-fit: cover; vertical-align: middle; margin-right: 6px;">`;
            } else {
                avatarHtml = `<span style="font-size: 16px; margin-right: 6px;">${entry.avatar || 'üèÉ'}</span>`;
            }
        }
        
        tbody.innerHTML += `
            <tr style="${rowStyle}">
                <td style="padding: 8px; color: ${textColor}; font-size: 14px;">${rankDisplay}</td>
                <td style="padding: 8px; color: ${textColor}; font-size: 14px;">
                    ${avatarHtml}<span>${entry.playerName || 'Anonymous'}</span>
                </td>
                <td style="padding: 8px; text-align: right; color: ${textColor}; font-size: 14px; font-weight: bold;">${entry.score.toLocaleString()}</td>
                <td style="padding: 8px; text-align: center; color: ${textColor}; font-size: 12px;">${entry.character}</td>
            </tr>
        `;
    });
    
    // Update player rank display
    if (playerGlobalRank && rankDisplay) {
        rankDisplay.textContent = `üèÜ Your Global Rank: #${playerGlobalRank} out of ${globalLeaderboard.length} players`;
    } else if (rankDisplay) {
        rankDisplay.textContent = `üåç ${globalLeaderboard.length} players competing worldwide`;
    }
}

// Refresh global leaderboard in settings
function refreshSettingsGlobalLeaderboard() {
    const button = event.target;
    const originalText = button.textContent;
    
    button.textContent = 'üîÑ Loading...';
    button.disabled = true;
    
    loadGlobalLeaderboard();
    
    setTimeout(() => {
        updateSettingsGlobalLeaderboard();
        button.textContent = originalText;
        button.disabled = false;
    }, 1500);
}

// Initialize settings global leaderboard when tab is opened
function initSettingsGlobalLeaderboard() {
    if (cloudSaveEnabled) {
        loadGlobalLeaderboard();
        setTimeout(updateSettingsGlobalLeaderboard, 1000);
    } else {
        const tbody = document.getElementById('settingsGlobalLeaderboardBody');
        const rankDisplay = document.getElementById('settingsGlobalRankText');
        
        if (tbody) {
            tbody.innerHTML = `
                <tr>
                    <td colspan="4" style="text-align: center; padding: 30px; color: #ccc;">
                        ‚òÅÔ∏è Cloud save required for global leaderboard<br>
                        <small>Sign in with Google to compete globally!</small>
                    </td>
                </tr>
            `;
        }
        
        if (rankDisplay) {
            rankDisplay.textContent = "‚òÅÔ∏è Sign in to see your global rank";
        }
    }
}
        

        
// ==================== TITLE SCREEN SYSTEM ====================
// Title screen, animations, and initial game presentation
// Dependencies: Character System for orbiting characters
// Functions: initTitleScreen(), updateTitleScreen(), startTitleAnimations(), etc.

// Create particles for title screen
function createTitleScreenParticles() {
    if (!characterTitleScene) return; // Changed from window.titleScene
    
    // Create particles
    const particlesGeometry = new THREE.BufferGeometry();
    const particleCount = 150;
    
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    
    for (let i = 0; i < particleCount; i++) {
        // Position - spread wider for title screen
        positions[i * 3] = (Math.random() - 0.5) * 30;      // x
        positions[i * 3 + 1] = (Math.random() - 0.5) * 20;  // y
        positions[i * 3 + 2] = (Math.random() - 0.5) * 15;  // z (behind characters)
        
        // Color (blue/cyan matching your theme)
        colors[i * 3] = 0.1 + Math.random() * 0.3;          // r
        colors[i * 3 + 1] = 0.4 + Math.random() * 0.4;      // g
        colors[i * 3 + 2] = 0.7 + Math.random() * 0.3;      // b
    }
    
    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    
    const particlesMaterial = new THREE.PointsMaterial({
        size: 0.08,
        transparent: true,
        opacity: 0.6,
        vertexColors: true,
        blending: THREE.AdditiveBlending
    });
    
    const particles = new THREE.Points(particlesGeometry, particlesMaterial);
    particles.userData = {
        originalPositions: positions.slice()
    };
    
    characterTitleScene.add(particles); // Changed from window.titleScene
    characterTitleScene.userData.particles = particles; // Changed from window.titleScene
    
    debug('‚ú® Title screen particles created!'); // Debug log
}

// Animate title screen particles
function animateTitleParticles() {
    if (!characterTitleScene || !characterTitleScene.userData.particles) return; // Changed scene names
    
    const particles = characterTitleScene.userData.particles; // Changed scene name
    const positions = particles.geometry.attributes.position.array;
    const originalPositions = particles.userData.originalPositions;
    
    for (let i = 0; i < positions.length; i += 3) {
        // Gentle floating motion
        positions[i] = originalPositions[i] + Math.sin(frameCount * 0.008 + i * 0.1) * 0.15;
        positions[i + 1] = originalPositions[i + 1] + Math.cos(frameCount * 0.006 + i * 0.05) * 0.1;
        positions[i + 2] = originalPositions[i + 2] + Math.sin(frameCount * 0.004 + i * 0.02) * 0.05;
    }
    
    particles.geometry.attributes.position.needsUpdate = true;
}

// Animate title screen particles (time-based)
function animateTitleParticles() {
    if (!characterTitleScene || !characterTitleScene.userData.particles) return;
    
    const particles = characterTitleScene.userData.particles;
    const positions = particles.geometry.attributes.position.array;
    const originalPositions = particles.userData.originalPositions;
    
    // Use Date.now() for time-based animation instead of frameCount
    const time = Date.now() * 0.001; // Convert to seconds
    
    for (let i = 0; i < positions.length; i += 3) {
        // Gentle floating motion using time
        positions[i] = originalPositions[i] + Math.sin(time * 0.8 + i * 0.1) * 0.15;
        positions[i + 1] = originalPositions[i + 1] + Math.cos(time * 0.6 + i * 0.05) * 0.1;
        positions[i + 2] = originalPositions[i + 2] + Math.sin(time * 0.4 + i * 0.02) * 0.05;
    }
    
    particles.geometry.attributes.position.needsUpdate = true;
}

// Function to initialize the title screen with orbiting characters
function initTitleScreen() {

    // Create a new scene for the character orbits
    characterTitleScene = new THREE.Scene();
    characterTitleScene.background = null; // Transparent background
    
    // Create a camera for this scene
    characterTitleCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    characterTitleCamera.position.set(0, 0, 5);
    
    // Create a renderer for the title canvas
    const titleCanvas = document.getElementById('titleCanvas');
    titleRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    titleRenderer.setSize(window.innerWidth, window.innerHeight);
    titleRenderer.setClearColor(0x000000, 0); // Transparent background
    titleRenderer.domElement.style.position = 'absolute';
    titleRenderer.domElement.style.top = '0';
    titleRenderer.domElement.style.left = '0';
    titleRenderer.domElement.style.width = '100%';
    titleRenderer.domElement.style.height = '100%';
    titleRenderer.domElement.style.zIndex = '1';
    titleRenderer.domElement.style.pointerEvents = 'none'; // Allow clicks to pass through
    titleCanvas.appendChild(titleRenderer.domElement);
    debug('Title renderer canvas added to DOM'); // Debug log
    
    // Add lights to the title scene
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    characterTitleScene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    characterTitleScene.add(directionalLight);
    
    // Create a center sphere for characters to orbit
    const centerGeometry = new THREE.SphereGeometry(0.5, 32, 32);
    const centerMaterial = new THREE.MeshStandardMaterial({
        color: 0x004e92,
        metalness: 0.8,
        roughness: 0.2,
        emissive: 0x004e92,
        emissiveIntensity: 0.5
    });
    orbitCenter = new THREE.Mesh(centerGeometry, centerMaterial);
    characterTitleScene.add(orbitCenter);
    
    // Add glow effect to center sphere
    const glowGeometry = new THREE.SphereGeometry(0.65, 32, 32);
    const glowMaterial = new THREE.MeshBasicMaterial({
        color: 0x00a2ff,
        transparent: true,
        opacity: 0.3,
        side: THREE.BackSide
    });
    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
    orbitCenter.add(glow);
    
    // Create orbit ring viewed from top
    const ringGeometry = new THREE.TorusGeometry(3.2, 0.04, 16, 100);
    const ringMaterial = new THREE.MeshBasicMaterial({
        color: 0x00a2ff,
        transparent: true,
        opacity: 0.4
    });
    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
    characterTitleScene.add(ring);
    
    // Create character models and place them in orbit
    createTitleCharacters();
    
    // Setup title screen animation
    function animateTitleScreen() {
        requestAnimationFrame(animateTitleScreen);
        
        if (gameState === "title" && titleRenderer && characterTitleScene && characterTitleCamera) {
            // ADD THIS LINE - increment frameCount for animations
            frameCount++;

            // Rotate the center sphere
            if (orbitCenter) {
                orbitCenter.rotation.y += 0.003;
                orbitCenter.rotation.x += 0.001;
            }
            
            // Rotate ring clockwise when viewed from top
            characterTitleScene.children.forEach(child => {
                if (child.geometry && child.geometry.parameters && child.geometry.parameters.tube !== undefined) {
                    child.rotation.z -= 0.001;
                }
            });
            
            // Orbit and rotate each character
            titleCharacterModels.forEach((charObj, index) => {
                if (charObj && charObj.model) {
                    // Calculate perfect equal spacing angle
                    const baseAngle = (frameCount * 0.003) + (index * (Math.PI * 2 / characterNames.length));
                    const radius = charObj.radius;
                    
                    // Move in circular path with perfect equal spacing
                    charObj.model.position.x = Math.cos(baseAngle) * radius;
                    charObj.model.position.y = Math.sin(baseAngle) * radius;
                    charObj.model.position.z = 0;
                    
                    // Update stored angle for other calculations
                    charObj.angle = baseAngle;
                    
                    // Make character face outward toward viewer
                    if (charObj && charObj.model) {
                        try {
                            charObj.model.lookAt(charObj.model.position.x, charObj.model.position.y, 5);
                        } catch (error) {
                            debugWarn('Error making character face outward:', error);
                            charObj.model.rotation.z = 0;
                        }
                    }
                }
            });
            
            // ADD PARTICLE ANIMATION HERE
animateTitleParticles();

// Render the scene
titleRenderer.render(characterTitleScene, characterTitleCamera);
        }
    }

    // Create particles for title screen
createTitleScreenParticles();
    
    // Start the animation once
    animateTitleScreen();
    
   // Create floating particles (keeping the CSS particles too!)
if (typeof createTitleParticles === 'function') {
    createTitleParticles();
} else {
    debug('CSS particles already handling title screen effects');
}
    
    // Add event listener to the start button
setTimeout(() => {
    const startButton = document.getElementById('titleStartButton');
    if (startButton) {
        // Remove any existing listeners first
        startButton.replaceWith(startButton.cloneNode(true));
        const newStartButton = document.getElementById('titleStartButton');
        
        newStartButton.addEventListener('click', function() {
            debug('Start button clicked!');
            
            // Stop particles when leaving title screen (if function exists)
            if (typeof clearTitleParticles === 'function') {
                clearTitleParticles();
            }
            
            // Hide title screen, show main menu
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('mainMenuScreen').style.display = 'flex';
            
            // Initialize main menu (create particles for background)
            initMainMenu();
            
            // Update game state
            gameState = "mainMenu";
        });
        debug('Start button event listener added successfully!');
    } else {
        debug('Start button not found!');
    }
}, 500); // Increased timeout to ensure DOM is ready



}

// Initialize Main Menu
function initMainMenu() {
    // Create floating particles for main menu background
    createMainMenuParticles();
    
    // Setup main menu button event listeners
    setupMainMenuButtons();
}

// Create particles for main menu (similar to title screen)
function createMainMenuParticles() {
    const particleContainer = document.querySelector('#mainMenuScreen .particle-container');
    if (!particleContainer) return;
    
    // Clear existing particles
    particleContainer.innerHTML = '';
    
    // Create CSS particles
    for (let i = 0; i < 50; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.width = Math.random() * 8 + 4 + 'px';
        particle.style.height = particle.style.width;
        particle.style.left = Math.random() * 100 + '%';
        particle.style.animationDelay = Math.random() * 8 + 's';
        particle.style.animationDuration = (Math.random() * 6 + 8) + 's';
        particleContainer.appendChild(particle);
    }
}

// Setup main menu button event listeners
function setupMainMenuButtons() {
    // RUN button - goes to world select
    document.getElementById('runButton').addEventListener('click', function() {
        document.getElementById('mainMenuScreen').style.display = 'none';
        document.getElementById('worldSelectScreen').style.display = 'flex';
        initWorldSelectScreen();
        gameState = "worldSelect";
    });
    
    // CHARACTERS button - goes to character select (no longer leads to world select)
    document.getElementById('charactersButton').addEventListener('click', function() {
        document.getElementById('mainMenuScreen').style.display = 'none';
        document.getElementById('characterSelectScreen').style.display = 'flex';
        initCharacterSelectScreen();
        gameState = "characterSelect";
    });
    
// SHOP button - show shop screen
    document.getElementById('shopButton').addEventListener('click', function() {
        document.getElementById('mainMenuScreen').style.display = 'none';
        document.getElementById('shopScreen').style.display = 'flex';
        initShopScreen();
        gameState = "shop";
    });
    
    // SETTINGS button - will create dedicated settings screen
    document.getElementById('mainMenuSettingsButton').addEventListener('click', function() {
        showMainMenuSettings();
    });
    
    // PROFILE button - show profile screen
    document.getElementById('profileButton').addEventListener('click', function() {
        document.getElementById('mainMenuScreen').style.display = 'none';
        document.getElementById('profileScreen').style.display = 'flex';
        initProfileScreen();
        gameState = "profile";
    });
}

// Show main menu settings screen
function showMainMenuSettings() {
    document.getElementById('mainMenuScreen').style.display = 'none';
    document.getElementById('mainMenuSettingsScreen').style.display = 'flex';
    gameState = "mainMenuSettings";
    
    // Initialize settings screen
    initMainMenuSettings();
}

// Initialize main menu settings screen
function initMainMenuSettings() {
    // Update audio checkbox states
    document.getElementById('mainMenuMusicCheckbox').checked = backgroundMusicEnabled;
    document.getElementById('mainMenuSoundCheckbox').checked = soundEffectsEnabled;
    
    // Update auth status display
    updateAuthStatusDisplay();
    
    // Setup event listeners
    setupMainMenuSettingsListeners();
}

// Update authentication status display
function updateAuthStatusDisplay() {
    const authDisplay = document.getElementById('authStatusDisplay');
    const googleBtn = document.getElementById('googleAuthBtn');
    
    // Check if user is signed in with Google (if Firebase is available)
    if (typeof firebase !== 'undefined' && firebase.auth) {
        const currentUser = firebase.auth().currentUser;
        const isSignedIn = currentUser && !currentUser.isAnonymous;
        
        if (isSignedIn) {
            authDisplay.innerHTML = `<p style="color: #34C759; font-size: 14px;">‚úÖ Signed in as ${currentUser.displayName}<br><small style="color: #999;">Your progress syncs across all devices!</small></p>`;
            googleBtn.textContent = 'üîì Sign Out';
            googleBtn.style.background = '#666';
        } else {
            authDisplay.innerHTML = `<p style="color: #FF9500; font-size: 14px;">‚ö†Ô∏è Not signed in<br><small style="color: #999;">Sign in to sync progress across devices</small></p>`;
            googleBtn.textContent = 'üîó Sign in with Google';
            googleBtn.style.background = '#4285f4';
        }
    } else {
        authDisplay.innerHTML = `<p style="color: #999; font-size: 14px;">üì± Use save codes to transfer progress</p>`;
        googleBtn.style.display = 'none';
    }
}

// Setup main menu settings event listeners
function setupMainMenuSettingsListeners() {
    // Back button
    document.getElementById('backToMainMenuFromSettings').addEventListener('click', function() {
        document.getElementById('mainMenuSettingsScreen').style.display = 'none';
        document.getElementById('mainMenuScreen').style.display = 'flex';
        gameState = "mainMenu";
    });
    
    // Settings tab switching
    document.querySelectorAll('.settings-tab').forEach(tab => {
        tab.addEventListener('click', function() {
            // Remove active class from all tabs
            document.querySelectorAll('.settings-tab').forEach(t => {
                t.classList.remove('active');
                t.style.background = '#666';
            });
            
            // Hide all tab content
            document.querySelectorAll('.settings-tab-content').forEach(content => {
                content.style.display = 'none';
            });
            
            // Activate clicked tab
            this.classList.add('active');
            this.style.background = '#2196F3';
            
            // Show corresponding content
            const tabName = this.getAttribute('data-tab');
            document.getElementById(`settings-${tabName}`).style.display = 'block';
            
            // Initialize global leaderboard when tab is opened
            if (tabName === 'leaderboard') {
                initSettingsGlobalLeaderboard();
            }
        });
    });
    
    // Audio settings
    document.getElementById('mainMenuMusicCheckbox').addEventListener('change', function() {
        backgroundMusicEnabled = this.checked;
        saveGameData('settings_change');
    });
    
    document.getElementById('mainMenuSoundCheckbox').addEventListener('change', function() {
        soundEffectsEnabled = this.checked;
        saveGameData('settings_change');
    });
    
    // Save code buttons
    document.getElementById('generateSaveCodeBtn').addEventListener('click', showSaveCode);
    document.getElementById('restoreSaveCodeBtn').addEventListener('click', showRestoreCode);
    
    // Google auth button
    document.getElementById('googleAuthBtn').addEventListener('click', function() {
        if (typeof firebase !== 'undefined' && firebase.auth) {
            const currentUser = firebase.auth().currentUser;
            const isSignedIn = currentUser && !currentUser.isAnonymous;
            
            if (isSignedIn) {
                signOutGoogle();
            } else {
                signInWithGoogle();
            }
            
            // Update display after auth change
            setTimeout(updateAuthStatusDisplay, 1000);
        }
    });
    
    // Mod mode
    document.getElementById('mainMenuModModeBtn').addEventListener('click', function() {
        const password = document.getElementById('mainMenuModPassword').value;
        
        if (password === '5050') {
            modModeEnabled = !modModeEnabled;
            saveGameData('mod_toggle');
            
            if (modModeEnabled) {
                showModModeNotification(true);
                this.textContent = 'Disable';
                this.style.background = '#F44336';
            } else {
                showModModeNotification(false);
                this.textContent = 'Enable';
                this.style.background = '#9C27B0';
            }
            
            document.getElementById('mainMenuModPassword').value = '';
        } else {
            showModModeNotification(false, true); // true = wrong password
        }
    });
    
    // Reset data
    document.getElementById('mainMenuResetDataBtn').addEventListener('click', function() {
        if (confirm('‚ö†Ô∏è Are you sure you want to reset ALL game data? This cannot be undone!')) {
            if (confirm('üö® This will delete all progress, unlocks, and settings. Continue?')) {
                // Reset all game data
                localStorage.clear();
                alert('‚úÖ All game data has been reset. The page will now reload.');
                location.reload();
            }
        }
    });
}

// Show character selected notification
function showCharacterSelectedNotification(characterName) {
    // Create notification element
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        background: linear-gradient(135deg, #4CAF50, #45a049);
        color: white;
        padding: 20px 30px;
        border-radius: 15px;
        font-size: 18px;
        font-weight: bold;
        text-align: center;
        z-index: 5000;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        border: 2px solid rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(10px);
        transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        pointer-events: none;
    `;
    
    notification.innerHTML = `
        <div style="font-size: 32px; margin-bottom: 8px;">‚úÖ</div>
        <div style="text-transform: capitalize; text-shadow: 0 2px 4px rgba(0,0,0,0.3);">
            ${characterName} Selected!
        </div>
    `;
    
    document.body.appendChild(notification);
    
    // Animate in
    requestAnimationFrame(() => {
        notification.style.transform = 'translate(-50%, -50%) scale(1)';
        notification.style.opacity = '1';
    });
    
    // Animate out and remove
    setTimeout(() => {
        notification.style.transform = 'translate(-50%, -50%) scale(0.8)';
        notification.style.opacity = '0';
        
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 300);
    }, 1500);
}

// Show world selected notification (for shop)
function showWorldSelectedNotification(worldName) {
    // Create notification element
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        background: linear-gradient(135deg, #FF9800, #F57C00);
        color: white;
        padding: 20px 30px;
        border-radius: 15px;
        font-size: 18px;
        font-weight: bold;
        text-align: center;
        z-index: 5000;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        border: 2px solid rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(10px);
        transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        pointer-events: none;
    `;
    
    notification.innerHTML = `
        <div style="font-size: 32px; margin-bottom: 8px;">üåç</div>
        <div style="text-shadow: 0 2px 4px rgba(0,0,0,0.3);">
            ${worldName} Selected!
        </div>
    `;
    
    document.body.appendChild(notification);
    
    // Animate in
    requestAnimationFrame(() => {
        notification.style.transform = 'translate(-50%, -50%) scale(1)';
        notification.style.opacity = '1';
    });
    
    // Animate out and remove
    setTimeout(() => {
        notification.style.transform = 'translate(-50%, -50%) scale(0.8)';
        notification.style.opacity = '0';
        
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 300);
    }, 1500);
}

// Show purchase success notification
function showPurchaseSuccessNotification(itemName, itemType) {
    const emoji = itemType === 'character' ? 'üë§' : 'üåç';
    
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        background: linear-gradient(135deg, #9C27B0, #7B1FA2);
        color: white;
        padding: 20px 30px;
        border-radius: 15px;
        font-size: 18px;
        font-weight: bold;
        text-align: center;
        z-index: 5000;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        border: 2px solid rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(10px);
        transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        pointer-events: none;
    `;
    
    notification.innerHTML = `
        <div style="font-size: 32px; margin-bottom: 8px;">${emoji}</div>
        <div style="text-transform: capitalize; text-shadow: 0 2px 4px rgba(0,0,0,0.3);">
            ${itemName} Unlocked!
        </div>
    `;
    
    document.body.appendChild(notification);
    
    // Animate in
    requestAnimationFrame(() => {
        notification.style.transform = 'translate(-50%, -50%) scale(1)';
        notification.style.opacity = '1';
    });
    
    // Animate out and remove
    setTimeout(() => {
        notification.style.transform = 'translate(-50%, -50%) scale(0.8)';
        notification.style.opacity = '0';
        
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 300);
    }, 2000); // Show slightly longer for purchases
}


// Initialize shop screen
function initShopScreen() {
    // Update coins display
    document.getElementById('shopCoinsDisplay').textContent = totalCoins;
    
    // Populate characters list
    populateShopCharacters();
    
    // Populate worlds list
    populateShopWorlds();
    
    // Setup shop event listeners
    setupShopListeners();
}

// Populate shop characters
function populateShopCharacters() {
    const charactersList = document.getElementById('shop-characters');
    charactersList.innerHTML = '';
    
    characterNames.forEach(charName => {
        const isUnlocked = unlockedCharacters[charName] || modModeEnabled;
        const cost = characterCosts[charName] || 100; // Default cost if not defined
        
        const characterItem = document.createElement('div');
        characterItem.style.cssText = `
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            border: 1px solid ${isUnlocked ? '#4CAF50' : '#666'};
        `;
        
        characterItem.innerHTML = `
            <h4 style="color: white; margin: 0 0 10px 0; text-transform: capitalize;">${charName}</h4>
            <div style="color: ${isUnlocked ? '#4CAF50' : '#FFD700'}; font-size: 14px; margin-bottom: 10px;">
                ${isUnlocked ? '‚úÖ Unlocked' : `üí∞ ${cost} coins`}
            </div>
            ${!isUnlocked ? `
                <button onclick="purchaseCharacter('${charName}')" 
                    style="background: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px;">
                    Purchase
                </button>
            ` : `
                <button onclick="selectCharacterFromShop('${charName}')" 
                    style="background: #2196F3; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px;">
                    Select
                </button>
            `}
        `;
        
        charactersList.appendChild(characterItem);
    });
}

// Populate shop worlds
function populateShopWorlds() {
    const worldsList = document.getElementById('shop-worlds');
    worldsList.innerHTML = '';
    
    availableWorlds.forEach(world => {
        const isUnlocked = unlockedWorlds[world.id] || modModeEnabled;
        
        const worldItem = document.createElement('div');
        worldItem.style.cssText = `
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            border: 1px solid ${isUnlocked ? '#4CAF50' : '#666'};
        `;
        
        worldItem.innerHTML = `
            <h4 style="color: white; margin: 0 0 10px 0;">${world.name}</h4>
            <p style="color: #ccc; font-size: 12px; margin: 0 0 10px 0;">${world.description}</p>
            <div style="color: ${isUnlocked ? '#4CAF50' : '#FFD700'}; font-size: 14px; margin-bottom: 10px;">
                ${isUnlocked ? '‚úÖ Unlocked' : `üí∞ ${world.cost} coins`}
            </div>
            ${!isUnlocked ? `
                <button onclick="purchaseWorld('${world.id}')" 
                    style="background: #FF9800; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px;">
                    Purchase
                </button>
            ` : `
                <button onclick="selectWorldFromShop('${world.id}')" 
                    style="background: #2196F3; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px;">
                    Select
                </button>
            `}
        `;
        
        worldsList.appendChild(worldItem);
    });
}

// Setup shop event listeners
function setupShopListeners() {
    // Back button
    document.getElementById('backToMainMenuFromShop').addEventListener('click', function() {
        document.getElementById('shopScreen').style.display = 'none';
        document.getElementById('mainMenuScreen').style.display = 'flex';
        gameState = "mainMenu";
    });
    
    // Shop tab switching
    document.querySelectorAll('.shop-tab').forEach(tab => {
        tab.addEventListener('click', function() {
            // Remove active class from all tabs
            document.querySelectorAll('.shop-tab').forEach(t => {
                t.classList.remove('active');
                t.style.background = '#666';
            });
            
            // Hide all tab content
            document.querySelectorAll('.shop-tab-content').forEach(content => {
                content.style.display = 'none';
            });
            
            // Activate clicked tab
            this.classList.add('active');
            this.style.background = '#2196F3';
            
            // Show corresponding content
            const tabName = this.getAttribute('data-tab');
            const content = document.getElementById(`shop-${tabName}`);
            content.style.display = tabName === 'drip' ? 'block' : 'grid';
            
            // Add hover effect for DRiP preview
            if (tabName === 'drip') {
                setupDripPreviewEffects();
            }
        });
    });
}

// Purchase character from shop
function purchaseCharacter(charName) {
    const cost = characterCosts[charName] || 100;
    
    if (unlockedCharacters[charName]) {
        alert('‚úÖ Character already unlocked!');
        return;
    }
    
    if (totalCoins >= cost) {
        totalCoins -= cost;
        unlockedCharacters[charName] = true;
        updateTotalCoins();
        saveGameData('character_purchase');
        showPurchaseSuccessNotification(charName, 'character');
        
        // Refresh shop display
        initShopScreen();
    } else {
showInsufficientFundsNotification(cost, 'character');
    }
}

// Purchase world from shop
function purchaseWorld(worldId) {
    const world = availableWorlds.find(w => w.id === worldId);
    if (!world) return;
    
    if (unlockedWorlds[worldId]) {
        alert('‚úÖ World already unlocked!');
        return;
    }
    
    if (totalCoins >= world.cost) {
        totalCoins -= world.cost;
        unlockedWorlds[worldId] = true;
        updateTotalCoins();
        saveGameData('world_purchase');
        showPurchaseSuccessNotification(world.name, 'world');
        
        // Refresh shop display
        initShopScreen();
    } else {
showInsufficientFundsNotification(world.cost, 'world');
    }
}

// Select character from shop
function selectCharacterFromShop(charName) {
    currentCharacter = charName;
    createPlayer();
    showCharacterSelectedNotification(charName);
}

// Select world from shop
function selectWorldFromShop(worldId) {
    const world = availableWorlds.find(w => w.id === worldId);
    if (world) {
        currentWorld = worldId;
        showWorldSelectedNotification(world.name);
    }
}

// Initialize DRiP iframe
function initDripIframe() {
    const container = document.getElementById('dripIframeContainer');
    const loadingMessage = document.getElementById('dripLoadingMessage');
    
    if (!container) return;
    
    // Detect if mobile device
    const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
    
    // Create iframe
    const iframe = document.createElement('iframe');
    iframe.src = 'https://drip.haus/alangnft/home';
    iframe.style.cssText = `
        width: 100%;
        height: 100%;
        border: none;
        border-radius: 10px;
        background: white;
    `;
    
    // Handle iframe load events
    iframe.onload = function() {
        // Hide loading message when iframe loads
        if (loadingMessage) {
            loadingMessage.style.display = 'none';
        }
    };
    
    iframe.onerror = function() {
        // Show error message if iframe fails to load
        if (loadingMessage) {
            loadingMessage.innerHTML = `
                <div style="color: #ff6b6b;">‚ùå Unable to load DRiP channel</div>
                <div style="margin-top: 10px; font-size: 12px;">
                    <a href="https://drip.haus/alangnft/home" target="_blank" style="color: #00a2ff;">
                        Click here to visit my DRiP profile directly
                    </a>
                </div>
            `;
        }
    };
    
    // Add iframe to container
    container.appendChild(iframe);
    
    // Set different height for mobile
    if (isMobileDevice) {
        container.style.height = '350px';
    }
    
    debug('DRiP iframe initialized');
}

// Setup DRiP preview hover effects
function setupDripPreviewEffects() {
    const container = document.getElementById('dripPreviewContainer');
    const overlay = document.getElementById('dripClickOverlay');
    
    if (container && overlay) {
        container.addEventListener('mouseenter', function() {
            overlay.style.opacity = '1';
        });
        
        container.addEventListener('mouseleave', function() {
            overlay.style.opacity = '0';
        });
        
        // Add click feedback
        container.addEventListener('mousedown', function() {
            this.style.transform = 'scale(0.98)';
        });
        
        container.addEventListener('mouseup', function() {
            this.style.transform = 'scale(1.02)';
        });
    }
}

// Initialize profile screen
function initProfileScreen() {
    // Update profile display
    updateProfileDisplay();
    
    // Setup profile event listeners
    setupProfileListeners();
}

// Update profile display
function updateProfileDisplay() {
    // Initialize profile data if missing
    initializeProfileData();
    
    // Update player name with custom username
    const nameElement = document.getElementById('profilePlayerName');
    nameElement.textContent = currentProfile.username || 'Anonymous Runner';
    
    // Update avatar
    setAvatarImage(currentProfile.avatarData || 'üèÉ');
    
    // Update high score - use the highest score from profile or leaderboard
    let playerHighScore = 0;
    
    // Check profile's stored high score
    if (currentProfile.highScore) {
        playerHighScore = currentProfile.highScore;
    }
    
    // Also check local leaderboard for this player's best score
    const playerName = currentProfile.username || 'Anonymous';
    const leaderboardData = JSON.parse(localStorage.getItem('runningBlitzLeaderboard') || '[]');
    const playerScores = leaderboardData.filter(entry => entry.name === playerName);
    
    if (playerScores.length > 0) {
        const leaderboardHighScore = Math.max(...playerScores.map(entry => entry.score));
        playerHighScore = Math.max(playerHighScore, leaderboardHighScore);
    }
    
    document.getElementById('profileHighScore').textContent = playerHighScore.toLocaleString();
    
    // Update total coins
    document.getElementById('profileTotalCoins').textContent = totalCoins;
    
    // Count unlocked characters
    const unlockedCharCount = characterNames.filter(char => unlockedCharacters[char]).length;
    document.getElementById('profileCharactersUnlocked').textContent = unlockedCharCount;
    
    // Count unlocked worlds
    const unlockedWorldCount = availableWorlds.filter(world => unlockedWorlds[world.id]).length;
    document.getElementById('profileWorldsUnlocked').textContent = unlockedWorldCount;
}

// Setup profile event listeners
function setupProfileListeners() {
    document.getElementById('backToMainMenuFromProfile').addEventListener('click', function() {
        document.getElementById('profileScreen').style.display = 'none';
        document.getElementById('mainMenuScreen').style.display = 'flex';
        gameState = "mainMenu";
    });
}

// Create character models for the title screen
function createTitleCharacters() {
    // Clear existing models
    titleCharacterModels.forEach(charObj => {
        characterTitleScene.remove(charObj.model);
    });
    titleCharacterModels = [];
    
    // Create each character
    characterNames.forEach((charType, index) => {
        // Create the character model
        let charModel;
        switch (charType) {
            // CHARACTER SELECTION SWITCH INJECTION POINT - Package manager will add cases here
    case "apple": charModel = createAppleCharacter(); break;
    case "carrot": charModel = createCarrotCharacter(); break;
    case "pumpkin": charModel = createPumpkinCharacter(); break;
    case "happyface": charModel = createHappyFaceCharacter(); break;
    case "monster": charModel = createMonsterCharacter(); break;
    case "atom": charModel = createAtomCharacter(); break;
    case "slime": charModel = createSlimeCharacter(); break;
    case "ufo": charModel = createUFOCharacter(); break;
    case "robot": charModel = createRobotCharacter(); break;
    case "dragon": charModel = createDragonCharacter(); break;
    case "ghost": charModel = createGhostCharacter(); break;
    case "creature": charModel = createCreatureCharacter(); break;
    // END CHARACTER SELECTION SWITCH INJECTION POINT
            default:
                debugWarn(`Unknown character type: ${charType}, using happyface instead`);
                charModel = createHappyFaceCharacter();
                break;
        }
        
        // Safety check
        if (!charModel) {
            console.error(`Failed to create character: ${charType}, using happyface instead`);
            charModel = createHappyFaceCharacter();
        }
        
        // Calculate position in circular orbit
        const startAngle = (index / characterNames.length) * Math.PI * 2;
        const orbitRadius = 3.2;
        const orbitSpeed = 0.003;

        // Position character in top-down circular orbit
        charModel.position.x = Math.cos(startAngle) * orbitRadius;
        charModel.position.y = Math.sin(startAngle) * orbitRadius;
        charModel.position.z = 0;

        // Scale characters smaller for cleaner look
        charModel.scale.set(0.7, 0.7, 0.7);
        
        // Add to scene
        characterTitleScene.add(charModel);
        
        // Store model and orbit parameters
        titleCharacterModels.push({
            model: charModel,
            type: charType,
            angle: startAngle,
            radius: orbitRadius,
            speed: orbitSpeed
        });
    });
}

        // ==================== CHARACTER SELECTION SYSTEM ====================
// Character selection screen and character preview functionality
// Dependencies: characters.js, THREE.js
// Functions: initCharacterSelectScreen(), selectCharacter(), previewCharacter(), etc.

        // Initialize Character Selection Screen
function initCharacterSelectScreen() {
    // Clear existing canvas content
    const selectCanvas = document.getElementById('characterSelectCanvas');
    selectCanvas.innerHTML = '';
    
    // Create a new scene for character display
    const characterSelectScene = new THREE.Scene();
    characterSelectScene.background = null; // Transparent background
    
    // Create a camera
const selectCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
selectCamera.position.set(0, 0, 3);
    
    // Create a renderer for full screen with background effects
const characterSelectRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
characterSelectRenderer.setSize(window.innerWidth, window.innerHeight);
characterSelectRenderer.setClearColor(0x000000, 0); // Transparent background
selectCanvas.appendChild(characterSelectRenderer.domElement);
    
    // Store references globally so they can be accessed by animation loop
window.characterSelectScene = characterSelectScene;
window.selectCamera = selectCamera;
window.characterSelectRenderer = characterSelectRenderer;
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            characterSelectScene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            characterSelectScene.add(directionalLight);
            
            // Create background effects
            createBackgroundEffects(characterSelectScene);
            
            // Clear existing character models if they exist
if (characterSelectModels && characterSelectModels.length > 0) {
    characterSelectModels.forEach(charObj => {
        if (charObj.model && charObj.model.parent) {
            charObj.model.parent.remove(charObj.model);
        }
    });
}

// Create all character models fresh
characterSelectModels = [];

// Filter to only show unlocked characters (unless mod mode is enabled)
const visibleCharacters = modModeEnabled ? characterNames : characterNames.filter(char => unlockedCharacters[char]);

visibleCharacters.forEach(charType => {
    let charModel;
    
    try {
        switch (charType) {
    // CHARACTER SELECTION SWITCH INJECTION POINT - Package manager will add cases here
    case "apple": charModel = createAppleCharacter(); break;
    case "carrot": charModel = createCarrotCharacter(); break;
    case "pumpkin": charModel = createPumpkinCharacter(); break;
    case "happyface": charModel = createHappyFaceCharacter(); break;
    case "monster": charModel = createMonsterCharacter(); break;
    case "atom": charModel = createAtomCharacter(); break;
    case "slime": charModel = createSlimeCharacter(); break;
    case "ufo": charModel = createUFOCharacter(); break;
    case "robot": charModel = createRobotCharacter(); break;
    case "dragon": charModel = createDragonCharacter(); break;
    case "ghost": charModel = createGhostCharacter(); break;
    case "creature": charModel = createCreatureCharacter(); break;
    // END CHARACTER SELECTION SWITCH INJECTION POINT
    default:
        debugWarn(`Character ${charType} not yet extracted - using Happy Face`);
        charModel = createHappyFaceCharacter();
        break;
}
        
        // Safety check
        if (!charModel) {
            console.error(`Failed to create character: ${charType}, using apple instead`);
            charModel = createAppleCharacter();
        }

        debug(`‚úÖ Created character: ${charType}`, charModel);
        
        // Scale and position
charModel.scale.set(1.5, 1.5, 1.5);
charModel.position.set(0, 0, 0);
charModel.visible = false; // Hide all initially
        
        // Add to scene
        characterSelectScene.add(charModel);
        
        characterSelectModels.push({
            model: charModel,
            type: charType
        });
        
        debug(`‚úÖ Created character: ${charType}`);
        
    } catch (error) {
        console.error(`‚ùå Error creating character ${charType}:`, error);
        
        // Fallback to apple character
        charModel = createAppleCharacter();
        charModel.scale.set(1.5, 1.5, 1.5);
        charModel.position.set(0, 0, 0);
        charModel.visible = false;
        characterSelectScene.add(charModel);
        
        characterSelectModels.push({
            model: charModel,
            type: charType
        });
    }
});

// Ensure selectedCharacterIndex is valid
if (selectedCharacterIndex >= characterSelectModels.length) {
    selectedCharacterIndex = 0;
}

// Show the correct initial character
characterSelectModels[selectedCharacterIndex].model.visible = true;
updateCharacterInfo();
            
            // Clear any existing animation loop
if (window.characterSelectAnimationId) {
    cancelAnimationFrame(window.characterSelectAnimationId);
}

// Animation for character selection screen
function animateCharacterSelect() {
    window.characterSelectAnimationId = requestAnimationFrame(animateCharacterSelect);
    
    if (gameState === "characterSelect") {
        // Rotate the displayed character
        if (characterSelectModels && characterSelectModels[selectedCharacterIndex]) {
            const currentModel = characterSelectModels[selectedCharacterIndex].model;
            const currentType = characterSelectModels[selectedCharacterIndex].type;
            
            // Basic rotation
            if (currentModel && currentModel.visible) {
                currentModel.rotation.y += 0.01;
                
                // Apply specific character animations
                animateCharacterModel(currentModel, currentType, frameCount);
            }
        }
        
        // Animate background elements
        if (window.characterSelectScene && window.characterSelectScene.userData.particles) {
            animateBackgroundEffects();
        }
        
        // Render
if (window.characterSelectRenderer && window.characterSelectScene && window.selectCamera) {
    window.characterSelectRenderer.render(window.characterSelectScene, window.selectCamera);
}
    }
}

// Start animation
animateCharacterSelect();
            
            // Remove any existing event listeners and add fresh ones
const prevBtn = document.getElementById('prevCharacterBtn');
const nextBtn = document.getElementById('nextCharacterBtn');

// Clone buttons to remove all event listeners
const newPrevBtn = prevBtn.cloneNode(true);
const newNextBtn = nextBtn.cloneNode(true);
prevBtn.parentNode.replaceChild(newPrevBtn, prevBtn);
nextBtn.parentNode.replaceChild(newNextBtn, nextBtn);

// Update arrow button visibility based on unlocked characters
updateCharacterArrowVisibility();

// Add fresh event listeners
document.getElementById('prevCharacterBtn').addEventListener('click', function() {
    // Get current visible characters
    const visibleCharacters = modModeEnabled ? characterNames : characterNames.filter(char => unlockedCharacters[char]);
    
    // Hide current model
    if (characterSelectModels[selectedCharacterIndex]) {
        characterSelectModels[selectedCharacterIndex].model.visible = false;
    }
    
    // Find current character in visible list
    const currentChar = characterNames[selectedCharacterIndex];
    const currentVisibleIndex = visibleCharacters.indexOf(currentChar);
    
    // Move to previous visible character
    const newVisibleIndex = (currentVisibleIndex - 1 + visibleCharacters.length) % visibleCharacters.length;
    const newChar = visibleCharacters[newVisibleIndex];
    
    // Update to new character index in full array
    selectedCharacterIndex = characterNames.indexOf(newChar);
    
    // Show new model
    if (characterSelectModels[selectedCharacterIndex]) {
        characterSelectModels[selectedCharacterIndex].model.visible = true;
    }
    
    // Update info display
    updateCharacterInfo();
});

document.getElementById('nextCharacterBtn').addEventListener('click', function() {
    // Get current visible characters
    const visibleCharacters = modModeEnabled ? characterNames : characterNames.filter(char => unlockedCharacters[char]);
    
    // Hide current model
    if (characterSelectModels[selectedCharacterIndex]) {
        characterSelectModels[selectedCharacterIndex].model.visible = false;
    }
    
    // Find current character in visible list
    const currentChar = characterNames[selectedCharacterIndex];
    const currentVisibleIndex = visibleCharacters.indexOf(currentChar);
    
    // Move to next visible character
    const newVisibleIndex = (currentVisibleIndex + 1) % visibleCharacters.length;
    const newChar = visibleCharacters[newVisibleIndex];
    
    // Update to new character index in full array
    selectedCharacterIndex = characterNames.indexOf(newChar);
    
    // Show new model
    if (characterSelectModels[selectedCharacterIndex]) {
        characterSelectModels[selectedCharacterIndex].model.visible = true;
    }
    
    // Update info display
    updateCharacterInfo();
});

function updateCharacterArrowVisibility() {
    const visibleCharacters = modModeEnabled ? characterNames : characterNames.filter(char => unlockedCharacters[char]);
    const prevBtn = document.getElementById('prevCharacterBtn');
    const nextBtn = document.getElementById('nextCharacterBtn');
    
    if (visibleCharacters.length <= 1) {
        prevBtn.style.display = 'none';
        nextBtn.style.display = 'none';
    } else {
        prevBtn.style.display = 'block';
        nextBtn.style.display = 'block';
    }
}
            
            // Back to main menu button
document.getElementById('backToMainMenuFromCharacters').addEventListener('click', function() {
    document.getElementById('characterSelectScreen').style.display = 'none';
    document.getElementById('mainMenuScreen').style.display = 'flex';
    gameState = "mainMenu";
});

// Select character button - just selects character and returns to main menu
document.getElementById('selectCharacterButton').addEventListener('click', function() {
    // Check if character is unlocked
    const selectedChar = characterNames[selectedCharacterIndex];
    
    if (unlockedCharacters[selectedChar] || modModeEnabled) {
        // Set the selected character
        currentCharacter = selectedChar;
        createPlayer(); // Update player model
        
        // Show success notification
        showCharacterSelectedNotification(characterNames[selectedCharacterIndex]);
        
        // Return to main menu
        document.getElementById('characterSelectScreen').style.display = 'none';
        document.getElementById('mainMenuScreen').style.display = 'flex';
        gameState = "mainMenu";
    } else {
        // Character is locked - ask if they want to unlock
        const cost = characterCosts[selectedChar];
        if (confirm(`This character costs ${cost} coins. Do you want to unlock it?`)) {
            tryUnlockCharacter(selectedChar);
            updateCharacterInfo(); // Refresh display after attempt
        }
    }
});
        }

        // ==================== WORLD SELECTION SYSTEM ====================
// World selection screen and world preview functionality
// Dependencies: worlds/forest.js, worlds/desert.js, Character System
// Functions: initWorldSelectScreen(), selectWorld(), previewWorld(), switchWorld(), etc.

        // Initialize World Selection Screen
function initWorldSelectScreen() {
    // Clear existing canvas content
    const selectCanvas = document.getElementById('worldSelectCanvas');
    selectCanvas.innerHTML = '';
    
    // Create a new scene for world preview
    worldSelectScene = new THREE.Scene();
    worldSelectScene.background = null; // Transparent background
    
    // Create a camera
worldSelectCamera = new THREE.PerspectiveCamera(75, 300 / 200, 0.1, 1000);
worldSelectCamera.position.set(0, 2.5, 3); // Higher camera position to see more of the top
worldSelectCamera.lookAt(0, 0, 0); // Make sure camera looks at center
    
    // Create a renderer
worldSelectRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
worldSelectRenderer.setSize(300, 200); // Match the preview box size
worldSelectRenderer.setClearColor(0x000000, 0); // Transparent background

// Style the renderer to fit inside the preview box
worldSelectRenderer.domElement.style.position = 'absolute';
worldSelectRenderer.domElement.style.top = '0';
worldSelectRenderer.domElement.style.left = '0';
worldSelectRenderer.domElement.style.width = '100%';
worldSelectRenderer.domElement.style.height = '100%';
worldSelectRenderer.domElement.style.borderRadius = '15px';

// Add to the preview container instead of the main canvas
const previewContainer = document.getElementById('worldPreview');
previewContainer.appendChild(worldSelectRenderer.domElement);
    
    // Add lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    worldSelectScene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    worldSelectScene.add(directionalLight);
    
    // Create world preview models
    createWorldPreviews();
    
    // Show the correct initial world
    updateWorldDisplay();
    
    // Clear any existing animation loop
    if (window.worldSelectAnimationId) {
        cancelAnimationFrame(window.worldSelectAnimationId);
    }

    // Animation for world selection screen
    function animateWorldSelect() {
        window.worldSelectAnimationId = requestAnimationFrame(animateWorldSelect);
        
        if (gameState === "worldSelect") {
            // Rotate the displayed world preview
            if (worldSelectModels && worldSelectModels[selectedWorldIndex]) {
                const currentModel = worldSelectModels[selectedWorldIndex];
                
                if (currentModel && currentModel.visible) {
                    currentModel.rotation.y += 0.005; // Slow, elegant rotation
                    
                    // Add gentle floating motion around the centered position
const baseY = currentModel.userData.baseY || 0;
currentModel.position.y = baseY + Math.sin(frameCount * 0.02) * 0.08; // Smaller floating range
                }
            }
            
            // Render
            if (worldSelectRenderer && worldSelectScene && worldSelectCamera) {
                worldSelectRenderer.render(worldSelectScene, worldSelectCamera);
            }
        }
    }

    // Start animation
    animateWorldSelect();
    
    // Setup navigation buttons
    setupWorldSelectButtons();
}

// Create world preview models
function createWorldPreviews() {
    // Clear existing models
    worldSelectModels.forEach(model => {
        if (model && model.parent) {
            model.parent.remove(model);
        }
    });
    worldSelectModels = [];
    
    availableWorlds.forEach(world => {
        const worldPreview = createWorldPreviewModel(world);
        worldPreview.visible = false; // Hide all initially
        worldSelectScene.add(worldPreview);
        worldSelectModels.push(worldPreview);
    });
    
    // Show the first world
    if (worldSelectModels.length > 0) {
        worldSelectModels[selectedWorldIndex].visible = true;
    }
}

// Create a 3D preview model for a world
function createWorldPreviewModel(world) {
    const previewGroup = new THREE.Group();
    
    if (world.id === 'classic') {
    // Create classic plains preview
    
    // Ground platform
    const groundGeometry = new THREE.BoxGeometry(4, 0.2, 4);
    const groundMaterial = new THREE.MeshStandardMaterial({
        color: world.colors.ground,
        roughness: 0.8
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.position.y = -0.1;
    previewGroup.add(ground);
    
    // Add some grass
    for (let i = 0; i < 8; i++) {
        const grassGeometry = new THREE.ConeGeometry(0.05, 0.3, 4);
        const grassMaterial = new THREE.MeshStandardMaterial({
            color: 0x228B22
        });
        const grass = new THREE.Mesh(grassGeometry, grassMaterial);
        grass.position.set(
            (Math.random() - 0.5) * 3,
            0.05,
            (Math.random() - 0.5) * 3
        );
        previewGroup.add(grass);
    }
    
    // Add a small tree
    const trunkGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.6, 8);
    const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
    trunk.position.set(1, 0.3, 1);
    previewGroup.add(trunk);
    
    const leavesGeometry = new THREE.SphereGeometry(0.4, 8, 8);
    const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
    const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
    leaves.position.set(1, 0.8, 1);
    previewGroup.add(leaves);
    
    // Add some flowers
    for (let i = 0; i < 5; i++) {
        const flowerGeometry = new THREE.SphereGeometry(0.03, 6, 6);
        const flowerColors = [0xFF0000, 0xFFFF00, 0xFF00FF, 0xFFFFFF];
        const flowerMaterial = new THREE.MeshStandardMaterial({
            color: flowerColors[Math.floor(Math.random() * flowerColors.length)]
        });
        const flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
        flower.position.set(
            (Math.random() - 0.5) * 2,
            0.1,
            (Math.random() - 0.5) * 2
        );
        previewGroup.add(flower);
    }
} else if (world.id === 'forest') {
    // Create forest preview
    
    // Dark forest ground
    const groundGeometry = new THREE.BoxGeometry(4, 0.2, 4);
    const groundMaterial = new THREE.MeshStandardMaterial({
        color: world.colors.ground,
        roughness: 0.9
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.position.y = -0.1;
    previewGroup.add(ground);
    
    // Add tall pine trees
    for (let i = 0; i < 4; i++) {
        const trunkGeometry = new THREE.CylinderGeometry(0.08, 0.12, 1.2, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.set(
            (Math.random() - 0.5) * 3,
            0.6,
            (Math.random() - 0.5) * 3
        );
        previewGroup.add(trunk);
        
        // Pine cone shape leaves
        const leavesGeometry = new THREE.ConeGeometry(0.5, 1.0, 8);
        const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x1F4F2F });
        const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
        leaves.position.copy(trunk.position);
        leaves.position.y += 0.8;
        previewGroup.add(leaves);
    }
    
    // Add mushrooms
    for (let i = 0; i < 6; i++) {
        const stemGeometry = new THREE.CylinderGeometry(0.03, 0.04, 0.15, 6);
        const stemMaterial = new THREE.MeshStandardMaterial({ color: 0xF5DEB3 });
        const stem = new THREE.Mesh(stemGeometry, stemMaterial);
        stem.position.set(
            (Math.random() - 0.5) * 2,
            0.075,
            (Math.random() - 0.5) * 2
        );
        previewGroup.add(stem);
        
        const capGeometry = new THREE.SphereGeometry(0.06, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
        const capMaterial = new THREE.MeshStandardMaterial({ 
            color: i % 2 === 0 ? 0xFF4500 : 0x8B4513 
        });
        const cap = new THREE.Mesh(capGeometry, capMaterial);
        cap.position.copy(stem.position);
        cap.position.y += 0.12;
        previewGroup.add(cap);
    }
    
    // Add ferns
    for (let i = 0; i < 8; i++) {
        const fernGeometry = new THREE.PlaneGeometry(0.2, 0.3);
        const fernMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x228B22,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.8
        });
        const fern = new THREE.Mesh(fernGeometry, fernMaterial);
        fern.position.set(
            (Math.random() - 0.5) * 3,
            0.15,
            (Math.random() - 0.5) * 3
        );
        fern.rotation.y = Math.random() * Math.PI * 2;
        previewGroup.add(fern);
    }
} else if (world.id === 'desert') {
    // Create desert preview
    
    // Sandy ground
    const groundGeometry = new THREE.BoxGeometry(4, 0.2, 4);
    const groundMaterial = new THREE.MeshStandardMaterial({
        color: world.colors.ground,
        roughness: 0.9
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.position.y = -0.1;
    previewGroup.add(ground);
    
    // Add sand dunes
    for (let i = 0; i < 3; i++) {
        const duneGeometry = new THREE.SphereGeometry(0.8, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
        const duneMaterial = new THREE.MeshStandardMaterial({
            color: 0xF4A460,
            roughness: 0.9
        });
        const dune = new THREE.Mesh(duneGeometry, duneMaterial);
        dune.position.set(
            (Math.random() - 0.5) * 3,
            0,
            (Math.random() - 0.5) * 3
        );
        dune.scale.set(1, 0.5, 1);
        previewGroup.add(dune);
    }
    
    // Add a small cactus
    const cactusGeometry = new THREE.CylinderGeometry(0.1, 0.12, 0.8, 8);
    const cactusMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
    const cactus = new THREE.Mesh(cactusGeometry, cactusMaterial);
    cactus.position.set(1.2, 0.4, 0.8);
    previewGroup.add(cactus);
    
    // Add cactus flower
    const flowerGeometry = new THREE.SphereGeometry(0.05, 6, 6);
    const flowerMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xFF69B4,
        emissive: 0xFF1493,
        emissiveIntensity: 0.3
    });
    const flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
    flower.position.set(1.2, 0.85, 0.8);
    previewGroup.add(flower);
    
    // Add some rocks
    for (let i = 0; i < 4; i++) {
        const rockGeometry = new THREE.DodecahedronGeometry(0.08, 1);
        const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x8B7355 });
        const rock = new THREE.Mesh(rockGeometry, rockMaterial);
        rock.position.set(
            (Math.random() - 0.5) * 2.5,
            0.05,
            (Math.random() - 0.5) * 2.5
        );
        rock.rotation.set(
            Math.random() * Math.PI,
            Math.random() * Math.PI,
            Math.random() * Math.PI
        );
        previewGroup.add(rock);
    }
    
    // Add heat shimmer effect
    const shimmerGeometry = new THREE.PlaneGeometry(4, 0.5);
    const shimmerMaterial = new THREE.MeshBasicMaterial({
        color: 0xFFFFFF,
        transparent: true,
        opacity: 0.1,
        side: THREE.DoubleSide
    });
    const shimmer = new THREE.Mesh(shimmerGeometry, shimmerMaterial);
    shimmer.rotation.x = -Math.PI / 2;
    shimmer.position.y = 0.01;
    previewGroup.add(shimmer);
} else if (world.id === 'underwater') {
    // Create underwater preview
    
    // Ocean floor
    const groundGeometry = new THREE.BoxGeometry(4, 0.2, 4);
    const groundMaterial = new THREE.MeshStandardMaterial({
        color: world.colors.ground,
        roughness: 0.9
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.position.y = -0.1;
    previewGroup.add(ground);
    
    // Add coral pieces
    for (let i = 0; i < 5; i++) {
        const coralGeometry = new THREE.SphereGeometry(0.15, 8, 6);
        const coralColors = [0xFF6B9D, 0xFFA500, 0x00CED1, 0xFFD700];
        const coralMaterial = new THREE.MeshStandardMaterial({
            color: coralColors[Math.floor(Math.random() * coralColors.length)],
            roughness: 0.7
        });
        const coral = new THREE.Mesh(coralGeometry, coralMaterial);
        coral.position.set(
            (Math.random() - 0.5) * 3,
            0.1,
            (Math.random() - 0.5) * 3
        );
        coral.scale.set(1, 0.6, 1);
        previewGroup.add(coral);
    }
    
    // Add seaweed
    for (let i = 0; i < 6; i++) {
        const seaweedGeometry = new THREE.CylinderGeometry(0.02, 0.04, 0.6, 6);
        const seaweedMaterial = new THREE.MeshStandardMaterial({
            color: 0x2F4F2F,
            roughness: 0.8
        });
        const seaweed = new THREE.Mesh(seaweedGeometry, seaweedMaterial);
        seaweed.position.set(
            (Math.random() - 0.5) * 3,
            0.3,
            (Math.random() - 0.5) * 3
        );
        seaweed.rotation.x = (Math.random() - 0.5) * 0.3;
        seaweed.rotation.z = (Math.random() - 0.5) * 0.3;
        previewGroup.add(seaweed);
    }
    
    // Add a fish
    const fishGeometry = new THREE.SphereGeometry(0.1, 8, 6);
    const fishMaterial = new THREE.MeshStandardMaterial({
        color: 0x1E90FF,
        metalness: 0.3,
        roughness: 0.5
    });
    const fish = new THREE.Mesh(fishGeometry, fishMaterial);
    fish.scale.set(1.5, 0.7, 0.5);
    fish.position.set(0.5, 0.8, 0);
    fish.rotation.y = Math.PI / 4;
    previewGroup.add(fish);
    
    // Fish tail
    const tailGeometry = new THREE.ConeGeometry(0.06, 0.15, 4);
    const tail = new THREE.Mesh(tailGeometry, fishMaterial);
    tail.position.set(0.35, 0.8, -0.1);
    tail.rotation.z = -Math.PI / 2;
    tail.scale.set(0.5, 1.2, 1);
    previewGroup.add(tail);
    
    // Add bubbles
    for (let i = 0; i < 8; i++) {
        const bubbleGeometry = new THREE.SphereGeometry(0.03, 6, 6);
        const bubbleMaterial = new THREE.MeshStandardMaterial({
            color: 0xE0FFFF,
            transparent: true,
            opacity: 0.4,
            metalness: 0.8,
            roughness: 0.1
        });
        const bubble = new THREE.Mesh(bubbleGeometry, bubbleMaterial);
        bubble.position.set(
            (Math.random() - 0.5) * 2,
            0.2 + Math.random() * 1.5,
            (Math.random() - 0.5) * 2
        );
        previewGroup.add(bubble);
    }
}



    
    // Scale up the preview to fill the rectangle better
previewGroup.scale.set(1.5, 1.5, 1.5);

// Center the preview perfectly in the rectangle  
previewGroup.position.set(0, 0.3, 0); // Raise it up slightly
previewGroup.userData.baseY = 0.3; // Store base position for floating animation

return previewGroup;
}

        // Setup world select navigation buttons
function setupWorldSelectButtons() {
    // Remove any existing event listeners by cloning buttons
    const prevBtn = document.getElementById('prevWorldBtn');
    const nextBtn = document.getElementById('nextWorldBtn');
    const startBtn = document.getElementById('startGameFromWorldButton');

    // Clone buttons to remove all event listeners
    const newPrevBtn = prevBtn.cloneNode(true);
    const newNextBtn = nextBtn.cloneNode(true);
    const newStartBtn = startBtn.cloneNode(true);
    
    prevBtn.parentNode.replaceChild(newPrevBtn, prevBtn);
    nextBtn.parentNode.replaceChild(newNextBtn, nextBtn);
    startBtn.parentNode.replaceChild(newStartBtn, startBtn);

   // Update arrow button visibility based on unlocked worlds
updateWorldArrowVisibility();

// Add fresh event listeners
document.getElementById('prevWorldBtn').addEventListener('click', function() {
    // Hide current model
    if (worldSelectModels[selectedWorldIndex]) {
        worldSelectModels[selectedWorldIndex].visible = false;
    }
    
    // Update index (with wrap-around)
    selectedWorldIndex = (selectedWorldIndex - 1 + availableWorlds.length) % availableWorlds.length;
    
    // Show new model
    if (worldSelectModels[selectedWorldIndex]) {
        worldSelectModels[selectedWorldIndex].visible = true;
    }
    
    // Update info display
    updateWorldDisplay();
});

document.getElementById('nextWorldBtn').addEventListener('click', function() {
    // Hide current model
    if (worldSelectModels[selectedWorldIndex]) {
        worldSelectModels[selectedWorldIndex].visible = false;
    }
    
    // Update index (with wrap-around)
    selectedWorldIndex = (selectedWorldIndex + 1) % availableWorlds.length;
    
    // Show new model
    if (worldSelectModels[selectedWorldIndex]) {
        worldSelectModels[selectedWorldIndex].visible = true;
    }
    
    // Update info display
    updateWorldDisplay();
});
    
    // Back to main menu button
    document.getElementById('backToMainMenuFromWorld').addEventListener('click', function() {
        document.getElementById('worldSelectScreen').style.display = 'none';
        document.getElementById('mainMenuScreen').style.display = 'flex';
        gameState = "mainMenu";
    });

    // Start game from world select
    document.getElementById('startGameFromWorldButton').addEventListener('click', function() {
        const selectedWorld = availableWorlds[selectedWorldIndex];
        
        if (unlockedWorlds[selectedWorld.id] || modModeEnabled) {
            // Set the selected world
            currentWorld = selectedWorld.id;
            applyWorldSettings(selectedWorld);
            
            // Hide world selection screen
            document.getElementById('worldSelectScreen').style.display = 'none';
            
            // Update game state and start the game
            gameState = "playing";
            startGame();
        } else {
            // World is locked - ask if they want to unlock
            const cost = selectedWorld.cost;
            if (confirm(`This world costs ${cost} coins. Do you want to unlock it?`)) {
                tryUnlockWorld(selectedWorld.id);
                updateWorldDisplay(); // Refresh display after attempt
            }
        }
    });
}

// Function to show/hide world navigation arrows
function updateWorldArrowVisibility() {
    const unlockedCount = availableWorlds.filter(world => unlockedWorlds[world.id] || modModeEnabled).length;
    const prevBtn = document.getElementById('prevWorldBtn');
    const nextBtn = document.getElementById('nextWorldBtn');
    
    if (unlockedCount <= 1) {
        prevBtn.style.display = 'none';
        nextBtn.style.display = 'none';
    } else {
        prevBtn.style.display = 'block';
        nextBtn.style.display = 'block';
    }
}

// Update world display information
function updateWorldDisplay() {
    const selectedWorld = availableWorlds[selectedWorldIndex];
    const worldNameElem = document.getElementById('worldName');
    const worldDescElem = document.getElementById('worldDescription');
    const worldStatusElem = document.getElementById('worldUnlockStatus');
    
    // Set name
    worldNameElem.textContent = selectedWorld.name;
    
    // Set description
    worldDescElem.textContent = selectedWorld.description;
    
    // Check unlock status
    if (unlockedWorlds[selectedWorld.id] || modModeEnabled) {
        worldStatusElem.textContent = "Unlocked";
        worldStatusElem.style.color = "#4CAF50"; // Green
    } else {
        worldStatusElem.textContent = `Locked - Cost: ${selectedWorld.cost} coins`;
        worldStatusElem.style.color = "#FF5722"; // Orange-red
    }
}

// Try to unlock a world
function tryUnlockWorld(worldId) {
    const world = availableWorlds.find(w => w.id === worldId);
    if (!world) return;
    
    if (unlockedWorlds[worldId]) {
        return; // Already unlocked
    }
    
    const cost = world.cost;
    if (totalCoins >= cost) {
        totalCoins -= cost;
        unlockedWorlds[worldId] = true;
        updateTotalCoins();
        saveGameData('world_unlock');  // or 'world_unlock'
        alert(`${world.name} unlocked!`);
    } else {
        alert(`Not enough coins! You need ${cost} coins to unlock this world.`);
    }
}

// Apply world settings to the game
function applyWorldSettings(world) {
    // Apply sky color
    scene.background = new THREE.Color(world.colors.sky);
    
    // Apply lighting changes
    if (skyLight) {
        skyLight.color.setHex(world.lighting.directional.color);
        skyLight.intensity = world.lighting.directional.intensity;
    }
    
    
    // In applyWorldSettings function, after the underwater effects code:
        if (world.id === 'underwater') {
            
            // Remove any existing water streams when switching to underwater
            waterStreams.forEach(stream => {
                scene.remove(stream);
            });
            waterStreams = [];
        
        }

    // Store current world data for other systems to use
    window.currentWorldData = world;
    
    // Clear existing obstacles from scene AND from the obstacles array
        obstacles.forEach(obstacle => {
            scene.remove(obstacle);
            // Also remove any references to avoid memory leaks
            if (obstacle.geometry) obstacle.geometry.dispose();
            if (obstacle.material) {
                if (Array.isArray(obstacle.material)) {
                    obstacle.material.forEach(mat => mat.dispose());
                } else {
                    obstacle.material.dispose();
                }
            }
        });
        obstacles.length = 0; // Clear the array completely

        // Remove birds and butterflies when switching any world
    butterflyGroups.forEach(butterfly => {
        scene.remove(butterfly);
    });
    butterflyGroups = [];

    birds.forEach(bird => {
        scene.remove(bird);
    });
    birds = [];

        // Add a small delay before spawning new obstacles to ensure scene is updated
        setTimeout(() => {
            console.log('Obstacles array after clearing:', obstacles.length);
            console.log('Available obstacles for spawning:', Array.from(obstacleModels.keys()));
        }, 100);
    
    // Clear the obstacle models cache and reload for new world
    obstacleModels.clear();
    currentWorldObstaclesLoaded = false;
    
    // Load the new world's obstacles
    loadWorldObstacles(world.id).then(() => {
        console.log(`‚úÖ ${world.id} obstacles loaded after world switch`);
    }).catch(error => {
        console.error(`Failed to load ${world.id} obstacles:`, error);
    });

    // Clear existing scenery from scene
sceneryObjects.forEach(scenery => scene.remove(scenery));
sceneryObjects = [];

// Clear the scenery models cache and reload for new world
sceneryModels.clear();
currentWorldSceneryLoaded = false;

// Load the new world's scenery
loadWorldScenery(world.id).then(() => {
    console.log(`‚úÖ ${world.id} scenery loaded after world switch`);
}).catch(error => {
    console.error(`Failed to load ${world.id} scenery:`, error);
});
    
    // IMPORTANT: Recreate the ground with the new world theme
    recreateGroundForWorld();
    
    debug(`Applied settings for world: ${world.name}`);
}

// Recreate ground and background with current world theme
function recreateGroundForWorld() {
    // Remove existing ground segments
    groundSegments.forEach(segment => {
        scene.remove(segment);
    });
    groundSegments = [];
    
    // Remove existing side terrain segments
    sideTerrainSegments.forEach(terrain => {
        scene.remove(terrain);
    });
    sideTerrainSegments = [];
    
    // Remove existing background elements (mountains, trees, etc.)
    removeOldBackground();
    
    // Recreate ground and background with current world theme
    createGround();
    createBackground();
    
    debug(`Ground and background recreated for world: ${currentWorld}`);
}

// Remove old background elements when switching worlds
function removeOldBackground() {
    // Find and remove background elements (mountains, trees, clouds, etc.)
    const elementsToRemove = [];
    
    scene.traverse((object) => {
        // Remove mountains, trees, and other background scenery
        // (but keep player, coins, obstacles, etc.)
        if (object.parent === scene && 
            object !== player && 
            !groundSegments.includes(object) &&
            !sideTerrainSegments.includes(object) &&
            !coins.includes(object) &&
            !obstacles.includes(object) &&
            !powerUps.includes(object) &&
            !waterStreams.includes(object) &&
            !sceneryObjects.includes(object) &&
            object.type !== 'DirectionalLight' &&
            object.type !== 'AmbientLight') {
            
            // Check if it's likely a background element (positioned far away)
            if (Math.abs(object.position.z) > 50 || Math.abs(object.position.x) > 20) {
                elementsToRemove.push(object);
            }
        }
    });
    
    // Remove the background elements
    elementsToRemove.forEach(element => {
        scene.remove(element);
    });
    
    debug(`Removed ${elementsToRemove.length} old background elements`);
}

        // Update character info display
        function updateCharacterInfo() {
            const selectedChar = characterNames[selectedCharacterIndex];
            const charNameElem = document.getElementById('characterName');
            const charDescElem = document.getElementById('characterDescription');
            const charStatusElem = document.getElementById('characterUnlockStatus');
            
            // Set name (capitalized)
            charNameElem.textContent = selectedChar.charAt(0).toUpperCase() + selectedChar.slice(1);
            
            // Set description
switch (selectedChar) {
    case "apple":
        charDescElem.textContent = "Classic runner";
        break;
    case "carrot":
        charDescElem.textContent = "Fast lane changes";
        break;
    case "pumpkin":
        charDescElem.textContent = "Higher jumps";
        break;
    case "happyface":
        charDescElem.textContent = "Bouncy and cheerful";
        break;
    case "monster":
        charDescElem.textContent = "Ominous and fast";
        break;
    case "atom":
        charDescElem.textContent = "Glowing nucleus";
        break;
    case "slime":
        charDescElem.textContent = "Oozing and creepy";
        break;
    case "ufo":
        charDescElem.textContent = "Alien technology";
        break;
    case "robot":
        charDescElem.textContent = "Electromagnetic shield";
        break;
    case "dragon":
        charDescElem.textContent = "Fire breath destroyer";
        break;
    case "ghost":
        charDescElem.textContent = "Phase through obstacles";
        break;
    case "creature":
        charDescElem.textContent = "Otherworldly cosmic entity";
        break;
}
            
            // Check unlock status
            if (unlockedCharacters[selectedChar] || modModeEnabled) {
                charStatusElem.textContent = "Unlocked";
                charStatusElem.style.color = "#4CAF50"; // Green
            } else {
                charStatusElem.textContent = `Locked - Cost: ${characterCosts[selectedChar]} coins`;
                charStatusElem.style.color = "#FF5722"; // Orange-red
            }
        }

        // Create and animate background effects
        function createBackgroundEffects(scene) {
            // Add particles, grid lines, etc. here
            // This is just a simple implementation - you can expand it
            
            // Create particles
            const particlesGeometry = new THREE.BufferGeometry();
            const particleCount = 200;
            
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                // Position
                positions[i * 3] = (Math.random() - 0.5) * 20;      // x
                positions[i * 3 + 1] = (Math.random() - 0.5) * 20;  // y
                positions[i * 3 + 2] = (Math.random() - 0.5) * 20;  // z
                
                // Color (blue/cyan)
                colors[i * 3] = 0.1 + Math.random() * 0.3;          // r
                colors[i * 3 + 1] = 0.4 + Math.random() * 0.4;      // g
                colors[i * 3 + 2] = 0.7 + Math.random() * 0.3;      // b
            }
            
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const particlesMaterial = new THREE.PointsMaterial({
                size: 0.1,
                transparent: true,
                opacity: 0.7,
                vertexColors: true
            });
            
            const particles = new THREE.Points(particlesGeometry, particlesMaterial);
            particles.userData = {
                originalPositions: positions.slice() // Store original positions
            };
            
            scene.add(particles);
            scene.userData.particles = particles;
        }

        function animateBackgroundEffects() {
            const scene = characterSelectModels[0].model.parent;
            const particles = scene.userData.particles;
            
            if (particles) {
                // Animate particles
                const positions = particles.geometry.attributes.position.array;
                const originalPositions = particles.userData.originalPositions;
                
                for (let i = 0; i < positions.length; i += 3) {
                    // Move particles in a wave pattern
                    positions[i] = originalPositions[i] + Math.sin(frameCount * 0.01 + i * 0.1) * 0.1;
                    positions[i + 1] = originalPositions[i + 1] + Math.cos(frameCount * 0.01 + i * 0.05) * 0.1;
                    positions[i + 2] = originalPositions[i + 2];
                }
                
                particles.geometry.attributes.position.needsUpdate = true;
            }
        }

        // Helper function to animate specific characters
        function animateCharacterModel(model, type, frame) {
            switch (type) {
                case "happyface":
    // Bouncy animation - but only during gameplay, not on title screen
    if (model.userData && model.userData.bounceOffset !== undefined && gameState === "playing") {
        model.position.y = Math.sin(frame * 0.05 + model.userData.bounceOffset) * 0.1;
    }
    break;
                case "monster":
                    // Smoky particle animation
                    if (model.children) {
                        for (let i = 5; i < model.children.length; i++) {
                            const particle = model.children[i];
                            if (particle.userData && particle.userData.initialPosition) {
                                particle.userData.angle += particle.userData.rotationSpeed;
                                
                                const orbitRadius = particle.userData.initialPosition.length() + 
                                    Math.sin(frame * particle.userData.oscillationSpeed) * 
                                    particle.userData.oscillationDistance;
                                
                                const newX = orbitRadius * Math.sin(particle.userData.angle);
                                const newY = particle.userData.initialPosition.y + 
                                    Math.sin(frame * 0.1 + i) * 0.05;
                                const newZ = orbitRadius * Math.cos(particle.userData.angle);
                                
                                particle.position.set(newX, newY, newZ);
                            }
                        }
                    }
                    break;
                case "atom":
                    // Update electrons in orbit
                    for (let i = 0; i < model.children.length; i++) {
                        const child = model.children[i];
                        
                        // Orbital rings rotation
                        if (i >= 2 && i <= 4) {
                            child.rotation.z += 0.01;
                        }
                        
                        // Electrons
                        if (child.userData && child.userData.orbitalIndex !== undefined) {
                            const electron = child;
                            const orbitalIndex = electron.userData.orbitalIndex;
                            const orbitalRadius = electron.userData.orbitalRadius;
                            const speed = electron.userData.speed;
                            
                            electron.userData.angle += speed;
                            
                            if (orbitalIndex === 0) {
                                electron.position.x = Math.cos(electron.userData.angle) * orbitalRadius;
                                electron.position.z = Math.sin(electron.userData.angle) * orbitalRadius;
                            } else if (orbitalIndex === 1) {
                                electron.position.y = Math.cos(electron.userData.angle) * orbitalRadius;
                                electron.position.z = Math.sin(electron.userData.angle) * orbitalRadius;
                            } else {
                                electron.position.x = Math.cos(electron.userData.angle) * orbitalRadius * 0.7;
                                electron.position.y = Math.cos(electron.userData.angle) * orbitalRadius * 0.7;
                                electron.position.z = Math.sin(electron.userData.angle) * orbitalRadius;
                            }
                        }
                        
                        // Nucleus sparkles
                        if (i === 0 && child.children) {
                            child.children.forEach(sparkle => {
                                if (sparkle.userData) {
                                    const pulseScale = 0.8 + Math.sin(frame * sparkle.userData.pulseSpeed + sparkle.userData.pulsePhase) * 0.3;
                                    sparkle.scale.set(pulseScale, pulseScale, pulseScale);
                                }
                            });
                        }
                        
                        // Glow effect
                        if (i === 1) {
                            const pulseScale = 1.0 + Math.sin(frame * 0.05) * 0.1;
                            child.scale.set(pulseScale, pulseScale, pulseScale);
                            child.material.opacity = 0.3 + Math.sin(frame * 0.08) * 0.15;
                        }
                    }
                    break;
case "ufo":
    // Rotate the outer ring
    if (model.userData && model.userData.ring) {
        model.userData.ring.rotation.y += 0.03;
    }
    
    // Pulse the lights
    if (model.userData && model.userData.lights) {
        model.userData.lights.children.forEach((light, index) => {
            if (light.userData) {
                const pulse = Math.sin(frame * light.userData.pulseSpeed + light.userData.pulsePhase);
                light.material.emissiveIntensity = light.userData.originalIntensity + pulse * 0.5;
            }
        });
    }
    
    // Pulse the dome
    if (model.userData && model.userData.dome) {
        const domePulse = Math.sin(frame * 0.03) * 0.2 + 0.5;
        model.userData.dome.material.emissiveIntensity = domePulse;
    }
    
    // Animate tractor beam
    if (model.userData && model.userData.beam) {
        const beamPulse = Math.sin(frame * 0.05) * 0.1 + 0.2;
        model.userData.beam.material.opacity = beamPulse;
        model.userData.beam.rotation.y += 0.02;
    }
    
    // Float energy particles
    if (model.userData && model.userData.particles) {
        model.userData.particles.forEach(particle => {
            if (particle.userData) {
                // Orbit motion
                particle.userData.orbitAngle += particle.userData.orbitSpeed;
                const x = Math.cos(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                const z = Math.sin(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                
                // Floating motion
                const floatY = Math.sin(frame * particle.userData.floatSpeed + particle.userData.floatOffset) * 0.3;
                
                particle.position.set(x, floatY, z);
                
                // Particle glow pulse
                const glowPulse = Math.sin(frame * 0.08 + particle.userData.floatOffset) * 0.3 + 0.7;
                particle.material.opacity = glowPulse;
            }
        });
    }
    break;

case "slime":
    // Wobble animation for slime
    if (model.userData) {
        const wobble = Math.sin(frame * model.userData.wobbleSpeed) * model.userData.wobbleIntensity;
        model.scale.set(1 + wobble, 1 - wobble * 0.5, 1 + wobble);
        
        // Animate bubbles
        if (model.userData.bubbles) {
            model.userData.bubbles.forEach(bubble => {
                if (bubble.userData) {
                    const pulseScale = bubble.userData.originalScale.x + Math.sin(frame * bubble.userData.pulseSpeed + bubble.userData.pulsePhase) * 0.3;
                    bubble.scale.set(pulseScale, pulseScale, pulseScale);
                }
            });
        }
    }
    break;

case "robot":
    // Animate electromagnetic field
    if (model.userData && model.userData.fieldParticles) {
        model.userData.fieldParticles.forEach(particle => {
            if (particle.userData) {
                // Orbit around robot
                particle.userData.orbitAngle += particle.userData.orbitSpeed;
                particle.position.x = Math.cos(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                particle.position.z = Math.sin(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                particle.position.y = particle.userData.verticalOffset + Math.sin(frame * 0.02 + particle.userData.orbitAngle) * 0.2;
                
                // Pulse brightness based on shield status
                const intensity = robotShieldActive ? 0.8 : 0.3;
                particle.material.opacity = intensity + Math.sin(frame * 0.1 + particle.userData.orbitAngle) * 0.2;
            }
        });
    }
    break;

case "dragon":
    // Animate wings
    if (model.userData && model.userData.wings) {
        const wingFlap = Math.sin(frame * 0.15) * 0.3;
        model.userData.wings[0].rotation.z = Math.PI / 3 + wingFlap; // Left wing
        model.userData.wings[1].rotation.z = -Math.PI / 3 - wingFlap; // Right wing
    }
    
    // Animate fire particles when fire breath is active
    if (model.userData && model.userData.fireParticles && dragonFireActive) {
        model.userData.fireParticles.forEach((particle, index) => {
            if (particle.userData) {
                // Move fire particles forward
                particle.position.z += particle.userData.speed;
                
                // Flicker effect
                const flicker = Math.sin(frame * particle.userData.flickerSpeed + index) * 0.3 + 0.7;
                particle.material.opacity = particle.userData.originalOpacity * flicker;
                particle.scale.setScalar(0.8 + flicker * 0.4);
                
                // Reset position if too far
                if (particle.position.z > 2.0) {
                    particle.position.set(
                        (Math.random() - 0.5) * 0.3,
                        0.1 + Math.random() * 0.2,
                        1.0
                    );
                }
            }
        });
    }
    break;

case "ghost":
    // Animate wispy tail
    if (model.userData && model.userData.wisps) {
        model.userData.wisps.forEach(wisp => {
            if (wisp.userData) {
                const float = Math.sin(frame * wisp.userData.floatSpeed + wisp.userData.floatOffset) * 0.1;
                wisp.position.y = wisp.userData.originalY + float;
                wisp.rotation.y += 0.01;
            }
        });
    }
    
    // Animate floating particles
    if (model.userData && model.userData.particles) {
        model.userData.particles.forEach(particle => {
            if (particle.userData) {
                // Orbit motion
                particle.userData.orbitAngle += particle.userData.orbitSpeed;
                particle.position.x = Math.cos(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                particle.position.z = Math.sin(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                
                // Floating motion
                const floatY = Math.sin(frame * particle.userData.floatSpeed + particle.userData.floatOffset) * 0.2;
                particle.position.y += floatY * 0.01;
                
                // Pulse opacity
                const pulse = Math.sin(frame * 0.05 + particle.userData.floatOffset) * 0.3 + 0.7;
                particle.material.opacity = 0.6 * pulse;
            }
        });
    }
    
    // Phase effect when phasing through obstacles
    if (ghostPhaseActive) {
        const phaseOpacity = 0.3 + Math.sin(frame * 0.2) * 0.2;
        model.children[0].material.opacity = phaseOpacity; // Main body
        
        // Make wisps more transparent too
        if (model.userData && model.userData.wisps) {
            model.userData.wisps.forEach((wisp, index) => {
                wisp.material.opacity = (0.5 - index * 0.05) * phaseOpacity;
            });
        }
    } else {
        // Normal opacity
        model.children[0].material.opacity = model.userData.originalOpacity;
        if (model.userData && model.userData.wisps) {
            model.userData.wisps.forEach((wisp, index) => {
                wisp.material.opacity = 0.5 - index * 0.05;
            });
        }
    }
    break;

    case "creature":
    // Animate the neon core pulsing
    if (model.userData && model.userData.neonCore) {
        model.userData.corePhase += model.userData.bodyPulseSpeed;
        const corePulse = Math.sin(model.userData.corePhase) * 0.3 + 1.0;
        model.userData.neonCore.scale.set(corePulse, corePulse, corePulse);
        model.userData.neonCore.material.emissiveIntensity = 0.8 + Math.sin(model.userData.corePhase * 1.5) * 0.4;
    }
    
    // Animate multiple eyes blinking independently
    if (model.userData && model.userData.eyes) {
        model.userData.eyes.forEach(eye => {
            if (eye.userData) {
                // Independent blinking
                const blink = Math.sin(frame * eye.userData.blinkSpeed + eye.userData.blinkOffset);
                eye.scale.y = Math.max(0.1, Math.abs(blink));
                
                // Color pulsing
                const pulse = Math.sin(frame * eye.userData.pulseSpeed + eye.userData.pulsePhase) * 0.5 + 1.0;
                eye.material.emissiveIntensity = pulse;
            }
        });
    }
    
    // Animate floating tentacles
    if (model.userData && model.userData.tentacles) {
        model.userData.tentacles.forEach(tentacle => {
            if (tentacle.userData) {
                // Sway tentacles
                const sway = Math.sin(frame * tentacle.userData.swaySpeed) * tentacle.userData.swayAmount;
                tentacle.rotation.z = sway * 0.3;
                
                // Animate individual segments
                tentacle.children.forEach(segment => {
                    if (segment.userData) {
                        const wave = Math.sin(frame * segment.userData.waveSpeed + segment.userData.waveOffset);
                        segment.position.x = wave * 0.1 * (segment.userData.segmentIndex + 1);
                    }
                });
            }
        });
    }
    
    // Animate ethereal wisps
    if (model.userData && model.userData.wisps) {
        model.userData.wisps.forEach(wisp => {
            if (wisp.userData) {
                // Orbit motion
                wisp.userData.orbitAngle += wisp.userData.orbitSpeed;
                wisp.position.x = Math.cos(wisp.userData.orbitAngle) * wisp.userData.orbitRadius;
                wisp.position.z = Math.sin(wisp.userData.orbitAngle) * wisp.userData.orbitRadius;
                
                // Vertical floating
                const verticalFloat = Math.sin(frame * wisp.userData.verticalSpeed + wisp.userData.verticalOffset) * 0.2;
                wisp.position.y += verticalFloat * 0.01;
                
                // Pulsing effect
                const pulse = Math.sin(frame * wisp.userData.pulseSpeed + wisp.userData.pulsePhase) * 0.4 + 0.6;
                wisp.material.opacity = pulse;
                wisp.scale.setScalar(pulse);
            }
        });
    }
    
    // Morph the main body slightly
    if (model.userData && model.userData.mainBody) {
        const morph = Math.sin(frame * model.userData.morphSpeed) * 0.05 + 1.0;
        model.userData.mainBody.scale.set(1.1 * morph, 0.9 / morph, 1.1 * morph);
    }
    break;

            }
        }

     
        function updateTimeOfDay() {
    // Skip time of day changes for underwater world
    if (currentWorld === 'underwater') {
        return;
    }
    
    time += timeCycleSpeed;
    if (time > 1) time = 0;
    
    // Calculate sky color based on time only (no weather)
    let targetSkyColor;
    if (time < 0.25) { // Morning
        targetSkyColor = new THREE.Color(0x87CEEB).lerp(new THREE.Color(0xFFA07A), time * 4);
    } else if (time < 0.3) { // Sunrise
        targetSkyColor = new THREE.Color(0xFFA07A).lerp(new THREE.Color(0x87CEEB), (time - 0.25) * 20);
    } else if (time < 0.7) { // Day
        targetSkyColor = new THREE.Color(0x87CEEB);
    } else if (time < 0.8) { // Sunset
        targetSkyColor = new THREE.Color(0x87CEEB).lerp(new THREE.Color(0xFF7F50), (time - 0.7) * 10);
    } else if (time < 0.85) { // Dusk
        targetSkyColor = new THREE.Color(0xFF7F50).lerp(new THREE.Color(0x191970), (time - 0.8) * 20);
    } else { // Night
        targetSkyColor = new THREE.Color(0x191970);
    }
    
    // Apply sky color
    scene.background.lerp(targetSkyColor, 0.005);
    
    // Adjust light intensity based on time
    let targetIntensity;
    if (time < 0.3 || time > 0.7) {
        targetIntensity = (time > 0.85 || time < 0.2) ? 0.3 : 0.6;
    } else {
        targetIntensity = 0.8;
    }
    
    skyLight.intensity += (targetIntensity - skyLight.intensity) * 0.01;
    
    // Adjust light color based on time
    let targetLightColor;
    if (time < 0.3) {
        targetLightColor = new THREE.Color(0xFFD580);
    } else if (time < 0.7) {
        targetLightColor = new THREE.Color(0xFFFFFF);
    } else if (time < 0.85) {
        targetLightColor = new THREE.Color(0xFFA07A);
    } else {
        targetLightColor = new THREE.Color(0x4169E1);
    }
    
    skyLight.color.lerp(targetLightColor, 0.01);
}

        function updateButterfliesAndBirds() {
            // Update butterflies
            for (let i = butterflyGroups.length - 1; i >= 0; i--) {
                const butterfly = butterflyGroups[i];
                
                // Move forward
                butterfly.position.add(butterfly.userData.moveDirection.clone().multiplyScalar(butterfly.userData.moveSpeed));
                
                // Animate wings
                butterfly.userData.wingPosition += butterfly.userData.wingSpeed;
                const leftWing = butterfly.children[0];
                const rightWing = butterfly.children[1];
                
                leftWing.rotation.z = Math.sin(butterfly.userData.wingPosition) * 0.5;
                rightWing.rotation.z = -Math.sin(butterfly.userData.wingPosition) * 0.5;
                
                // Change direction occasionally
                butterfly.userData.changeDirectionCounter++;
                if (butterfly.userData.changeDirectionCounter > butterfly.userData.changeDirectionTime) {
                    butterfly.userData.moveDirection = new THREE.Vector3(
                        Math.random() * 2 - 1,
                        Math.random() * 2 - 1,
                        Math.random() * 2 - 1
                    ).normalize();
                    butterfly.userData.changeDirectionCounter = 0;
                    butterfly.userData.changeDirectionTime = Math.floor(Math.random() * 100) + 50;
                }
                
                // Remove if too far
                if (butterfly.position.distanceTo(player.position) > 50) {
                    scene.remove(butterfly);
                    butterflyGroups.splice(i, 1);
                }
            }
            
            // Update birds
            for (let i = birds.length - 1; i >= 0; i--) {
                const bird = birds[i];
                
                // Move forward
                bird.position.z += currentSpeed + bird.userData.flySpeed;
                
                // Animate wings
                bird.userData.wingPosition += bird.userData.wingSpeed;
                const wings = bird.children[1];
                wings.rotation.z = Math.sin(bird.userData.wingPosition) * 0.3;
                
                // Remove if behind camera
                if (bird.position.z > 10) {
                    scene.remove(bird);
                    birds.splice(i, 1);
                }
            }
            
            // Spawn new butterflies/beetles occasionally - world-specific
if (Math.random() < 0.005 && butterflyGroups.length < mobileButterflyLimit) {
    // Don't spawn in underwater world!
    if (currentWorld !== 'underwater') {
        const x = Math.random() * 40 - 20;
        const y = Math.random() * 3 + 1;
        const z = Math.random() * 20 - 40;
        
        if (currentWorld === 'desert') {
            // Desert beetles instead of butterflies
            butterflyGroups.push(createDesertBeetle(x, y, z));
        } else {
            // Regular butterflies for classic and forest
            butterflyGroups.push(createButterfly(x, y, z));
        }
    }
}
            
            // Spawn new birds occasionally - world-specific types
if (Math.random() < 0.002 && birds.length < mobileBirdsLimit) {
    // Don't spawn in underwater or forest worlds!
    if (currentWorld !== 'underwater' && currentWorld !== 'forest') {
        const x = Math.random() * 60 - 30;
        const y = Math.random() * 10 + 10;
        const z = -100;
        
        // Different birds for different worlds
        if (currentWorld === 'desert') {
            // Vultures and desert birds fly higher
            const desertY = Math.random() * 15 + 15;
            birds.push(createBird(x, desertY, z));
        } else {
            // Regular birds for classic only
            birds.push(createBird(x, y, z));
        }
    }
}
}

// Create desert beetle animation
function createDesertBeetle(x, y, z) {
    const beetleGroup = new THREE.Group();
    
    // Beetle colors - desert themed
    const beetleColors = [
        0x8B4513, // Saddle brown
        0xA0522D, // Sienna  
        0x654321, // Dark brown
        0x2F4F4F, // Dark slate gray
        0x556B2F, // Dark olive green
        0x8B7355  // Burlywood
    ];
    
    const color = beetleColors[Math.floor(Math.random() * beetleColors.length)];
    
    // Beetle body - more elongated than butterfly
    const bodyGeometry = new THREE.CapsuleGeometry(0.02, 0.15, 4, 8);
    const bodyMaterial = new THREE.MeshStandardMaterial({
        color: 0x000000, // Black body
        metalness: 0.7,
        roughness: 0.3
    });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.rotation.x = Math.PI / 2;
    beetleGroup.add(body);
    
    // Beetle wing covers (elytra) - hard wing cases using boxes
const wingGeometry = new THREE.BoxGeometry(0.06, 0.02, 0.2);
const wingMaterial = new THREE.MeshStandardMaterial({
    color: color,
    metalness: 0.8,
    roughness: 0.2
});

const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
leftWing.position.set(-0.05, 0, 0);
beetleGroup.add(leftWing);

const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
rightWing.position.set(0.05, 0, 0);
beetleGroup.add(rightWing);

// Add beetle head
const headGeometry = new THREE.SphereGeometry(0.04, 8, 8);
const headMaterial = new THREE.MeshStandardMaterial({
    color: 0x000000,
    metalness: 0.6,
    roughness: 0.4
});
const head = new THREE.Mesh(headGeometry, headMaterial);
head.position.z = 0.1;
beetleGroup.add(head);
    
    // Antennae
    for (let i = 0; i < 2; i++) {
        const antennaGeometry = new THREE.CylinderGeometry(0.005, 0.005, 0.1, 4);
        const antennaMaterial = new THREE.MeshStandardMaterial({
            color: 0x000000
        });
        const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
        antenna.position.set(i === 0 ? -0.02 : 0.02, 0, 0.08);
        antenna.rotation.z = (i === 0 ? -1 : 1) * Math.PI / 6;
        beetleGroup.add(antenna);
    }
    
    // Position beetle
    beetleGroup.position.set(x, y, z);
    
    // Add animation properties (beetles fly differently than butterflies)
    beetleGroup.userData.wingSpeed = Math.random() * 0.15 + 0.2; // Faster wing beat
    beetleGroup.userData.wingPosition = 0;
    beetleGroup.userData.moveSpeed = Math.random() * 0.02 + 0.015; // Slightly faster movement
    beetleGroup.userData.moveDirection = new THREE.Vector3(
        Math.random() * 2 - 1,
        Math.random() * 2 - 1,
        Math.random() * 2 - 1
    ).normalize();
    beetleGroup.userData.changeDirectionCounter = 0;
    beetleGroup.userData.changeDirectionTime = Math.floor(Math.random() * 80) + 40; // More erratic movement
    
    scene.add(beetleGroup);
    return beetleGroup;
}
        
        // Create butterfly animation
        function createButterfly(x, y, z) {
            const butterflyGroup = new THREE.Group();
            
            // Butterfly colors
            const colors = [
                0xFF7F50, // Coral
                0xFFB6C1, // Light Pink
                0x4682B4, // Steel Blue
                0xFFA500, // Orange
                0xBDB76B, // Dark Khaki
                0xADFF2F  // Green Yellow
            ];
            
            const color = colors[Math.floor(Math.random() * colors.length)];
            
            // Wings
            const wingGeometry = new THREE.CircleGeometry(0.3, 16, 0, Math.PI);
            const wingMaterial = new THREE.MeshBasicMaterial({
                color: color,
                side: THREE.DoubleSide
            });
            
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.rotation.x = Math.PI / 2;
            leftWing.rotation.y = Math.PI / 2;
            leftWing.position.x = -0.15;
            butterflyGroup.add(leftWing);
            
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.rotation.x = Math.PI / 2;
            rightWing.rotation.y = -Math.PI / 2;
            rightWing.position.x = 0.15;
            butterflyGroup.add(rightWing);
            
            // Body
            const bodyGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.3, 8);
            const bodyMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000 // Black
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.x = Math.PI / 2;
            butterflyGroup.add(body);
            
            // Position butterfly
            butterflyGroup.position.set(x, y, z);
            
            // Add animation properties
            butterflyGroup.userData.wingSpeed = Math.random() * 0.1 + 0.1;
            butterflyGroup.userData.wingPosition = 0;
            butterflyGroup.userData.moveSpeed = Math.random() * 0.03 + 0.01;
            butterflyGroup.userData.moveDirection = new THREE.Vector3(
                Math.random() * 2 - 1,
                Math.random() * 2 - 1,
                Math.random() * 2 - 1
            ).normalize();
            butterflyGroup.userData.changeDirectionCounter = 0;
            butterflyGroup.userData.changeDirectionTime = Math.floor(Math.random() * 100) + 50;
            
            scene.add(butterflyGroup);
            return butterflyGroup;
        }
        
        // Create birds
        function createBird(x, y, z) {
            const birdGroup = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const bodyMaterial = new THREE.MeshBasicMaterial({
                color: Math.random() > 0.5 ? 0x555555 : 0x777777 // Gray birds
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            birdGroup.add(body);
            
            // Wings
            const wingGeometry = new THREE.BoxGeometry(0.6, 0.02, 0.2);
            const wingMaterial = new THREE.MeshBasicMaterial({
                color: bodyMaterial.color,
                side: THREE.DoubleSide
            });
            
            const wings = new THREE.Mesh(wingGeometry, wingMaterial);
            wings.position.y = 0.08;
            birdGroup.add(wings);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const headMaterial = new THREE.MeshBasicMaterial({
                color: bodyMaterial.color
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.z = 0.15;
            head.position.y = 0.04;
            birdGroup.add(head);
            
            // Beak
            const beakGeometry = new THREE.ConeGeometry(0.03, 0.1, 8);
            const beakMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFD700 // Gold
            });
            const beak = new THREE.Mesh(beakGeometry, beakMaterial);
            beak.rotation.x = -Math.PI / 2;
            beak.position.z = 0.25;
            beak.position.y = 0.04;
            birdGroup.add(beak);
            
            // Position bird
            birdGroup.position.set(x, y, z);
            birdGroup.rotation.y = Math.PI; // Face forward
            
            // Add animation properties
            birdGroup.userData.wingSpeed = Math.random() * 0.1 + 0.2;
            birdGroup.userData.wingPosition = 0;
            birdGroup.userData.flySpeed = Math.random() * 0.1 + 0.15;
            
            scene.add(birdGroup);
            return birdGroup;
        }

// Toggle settings screen visibility
        function toggleSettingsScreen() {
            const settingsScreen = document.getElementById('settingsScreen');
            const modalOverlay = document.getElementById('modalOverlay');
            
            if (settingsScreen.style.display === 'flex') {
                closeSettingsScreen();
            } else {
                // Set the active tab back to the first tab
                document.querySelectorAll('.tab-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.querySelector('.tab-button').classList.add('active');
                document.getElementById('settings-tab').classList.add('active');
                
                // Update character display in settings
                updateCharactersInSettings();
                
                // Update mod mode display
                if (modModeEnabled) {
                    document.getElementById('mod-mode-option').classList.add('enabled');
                    document.getElementById('modModeButton').textContent = 'Disable';
                } else {
                    document.getElementById('mod-mode-option').classList.remove('enabled');
                    document.getElementById('modModeButton').textContent = 'Enable';
                }
                
                // Update leaderboard
                updateLeaderboardDisplay();
                
                // Show settings and overlay
                settingsScreen.style.display = 'flex';
                modalOverlay.style.display = 'block';
                
                // Pause the game if it's running
                if (gameState === "playing") {
                    gamePaused = true;
                    gameState = "paused";
                }
            }
        }
        
        // Close settings screen
        function closeSettingsScreen() {
// Stop any playing preview
    if (window.previewMusic && window.previewMusic.playing) {
        stopPreview();
    }

            document.getElementById('settingsScreen').style.display = 'none';
            document.getElementById('modalOverlay').style.display = 'none';
            
            // Check where to return to based on game state
            if (gameState === "paused") {
                // If we came from pause menu, go back to pause menu
                document.getElementById('pauseScreen').style.display = 'flex';
                // Keep gamePaused as true
            } else if (gameState === "gameOver") {
                // If we came from game over, go back to game over screen
                document.getElementById('gameOver').style.display = 'flex';
            } else if (gameState === "playing") {
                // If we opened settings during gameplay, unpause
                gamePaused = false;
            }
        }
        
        // Toggle mod mode on/off
        function toggleModMode() {
            const password = document.getElementById('modPassword').value;
            
            if (!modModeEnabled) {
    // Trying to enable mod mode
    if (password === MOD_PASSWORD) {
        modModeEnabled = true;
        document.getElementById('mod-mode-option').classList.add('enabled');
        document.getElementById('modModeButton').textContent = 'Disable';
        
        // Show difficulty override option
        document.getElementById('difficulty-override-option').style.display = 'flex';
        
        // Unlock all characters
        unlockedCharacters.apple = true;
        unlockedCharacters.carrot = true;
        unlockedCharacters.pumpkin = true;
        unlockedCharacters.happyface = true;
        unlockedCharacters.monster = true;
        unlockedCharacters.atom = true;
        unlockedCharacters.slime = true;
        unlockedCharacters.ufo = true;

        // Unlock all worlds
availableWorlds.forEach(world => {
    unlockedWorlds[world.id] = true;
});
        
        // Update UI
        updateCharactersInSettings();
        
        alert('Mod Mode enabled! All characters unlocked + Difficulty Override available.');
    } else {
        alert('Incorrect password!');
    }
} else {
    // Disabling mod mode
    modModeEnabled = false;
    document.getElementById('mod-mode-option').classList.remove('enabled');
    document.getElementById('modModeButton').textContent = 'Enable';
    document.getElementById('modPassword').value = '';
    
    // Hide difficulty override option
    document.getElementById('difficulty-override-option').style.display = 'none';
    difficultyOverride = -1; // Reset to normal
    
    // PROPERLY reload the original saved state
    const saveKey = `${GAME_ID}_profile_${currentProfileName}`;
    const savedData = localStorage.getItem(saveKey);
    
    if (savedData) {
        try {
            const savedProfile = JSON.parse(savedData);
            // Restore ONLY the unlock states from saved data (don't touch coins/character)
            unlockedCharacters = {...savedProfile.unlockedCharacters};
            unlockedWorlds = savedProfile.unlockedWorlds || {classic: true};
            
            // Update the current profile to match
            currentProfile.unlockedCharacters = {...unlockedCharacters};
            currentProfile.unlockedWorlds = {...unlockedWorlds};
            currentProfile.modModeEnabled = false;
            
            console.log('üîÑ Restored unlock states from saved data');
            console.log('Characters:', unlockedCharacters);
            console.log('Worlds:', unlockedWorlds);
        } catch (error) {
            console.error('Failed to reload saved state:', error);
            // Fallback to defaults
            unlockedCharacters = {
                apple: true,
                carrot: false,
                pumpkin: false,
                happyface: false,
                monster: false,
                atom: false,
                slime: false,
                ufo: false,
                robot: false,
                dragon: false,
                ghost: false
            };
            unlockedWorlds = {classic: true};
        }
    }
    
    // Save the updated state
    saveGameData('settings_change');
    
    alert('Mod Mode disabled.');
}
            
            saveGameData('settings_change');



        }

// Apply difficulty override for testing
function applyDifficultyOverride() {
    const selectedLevel = parseInt(document.getElementById('difficultyOverride').value);
    difficultyOverride = selectedLevel;
    
    if (selectedLevel === -1) {
        alert('Difficulty override disabled. Using normal time-based progression.');
        // Reset to normal progression
        if (gameStarted && !gameOver) {
            resetDynamicDifficulty();
        }
    } else {
        const levelNames = ['Cruise', 'Accelerating', 'Intense', 'Blazing', 'Maximum Chaos'];
        alert(`Difficulty forced to Level ${selectedLevel + 1}: ${levelNames[selectedLevel]}`);
        
        // Immediately apply the override with full parameters
        currentSpeedLevel = selectedLevel;
        
        // Manually set speed based on level
        currentSpeed = baseSpeed + (currentSpeedLevel * speedIncrement);
        currentSpeed = Math.min(currentSpeed, maxSpeed);
        
        // Update speed multiplier for display
        currentSpeedMultiplier = currentSpeed / baseSpeed;
        
        // Update spawn rates based on level
        const speedProgress = currentSpeedLevel / speedIncreaseIntervals.length;
        if (currentSpeedLevel >= 3) {
            const adjustedProgress = 0.7 + (currentSpeedLevel - 3) * 0.15;
            currentObstacleSpawnRate = Math.floor(Math.max(
                baseObstacleSpawnRate - (adjustedProgress * (baseObstacleSpawnRate - minObstacleSpawnRate)),
                currentSpeedLevel >= 4 ? 25 : minObstacleSpawnRate
            ));
        } else {
            currentObstacleSpawnRate = Math.floor(Math.max(
                baseObstacleSpawnRate - (speedProgress * (baseObstacleSpawnRate - minObstacleSpawnRate)),
                minObstacleSpawnRate
            ));
        }
        
        // Update stream spawn rate
        if (currentSpeedLevel >= 3) {
            currentStreamSpawnRate = Math.floor(baseStreamSpawnRate * 1.2);
        } else {
            currentStreamSpawnRate = Math.floor(Math.max(
                baseStreamSpawnRate - (speedProgress * 0.2 * (baseStreamSpawnRate - minStreamSpawnRate)),
                minStreamSpawnRate
            ));
        }
        
        // Update visual speed indicator
        updateSpeedIndicator();
        
        debug(`Forced Level: ${currentSpeedLevel}, Speed: ${currentSpeed.toFixed(2)}, Obstacle Rate: ${currentObstacleSpawnRate}`);
    }
}
        
        // Reset game data
        function resetGameData() {
            if (confirm('Are you sure you want to reset all game data? This cannot be undone.')) {
                // Clear localStorage
                localStorage.removeItem('endlessRunnerData');
                
                // Reset game variables
totalCoins = 0;
modModeEnabled = false;
unlockedCharacters = {
    apple: true,
    carrot: false,
    pumpkin: false,
    happyface: false,
    monster: false,
    atom: false,
    slime: false,
    ufo: false
};
unlockedWorlds = {
    classic: true
};
currentCharacter = 'apple';
currentWorld = 'classic';
                
                // Update UI
                document.getElementById('mod-mode-option').classList.remove('enabled');
                document.getElementById('modModeButton').textContent = 'Enable';
                document.getElementById('modPassword').value = '';
                updateTotalCoins();
                updateCharactersInSettings();
                
                // Recreate player with default character
                createPlayer();
                
                alert('Game data has been reset.');
            }
        }
        
        // Load textures
        function loadTextures() {
            const textureLoader = new THREE.TextureLoader();
            
            // Create procedural grass texture for simplicity and guaranteed loading
            const grassCanvas = document.createElement('canvas');
            grassCanvas.width = 512;
            grassCanvas.height = 512;
            const grassCtx = grassCanvas.getContext('2d');
            
            // Base color - grass green
            grassCtx.fillStyle = '#4CAF50';
            grassCtx.fillRect(0, 0, 512, 512);
            
            // Add some texture/variation
            for (let i = 0; i < 2000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const size = Math.random() * 3 + 1;
                const brightness = Math.random() * 30 - 15;
                
                // Random shade of green
                const r = Math.max(0, Math.min(255, 76 + brightness));
                const g = Math.max(0, Math.min(255, 175 + brightness));
                const b = Math.max(0, Math.min(255, 80 + brightness));
                
                grassCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                grassCtx.fillRect(x, y, size, size);
            }
            
            // Create some grass blades
            for (let i = 0; i < 400; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const height = Math.random() * 10 + 5;
                const width = Math.random() * 2 + 1;
                
                grassCtx.fillStyle = '#2E7D32'; // Darker green for blades
                grassCtx.fillRect(x, y, width, height);
            }
            
            grassTexture = new THREE.CanvasTexture(grassCanvas);
            grassTexture.wrapS = THREE.RepeatWrapping;
            grassTexture.wrapT = THREE.RepeatWrapping;
            grassTexture.repeat.set(3, 20);
            
            // Create procedural water texture
            const waterCanvas = document.createElement('canvas');
            waterCanvas.width = 512;
            waterCanvas.height = 512;
            const waterCtx = waterCanvas.getContext('2d');
            
            // Base color - water blue
            waterCtx.fillStyle = '#1E88E5';
            waterCtx.fillRect(0, 0, 512, 512);
            
            // Add some wave effect
            for (let y = 0; y < 512; y += 8) {
                for (let x = 0; x < 512; x += 1) {
                    const brightness = Math.sin(y * 0.05 + x * 0.03) * 20;
                    const r = Math.max(0, Math.min(255, 30 + brightness));
                    const g = Math.max(0, Math.min(255, 136 + brightness));
                    const b = Math.max(0, Math.min(255, 229 + brightness));
                    
                    waterCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    waterCtx.fillRect(x, y, 1, 4);
                }
            }
            
            // Add some highlights
            for (let i = 0; i < 300; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const size = Math.random() * 2 + 1;
                
                waterCtx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                waterCtx.fillRect(x, y, size, size);
            }
            
            waterTexture = new THREE.CanvasTexture(waterCanvas);
            waterTexture.wrapS = THREE.RepeatWrapping;
            waterTexture.wrapT = THREE.RepeatWrapping;
            waterTexture.repeat.set(5, 1);
        }

        function createOceanFloorTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 512;
    const ctx = canvas.getContext('2d');
    
    // Dark ocean floor base
    ctx.fillStyle = '#1a3a4a';
    ctx.fillRect(0, 0, 512, 512);
    
    // Add sand/sediment texture
    for (let i = 0; i < 2000; i++) {
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        const brightness = Math.random() * 20 + 30;
        const size = Math.random() * 2 + 1;
        ctx.fillStyle = `rgb(${brightness}, ${brightness + 10}, ${brightness + 20})`;
        ctx.fillRect(x, y, size, size);
    }
    
    // Add darker patches
    for (let i = 0; i < 20; i++) {
        ctx.save();
        ctx.globalAlpha = 0.3;
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        const radius = Math.random() * 40 + 20;
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        gradient.addColorStop(0, '#000000');
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
        ctx.restore();
    }
    
    // Add some lighter sandy patches
    for (let i = 0; i < 15; i++) {
        ctx.save();
        ctx.globalAlpha = 0.2;
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        const radius = Math.random() * 30 + 15;
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        gradient.addColorStop(0, '#3a5a6a');
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
        ctx.restore();
    }
    
    const texture = new THREE.CanvasTexture(canvas);
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(2, 10);
    
    return texture;
}
        
        // Create ground with grass texture
function createGround() {
    // Create ground geometry
    const groundGeometry = new THREE.BoxGeometry(10, 0.5, 100);

    // Create material based on current world
    let groundMaterial;
    if (currentWorld === 'forest') {
        groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x2F4F2F, // Dark forest floor
            roughness: 0.9
        });
    } else if (currentWorld === 'desert') {
        groundMaterial = new THREE.MeshStandardMaterial({
            color: 0xF4A460, // Sandy brown
            roughness: 0.8
        });
    } else if (currentWorld === 'underwater') {
    groundMaterial = new THREE.MeshStandardMaterial({
        color: 0x2a5a7a,  // Brighter ocean floor (was 0x1a3a4a)
        roughness: 1,
        metalness: 0
    });
} else {
        // Classic world - use grass texture
        groundMaterial = new THREE.MeshStandardMaterial({
            map: grassTexture,
            roughness: 0.8,
            color: 0xffffff
        });
    }
    
    // Create multiple ground segments to ensure continuous ground coverage
    const numSegments = 8;
    
    for (let i = 0; i < numSegments; i++) {
        const segment = new THREE.Mesh(groundGeometry, groundMaterial);
        segment.position.y = -0.25;
        segment.position.z = -45 - (i * 50);
        scene.add(segment);
        groundSegments.push(segment);
        
        // Add dirt sides to each ground segment
        const dirtGeometry = new THREE.BoxGeometry(12, 1, 50.1);
        // Create dirt material based on world
let dirtMaterial;
if (currentWorld === 'forest') {
    dirtMaterial = new THREE.MeshStandardMaterial({
        color: 0x654321, // Dark brown forest soil
        roughness: 1
    });
} else if (currentWorld === 'desert') {
    dirtMaterial = new THREE.MeshStandardMaterial({
        color: 0xCD853F, // Sandy rock color
        roughness: 0.9
    });
} else if (currentWorld === 'underwater') {  // ADD THIS
    dirtMaterial = new THREE.MeshStandardMaterial({
        color: 0x0d1f2d, // Very dark ocean depths
        roughness: 1,
        metalness: 0
    });
} else {
    dirtMaterial = new THREE.MeshStandardMaterial({
        color: 0x8B4513, // Classic brown dirt
        roughness: 1
    });
}

        const dirtSide = new THREE.Mesh(dirtGeometry, dirtMaterial);
        dirtSide.position.y = -0.75;
        dirtSide.position.z = segment.position.z;
        scene.add(dirtSide);

        // Create side terrain material based on world
let sideTerrainMaterial;
if (currentWorld === 'forest') {
    sideTerrainMaterial = new THREE.MeshStandardMaterial({
        color: 0x1F4F2F, // Very dark forest green
        roughness: 1.0
    });
} else if (currentWorld === 'desert') {
    sideTerrainMaterial = new THREE.MeshStandardMaterial({
        color: 0xDEB887, // Desert sand color
        roughness: 0.9
    });
} else if (currentWorld === 'underwater') {
    sideTerrainMaterial = new THREE.MeshStandardMaterial({
        color: 0x225570,  // Brighter (was 0x0f2a3f)
        roughness: 1,
        metalness: 0
    });
} else {
    // Classic world - use grass texture
    const wildGrassTexture = grassTexture.clone();
    wildGrassTexture.repeat.set(5, 30);
    sideTerrainMaterial = new THREE.MeshStandardMaterial({
        map: wildGrassTexture,
        roughness: 0.9,
        color: 0x88AA88
    });
}

        // Left side terrain
        const leftTerrainGeometry = new THREE.BoxGeometry(50, 0.3, 100);
        const leftTerrain = new THREE.Mesh(leftTerrainGeometry, sideTerrainMaterial);
        leftTerrain.position.y = -0.15;
        leftTerrain.position.x = -30;
        leftTerrain.position.z = segment.position.z;
        scene.add(leftTerrain);
        sideTerrainSegments.push(leftTerrain);

        // Right side terrain
        const rightTerrainGeometry = new THREE.BoxGeometry(50, 0.3, 100);
        const rightTerrain = new THREE.Mesh(rightTerrainGeometry, sideTerrainMaterial);
        rightTerrain.position.y = -0.15;
        rightTerrain.position.x = 30;
        rightTerrain.position.z = segment.position.z;
        scene.add(rightTerrain);
        sideTerrainSegments.push(rightTerrain);

        // Left dirt underneath
        const leftDirtGeometry = new THREE.BoxGeometry(50, 1, 100);
        const leftDirt = new THREE.Mesh(leftDirtGeometry, dirtMaterial);
        leftDirt.position.y = -0.6;
        leftDirt.position.x = -30;
        leftDirt.position.z = segment.position.z;
        scene.add(leftDirt);
        sideTerrainSegments.push(leftDirt);

        // Right dirt underneath
        const rightDirtGeometry = new THREE.BoxGeometry(50, 1, 100);
        const rightDirt = new THREE.Mesh(rightDirtGeometry, dirtMaterial);
        rightDirt.position.y = -0.6;
        rightDirt.position.x = 30;
        rightDirt.position.z = segment.position.z;
        scene.add(rightDirt);
        sideTerrainSegments.push(rightDirt);
    }
}
        
        // Create a simple water stream with minimal visual effects
        function createWaterStream() {
            const streamGroup = new THREE.Group();
            
            // Water surface - spans way beyond visible area to look infinite
const waterGeometry = new THREE.BoxGeometry(150, 0.25, 3); // Much wider - extends off screen
const waterMaterial = new THREE.MeshStandardMaterial({
    color: 0x1E88E5, // Deep blue water
    roughness: 0.1,
    metalness: 0.3,
    // No transparency - this prevents flickering
});

const water = new THREE.Mesh(waterGeometry, waterMaterial);
water.position.y = -0.05; // Align with ground level
streamGroup.add(water);

// Add water surface highlights for realism
const highlightGeometry = new THREE.BoxGeometry(150, 0.01, 3); // Match full width
const highlightMaterial = new THREE.MeshStandardMaterial({
    color: 0x87CEEB, // Light blue highlight
    roughness: 0.05,
    metalness: 0.8,
    emissive: 0x003366,
    emissiveIntensity: 0.2
});

const highlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
highlight.position.y = 0.08; // On top of water
streamGroup.add(highlight);

// Clean river banks with better positioning
const bankGeometry = new THREE.BoxGeometry(150, 0.4, 0.6); // Full width banks
const bankMaterial = new THREE.MeshStandardMaterial({
    color: 0x8B4513, // Brown
    roughness: 0.9
});

// Front bank - positioned to create clean edge
const frontBank = new THREE.Mesh(bankGeometry, bankMaterial);
frontBank.position.z = -1.8;
frontBank.position.y = 0.05;
streamGroup.add(frontBank);

// Back bank - positioned to create clean edge
const backBank = new THREE.Mesh(bankGeometry, bankMaterial);
backBank.position.z = 1.8;
backBank.position.y = 0.05;
streamGroup.add(backBank);

// Add some sandy/muddy edges for realism
const edgeGeometry = new THREE.BoxGeometry(150, 0.1, 0.2); // Full width edges
const edgeMaterial = new THREE.MeshStandardMaterial({
    color: 0xD2B48C, // Sandy color
    roughness: 0.8
});

// Front edge
const frontEdge = new THREE.Mesh(edgeGeometry, edgeMaterial);
frontEdge.position.z = -1.4;
frontEdge.position.y = 0.02;
streamGroup.add(frontEdge);

// Back edge
const backEdge = new THREE.Mesh(edgeGeometry, edgeMaterial);
backEdge.position.z = 1.4;
backEdge.position.y = 0.02;
streamGroup.add(backEdge);
            
            // Add rocks and logs for visual interest only
            const numObjects = Math.floor(Math.random() * 3) + 2; // 2-4 objects
            
            for (let i = 0; i < numObjects; i++) {
                // 50% chance for rock, 50% chance for log
                const isRock = Math.random() > 0.5;
                
                if (isRock) {
                    const rockGeometry = new THREE.DodecahedronGeometry(0.2, 1);
                    const rockMaterial = new THREE.MeshStandardMaterial({
                        color: 0x808080,
                        roughness: 0.8
                    });
                    
                    const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                    rock.position.set(
                        Math.random() * 8 - 4,
                        0.1,
                        Math.random() * 2 - 1
                    );
                    rock.rotation.set(
                        Math.random() * Math.PI,
                        Math.random() * Math.PI,
                        Math.random() * Math.PI
                    );
                    streamGroup.add(rock);
                } else {
                    // Small log sticking out of water
                    const logGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
                    const logMaterial = new THREE.MeshStandardMaterial({
                        color: 0x8B4513,
                        roughness: 0.9
                    });
                    
                    const log = new THREE.Mesh(logGeometry, logMaterial);
                    log.position.set(
                        Math.random() * 8 - 4,
                        0.2,
                        Math.random() * 2 - 1
                    );
                    // Tilt the log
                    log.rotation.x = Math.random() * 0.3;
                    log.rotation.z = Math.random() * Math.PI;
                    streamGroup.add(log);
                }
            }
            
            // Position stream on the track
            streamGroup.position.z = -50; // Spawn far away
            streamGroup.position.y = 0;   // Align with ground
            
            scene.add(streamGroup);
            waterStreams.push(streamGroup);
            streamCreated = true;
            
            return streamGroup;
        }
        
        // Simplest possible water streams update - only moves them forward with no animations
        function updateWaterStreams() {
            for (let i = waterStreams.length - 1; i >= 0; i--) {
                const stream = waterStreams[i];
                
                // Just move stream forward
                stream.position.z += currentSpeed;
                
                // Check for collision
                if (checkCollision(stream)) {
                    if (!jumping) {
                        // Hit water stream without jumping - game over
                        endGame();
                    }
                }
                
                // Remove streams that have passed the player
                if (stream.position.z > 10) {
                    scene.remove(stream);
                    waterStreams.splice(i, 1);
                }
            }
        }
        
        // Create background scenery
        function createBackground() {
            // Create world-specific background
if (currentWorld === 'desert') {
    // Create desert mountains/mesas
    for (let i = 0; i < 15; i++) {
        const mesaHeight = Math.random() * 10 + 5;
        const mesaWidth = Math.random() * 12 + 8;
        
        // Flat-topped mesa
        const mesaGeometry = new THREE.CylinderGeometry(mesaWidth, mesaWidth * 1.2, mesaHeight, 8);
        const mesaMaterial = new THREE.MeshStandardMaterial({
            color: 0xCD853F, // Sandy rock color
            flatShading: true,
            roughness: 0.8
        });
        
        const mesa = new THREE.Mesh(mesaGeometry, mesaMaterial);
        
        // Position mesas in the background
        const distance = Math.random() * 400 + 150;
        const posX = Math.random() * 300 - 150;
        mesa.position.set(posX, mesaHeight / 2 - 3, -distance);
        
        scene.add(mesa);
    }
    
    // Add distant sand dunes
    for (let i = 0; i < 25; i++) {
        const duneGeometry = new THREE.SphereGeometry(Math.random() * 20 + 10, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
        const duneMaterial = new THREE.MeshStandardMaterial({
            color: 0xF4A460,
            roughness: 0.9
        });
        const dune = new THREE.Mesh(duneGeometry, duneMaterial);
        
        const distance = Math.random() * 200 + 80;
        const posX = Math.random() * 400 - 200;
        dune.position.set(posX, -2, -distance);
        dune.scale.set(1, 0.3, 1);
        
        scene.add(dune);
    }
 } else if (currentWorld === 'underwater') {
    // Create distant coral reef formations
    for (let i = 0; i < 10; i++) {  // Reduced from 12
        const coralGroup = new THREE.Group();
        
        // Create brain coral shape (more interesting than rocks)
        const coralGeometry = new THREE.SphereGeometry(
            Math.random() * 20 + 15,
            8,  // Reduced segments for performance
            6
        );
        // Deform the sphere to look more like brain coral
        const coralMaterial = new THREE.MeshStandardMaterial({
            color: Math.random() > 0.5 ? 0xFF6B9D : 0xFF8FAB,  // Pink coral colors
            roughness: 0.8,
            flatShading: true  // Gives it a more coral-like appearance
        });
        const coral = new THREE.Mesh(coralGeometry, coralMaterial);
        coral.scale.set(1, 0.6, 1);  // Flatten it
        
        // Add staghorn coral branches
        for (let j = 0; j < 4; j++) {  // Reduced from more branches
            const branchGeometry = new THREE.ConeGeometry(3, 15, 6);  // Simple cone
            const branchMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFA07A,  // Light coral color
                roughness: 0.9
            });
            const branch = new THREE.Mesh(branchGeometry, branchMaterial);
            const angle = (j / 4) * Math.PI * 2;
            branch.position.set(
                Math.cos(angle) * 10,
                7,
                Math.sin(angle) * 10
            );
            branch.rotation.z = angle * 0.3;
            coralGroup.add(branch);
        }
        
        coralGroup.add(coral);
        
        // Position FAR in the background
        const distance = Math.random() * 300 + 150;
        const posX = Math.random() * 300 - 150;
        coralGroup.position.set(posX, -5, -distance);
        
        scene.add(coralGroup);
    }
    
    // Simpler kelp forests - just cylinders
    for (let i = 0; i < 5; i++) {  // Reduced from 8
        const kelpGeometry = new THREE.CylinderGeometry(3, 5, 40, 6);  // Reduced segments
        const kelpMaterial = new THREE.MeshStandardMaterial({
            color: 0x2F4F2F,
            roughness: 0.9
        });
        const kelp = new THREE.Mesh(kelpGeometry, kelpMaterial);
        
        const distance = Math.random() * 200 + 200;
        const posX = Math.random() * 400 - 200;
        kelp.position.set(posX, 0, -distance);
        
        scene.add(kelp);
    }
    
    return;
} else if (currentWorld === 'forest') {
    // Create forest mountains
    for (let i = 0; i < 20; i++) {
        const mountainHeight = Math.random() * 15 + 8;
        const mountainWidth = Math.random() * 8 + 5;
        
        const mountainGeometry = new THREE.ConeGeometry(mountainWidth, mountainHeight, 16);
        const mountainMaterial = new THREE.MeshStandardMaterial({
            color: 0x2F4F2F, // Dark forest green
            flatShading: true,
            roughness: 0.9
        });
        
        const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
        
        // Position mountains in the background
        const distance = Math.random() * 300 + 100;
        const posX = Math.random() * 200 - 100;
        mountain.position.set(posX, mountainHeight / 2 - 5, -distance);
        
        scene.add(mountain);
    }
} else {
    // Classic world mountains with snow caps
    for (let i = 0; i < 20; i++) {
        const mountainHeight = Math.random() * 15 + 8;
        const mountainWidth = Math.random() * 8 + 5;
        
        const mountainGeometry = new THREE.ConeGeometry(mountainWidth, mountainHeight, 16);
        const mountainMaterial = new THREE.MeshStandardMaterial({
            color: 0x808080, // Gray for mountains
            flatShading: true,
            roughness: 0.9
        });
        
        const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
        
        // Add snow cap to mountain
        const snowCapGeometry = new THREE.ConeGeometry(mountainWidth * 0.7, mountainHeight * 0.2, 16);
        const snowMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff, // White for snow
            roughness: 0.5
        });
        const snowCap = new THREE.Mesh(snowCapGeometry, snowMaterial);
        snowCap.position.y = mountainHeight * 0.4;
        mountain.add(snowCap);
        
        // Position mountains in the background
        const distance = Math.random() * 300 + 100;
        const posX = Math.random() * 200 - 100;
        mountain.position.set(posX, mountainHeight / 2 - 5, -distance);
        
        scene.add(mountain);
    }
}
            
            // Create a sun in the sky
            const sunGeometry = new THREE.SphereGeometry(10, 32, 32);
            const sunMaterial = new THREE.MeshStandardMaterial({
                color: 0xffff00, // Yellow
                emissive: 0xffff00,
                emissiveIntensity: 1
            });
            const sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.position.set(70, 50, -300);
            scene.add(sun);
            
            // Create a moon
            const moonGeometry = new THREE.SphereGeometry(7, 32, 32);
            const moonMaterial = new THREE.MeshStandardMaterial({
                color: 0xDDDDDD, // Off-white
                emissive: 0xDDDDDD,
                emissiveIntensity: 0.5
            });
            const moon = new THREE.Mesh(moonGeometry, moonMaterial);
            moon.position.set(-70, 50, -300);
            scene.add(moon);
            
            // Add more detailed clouds
        for (let i = 0; i < (isMobile ? 15 : 30); i++) {
                const cloudGroup = new THREE.Group();
                
                // Create several spheres for a cloud with more variety
                const numSpheres = Math.floor(Math.random() * 5) + 5;
                for (let j = 0; j < numSpheres; j++) {
                    const size = Math.random() * 4 + 3;
                    const sphereGeometry = new THREE.SphereGeometry(size, 8, 8);
                    const cloudMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        roughness: 0.2,
                        metalness: 0
                    });
                    
                    const sphere = new THREE.Mesh(sphereGeometry, cloudMaterial);
                    sphere.position.set(
                        (Math.random() - 0.5) * 15,
                        (Math.random() - 0.5) * 3,
                        (Math.random() - 0.5) * 15
                    );
                    cloudGroup.add(sphere);
                }
                
                // Position cloud in sky with wider spread
                const distance = Math.random() * 400 + 100;
                const posX = Math.random() * 300 - 150;
                const posY = Math.random() * 40 + 20;
                cloudGroup.position.set(posX, posY, -distance);
                
                scene.add(cloudGroup);
            }
            
            // Add world-specific distant vegetation
if (currentWorld === 'desert') {
    // Add scattered desert plants
    for (let i = 0; i < (isMobile ? 20 : 80); i++) {
        const desertPlantGroup = new THREE.Group();
        
        // Random desert plant type
        const plantType = Math.random();
        
        if (plantType < 0.6) {
            // Small cactus
            const cactusGeometry = new THREE.CylinderGeometry(0.3, 0.4, 3, 8);
            const cactusMaterial = new THREE.MeshStandardMaterial({
                color: 0x228B22,
                roughness: 0.8
            });
            const cactus = new THREE.Mesh(cactusGeometry, cactusMaterial);
            cactus.position.y = 1.5;
            desertPlantGroup.add(cactus);
        } else {
            // Palm tree
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 4, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.8
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2;
            desertPlantGroup.add(trunk);
            
            // Palm fronds
            for (let j = 0; j < 6; j++) {
                const frondGeometry = new THREE.PlaneGeometry(0.5, 3);
                const frondMaterial = new THREE.MeshStandardMaterial({
                    color: 0x228B22,
                    side: THREE.DoubleSide
                });
                const frond = new THREE.Mesh(frondGeometry, frondMaterial);
                frond.position.y = 4.5;
                frond.rotation.y = (j / 6) * Math.PI * 2;
                frond.rotation.x = -Math.PI / 6;
                desertPlantGroup.add(frond);
            }
        }
        
        // Position at horizon
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 100 + 150;
        desertPlantGroup.position.set(
            Math.cos(angle) * radius,
            -5,
            -Math.sin(angle) * radius
        );
        
        scene.add(desertPlantGroup);
    }
} else if (currentWorld === 'forest') {
    // Dense dark forest
    for (let i = 0; i < (isMobile ? 80 : 300); i++) {
        const treeGroup = new THREE.Group();
        
        // Dark forest tree
        const trunkGeometry = new THREE.CylinderGeometry(1, 1.2, 8, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({
            color: 0x654321,
            roughness: 0.8
        });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.y = 4;
        treeGroup.add(trunk);
        
        // Dark pine-like canopy
        const leavesGeometry = new THREE.ConeGeometry(4, 12, 8);
        const leavesMaterial = new THREE.MeshStandardMaterial({
            color: 0x1F4F2F, // Very dark green
            roughness: 0.8
        });
        
        const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
        leaves.position.y = 10;
        treeGroup.add(leaves);
        
        // Position trees at horizon
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 100 + 150;
        treeGroup.position.set(
            Math.cos(angle) * radius,
            -5,
            -Math.sin(angle) * radius
        );
        
        scene.add(treeGroup);
    }
} else {
    // Classic world forest
    for (let i = 0; i < (isMobile ? 50 : 200); i++) {
        const treeGroup = new THREE.Group();
        
        // Tree trunk
        const trunkGeometry = new THREE.CylinderGeometry(1, 1.2, 5, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B4513,
            roughness: 0.7
        });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.y = 2.5;
        treeGroup.add(trunk);
        
        // Tree leaves - layered cones for more natural look
        const leavesGeometry = new THREE.ConeGeometry(3, 8, 8);
        const leavesMaterial = new THREE.MeshStandardMaterial({
            color: 0x228B22,
            roughness: 0.6
        });
        
        const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
        leaves.position.y = 7;
        treeGroup.add(leaves);
        
        // Position trees at horizon
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 100 + 150;
        treeGroup.position.set(
            Math.cos(angle) * radius,
            -5,
            -Math.sin(angle) * radius
        );
        
        // Add to scene
        scene.add(treeGroup);
    }
}
            
            // Add some hills in mid-distance
            for (let i = 0; i < 15; i++) {
                const hillGeometry = new THREE.SphereGeometry(20, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
                const hillMaterial = new THREE.MeshStandardMaterial({
                    color: 0x4CAF50, // Green
                    roughness: 0.8
                });
                
                const hill = new THREE.Mesh(hillGeometry, hillMaterial);
                
                // Position hill
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 60 + 80;
                hill.position.set(
                    Math.cos(angle) * radius,
                    -20,
                    -Math.sin(angle) * radius
                );
                
                scene.add(hill);
            }
            
            // Add some butterflies - ONLY for appropriate worlds
            if (currentWorld === 'classic' || currentWorld === 'forest') {
                for (let i = 0; i < 5; i++) {
                    const x = Math.random() * 40 - 20;
                    const y = Math.random() * 3 + 1;
                    const z = Math.random() * 20 - 40;
                    butterflyGroups.push(createButterfly(x, y, z));
                }
            }
            
            // Add some birds - ONLY for appropriate worlds  
            if (currentWorld === 'classic') {
                for (let i = 0; i < 3; i++) {
                    const x = Math.random() * 60 - 30;
                    const y = Math.random() * 10 + 10;
                    const z = Math.random() * 40 - 80;
                    birds.push(createBird(x, y, z));
                }
            }
        }
        
        
        
        // Create player based on selected character
        function createPlayer() {
            // Remove existing player if it exists
            if (player) {
                scene.remove(player);
            }

            // Create character based on selection
            switch (currentCharacter) {
    // CREATE PLAYER SWITCH INJECTION POINT - Package manager will add cases here
    case "apple": player = createAppleCharacter(); break;
    case "carrot": player = createCarrotCharacter(); break;
    case "pumpkin": player = createPumpkinCharacter(); break;
    case "happyface": player = createHappyFaceCharacter(); break;
    case "monster": player = createMonsterCharacter(); break;
    case "atom": player = createAtomCharacter(); break;
    case "slime": player = createSlimeCharacter(); break;
    case "ufo": player = createUFOCharacter(); break;
    case "robot": player = createRobotCharacter(); break;
    case "dragon": player = createDragonCharacter(); break;
    case "ghost": player = createGhostCharacter(); break;
    case "creature": player = createCreatureCharacter(); break;
    // END CREATE PLAYER SWITCH INJECTION POINT
    default:
        debugWarn(`Character ${currentCharacter} not yet extracted - using Happy Face`);
        currentCharacter = "happyface";
        player = createHappyFaceCharacter();
        break;
}

// After the switch statement, add this:
if (!player) {
    console.error('Failed to create player character! Falling back to Happy Face');
    player = createHappyFaceCharacter();
}

// Add null check before accessing player properties
if (player && player.position) {
    // Your existing code that uses player.position
} else {
    console.error('Player object is invalid:', player);
}
            
            // Set player position
player.position.y = playerY;
player.position.z = 0;
player.rotation.x = 0; // Reset rotation

// Make robot, dragon, and ghost face forward down the track
if (currentCharacter === 'robot' || currentCharacter === 'dragon' || currentCharacter === 'ghost') {
    player.rotation.y = Math.PI; // Face forward down the track
} else {
    player.rotation.y = 0; // Default orientation for other characters
}

scene.add(player);

// Initialize ability status bar for new character
if (typeof initializeAbilityStatusBar === 'function') {
    initializeAbilityStatusBar();
}
        }
        
        // Try to unlock a character
        function tryUnlockCharacter(character) {
            if (unlockedCharacters[character]) {
                // Already unlocked, select it
                selectCharacter(character);
                return;
            }
            
            const cost = characterCosts[character];
            if (totalCoins >= cost) {
                totalCoins -= cost;
                unlockedCharacters[character] = true;
                selectCharacter(character);
                updateTotalCoins();
                saveGameData('character_unlock');  // or 'world_unlock'
            } else {
                alert(`Not enough coins! You need ${cost} coins to unlock this character.`);
            }
        }
        
        // Select a character
        function selectCharacter(character) {
            if (!unlockedCharacters[character] && !modModeEnabled) return;
            
            currentCharacter = character;
            updateCharactersInSettings();
            createPlayer(); // Update the player model
            saveGameData();
        }
        


// ==================== GAME SAVE SYSTEM ====================
// This system ensures compatibility across all versions and devices
// =================================================================
// =================================================================

// ===== GOOGLE SIGN-IN SYSTEM =====
let isGoogleUser = false;

// Enable Google Sign-In in Firebase Console first!
// Enable Google Sign-In in Firebase Console first!
function signInWithGoogle() {
    if (!firebase.auth) {
        alert('‚ùå Authentication not available!');
        return;
    }
    
    const provider = new firebase.auth.GoogleAuthProvider();
    provider.addScope('profile');
    provider.addScope('email');
    
    firebase.auth().signInWithPopup(provider)
        .then((result) => {
            debug('‚úÖ Google sign-in successful!');
            const user = result.user;
            
            // Update player info
            playerId = user.uid;
            isGoogleUser = true;
            cloudSaveEnabled = true;
            
            debug('üë§ Signed in as:', user.displayName);
            debug('üìß Email:', user.email);
            
            // Merge anonymous data with Google account
            mergeAnonymousDataToGoogleAccount();
            
            // Hide the Google sign-in button on title screen
            const signInBtn = document.getElementById('googleSignInBtn');
            const authSection = document.getElementById('titleScreenAuth');
            if (signInBtn && authSection) {
                authSection.innerHTML = `
                    <p style="color: #34C759; font-size: 14px; margin: 10px 0;">
                        ‚úÖ Signed in as ${user.displayName}
                    </p>
                    <p style="color: #666; font-size: 12px; font-style: italic;">
                        Your progress syncs across all devices!
                    </p>
                `;
            }
            
            alert(`‚úÖ Signed in as ${user.displayName}!\nYour progress now syncs across all devices!`);
            
        })
        .catch((error) => {
            console.error('‚ùå Google sign-in failed:', error);
            alert('‚ùå Sign-in failed: ' + error.message);
        });
}

function mergeAnonymousDataToGoogleAccount() {
    if (!currentProfile || !playerId) return;
    
    debug('üîÑ Merging anonymous data to Google account...');
    
    // Check if Google account already has data
    firebase.database().ref('profiles/' + playerId + '/Default').once('value')
        .then((snapshot) => {
            const googleData = snapshot.val();
            
            if (googleData) {
                // Google account has existing data - smart merge needed
                const googleCoins = googleData.totalCoins || 0;
                const localCoins = currentProfile.totalCoins || 0;
                
                const googleUnlocks = countUnlocks(googleData);
                const localUnlocks = countUnlocks(currentProfile);
                
                console.log('üîç Merge comparison:');
                console.log('Local:', { coins: localCoins, unlocks: localUnlocks });
                console.log('Google:', { coins: googleCoins, unlocks: googleUnlocks });
                
                // Smart merge: combine the best of both
                const mergedProfile = smartMergeProfiles(currentProfile, googleData);
                
                // Seamless auto-merge using unlock-prioritized logic
                const localMoreProgress = localUnlocks > googleUnlocks || (localUnlocks === googleUnlocks && localCoins <= googleCoins);
                const primarySource = localMoreProgress ? 'Local' : 'Cloud';

                console.log(`üîÑ Auto-syncing: Using ${primarySource} as primary (${localMoreProgress ? localCoins : googleCoins} coins, ${Math.max(localUnlocks, googleUnlocks)} unlocks)`);

                currentProfile = mergedProfile;
                syncProfileToGameState();
                saveProfile();
                showSaveIndicator('‚òÅÔ∏è Progress Synced!');
            } else {
                // No Google data - upload current progress
                debug('üì§ Uploading current progress to Google account...');
                saveProfile();
            }
            
            showSaveIndicator('‚òÅÔ∏è Google Synced');
        })
        .catch((error) => {
            debug('‚ö†Ô∏è Merge failed, saving current data:', error);
            saveProfile();
        });
}

// Count total unlocks for comparison
function countUnlocks(profile) {
    let count = 0;
    
    // Count characters (skip apple since it's default)
    if (profile.unlockedCharacters) {
        count += Object.values(profile.unlockedCharacters).filter(unlocked => unlocked).length - 1;
    }
    
    // Count worlds (skip classic since it's default)  
    if (profile.unlockedWorlds) {
        count += Object.keys(profile.unlockedWorlds).filter(world => profile.unlockedWorlds[world] && world !== 'classic').length;
    }
    
    return count;
}

// Smart merge: prioritize whichever profile has MORE UNLOCKS (more progress)
function smartMergeProfiles(localProfile, cloudProfile) {
    const localUnlocks = countUnlocks(localProfile);
    const cloudUnlocks = countUnlocks(cloudProfile);
    const localCoins = localProfile.totalCoins || 0;
    const cloudCoins = cloudProfile.totalCoins || 0;
    
    console.log('üîç Progress comparison:');
    console.log('Local:', { coins: localCoins, unlocks: localUnlocks });
    console.log('Cloud:', { coins: cloudCoins, unlocks: cloudUnlocks });
    
    let primaryProfile, secondaryProfile;
    
    if (localUnlocks > cloudUnlocks) {
        // Local has more unlocks - it's the primary
        primaryProfile = localProfile;
        secondaryProfile = cloudProfile;
        console.log('üéØ Local profile has more progress - using as primary');
    } else if (cloudUnlocks > localUnlocks) {
        // Cloud has more unlocks - it's the primary
        primaryProfile = cloudProfile;
        secondaryProfile = localProfile;
        console.log('üéØ Cloud profile has more progress - using as primary');
    } else {
        // Same number of unlocks - use the one with FEWER coins (more recent spending)
        if (localCoins <= cloudCoins) {
            primaryProfile = localProfile;
            secondaryProfile = cloudProfile;
            console.log('üéØ Same unlocks, local has fewer coins (more recent spending) - using local');
        } else {
            primaryProfile = cloudProfile;
            secondaryProfile = localProfile;
            console.log('üéØ Same unlocks, cloud has fewer coins (more recent spending) - using cloud');
        }
    }
    
    // Start with the primary profile (the one with more progress)
    const merged = JSON.parse(JSON.stringify(primaryProfile));
    
    // Only add unlocks from secondary if they don't exist in primary
    // (This handles edge cases where someone unlocked different things on different devices)
    if (secondaryProfile.unlockedCharacters) {
        Object.keys(secondaryProfile.unlockedCharacters).forEach(char => {
            if (secondaryProfile.unlockedCharacters[char] && !merged.unlockedCharacters[char]) {
                merged.unlockedCharacters[char] = true;
                console.log('üîÑ Added character unlock from secondary profile:', char);
            }
        });
    }
    
    if (secondaryProfile.unlockedWorlds) {
        Object.keys(secondaryProfile.unlockedWorlds).forEach(world => {
            if (secondaryProfile.unlockedWorlds[world] && !merged.unlockedWorlds[world]) {
                merged.unlockedWorlds[world] = true;
                console.log('üîÑ Added world unlock from secondary profile:', world);
            }
        });
    }
    
    // Keep other progress from primary only (no mixing scores/stats to avoid exploits)
    
    console.log('üéØ Anti-exploit merge result:', {
        coins: merged.totalCoins,
        characters: Object.values(merged.unlockedCharacters).filter(u => u).length,
        worlds: Object.keys(merged.unlockedWorlds).filter(w => merged.unlockedWorlds[w]).length,
        source: primaryProfile === localProfile ? 'local' : 'cloud'
    });
    
    // Handle username - keep the most recent non-default one
    if (cloudProfile.username && !cloudProfile.username.startsWith('Swift') && 
        !cloudProfile.username.startsWith('Bold') && cloudProfile.username.length > 0) {
        merged.username = cloudProfile.username;
    } else if (localProfile.username && !localProfile.username.startsWith('Swift') && 
               !localProfile.username.startsWith('Bold')) {
        merged.username = localProfile.username;
    } else {
        merged.username = cloudProfile.username || localProfile.username || generateDefaultUsername();
    }
    
    // Handle avatar - prefer custom uploaded images over emojis
    if (cloudProfile.avatarType === 'image' && cloudProfile.avatarData) {
        merged.avatarType = cloudProfile.avatarType;
        merged.avatarData = cloudProfile.avatarData;
    } else if (localProfile.avatarType === 'image' && localProfile.avatarData) {
        merged.avatarType = localProfile.avatarType;
        merged.avatarData = localProfile.avatarData;
    } else {
        // Keep whichever has the most recent avatar data
        merged.avatarType = cloudProfile.avatarType || localProfile.avatarType || 'emoji';
        merged.avatarData = cloudProfile.avatarData || localProfile.avatarData || 'üèÉ';
    }
    
    return merged;
}

// Sign out of Google
function signOutGoogle() {
    firebase.auth().signOut()
        .then(() => {
            debug('üëã Signed out of Google');
            
            // Revert to anonymous auth
            initializeCloudSave();
            
            alert('üëã Signed out! Your progress is now device-specific again.');
        })
        .catch((error) => {
            console.error('‚ùå Sign-out failed:', error);
        });
}

// ===== SAVE CODE SYSTEM =====
// Generate a transferable save code
function generateSaveCode() {
    if (!currentProfile || !playerId) {
        alert('‚ùå No save data available to export!');
        return null;
    }
    
    try {
        const exportData = {
            version: SAVE_VERSION,
            playerId: playerId,
            profileName: currentProfileName,
            profile: currentProfile,
            timestamp: Date.now(),
            deviceInfo: navigator.userAgent.substring(0, 50) // For reference
        };
        
        // Compress and encode the data
        const compressed = JSON.stringify(exportData);
        const encoded = btoa(compressed);
        
        // Create readable save code (format: BLITZ-XXXX-XXXX-XXXX)
        const codeBase = encoded.substring(0, 12).toUpperCase();
        const saveCode = `BLITZ-${codeBase.substring(0, 4)}-${codeBase.substring(4, 8)}-${codeBase.substring(8, 12)}`;
        
        debug('üíæ Save code generated:', saveCode);
        return { code: saveCode, fullData: encoded };
        
    } catch (error) {
        console.error('‚ùå Failed to generate save code:', error);
        alert('‚ùå Failed to generate save code!');
        return null;
    }
}

// Use a save code to restore progress
function useSaveCode(saveCode, fullData = null) {
    try {
        let decodedData;
        
        if (fullData) {
            // Use full data if provided
            decodedData = JSON.parse(atob(fullData));
        } else {
            // For now, save codes need the full data
            // In a real implementation, you'd store codes in Firebase
            alert('‚ùå Save codes need the full export data for now!');
            return false;
        }
        
        if (decodedData.version !== SAVE_VERSION) {
            debug('‚ö†Ô∏è Save code is from different version, attempting migration...');
        }
        
        // Validate the data
        if (!decodedData.profile || !decodedData.playerId) {
            throw new Error('Invalid save code data');
        }
        
        debug('üì• Restoring save from code...');
        debug(`üí∞ Restoring ${decodedData.profile.totalCoins} coins`);
        debug(`üë§ Restoring character: ${decodedData.profile.currentCharacter}`);
        
        // Apply the restored profile
        currentProfile = validateAndMigrateProfile(decodedData.profile);
        currentProfileName = decodedData.profileName || "Restored";
        
        // Sync to game state
        syncProfileToGameState();
        
        // Save the restored profile locally and to cloud
        saveProfile();
        
        alert(`‚úÖ Progress restored!\nüí∞ ${currentProfile.totalCoins} coins\nüë§ Character: ${currentProfile.currentCharacter}`);
        
        return true;
        
    } catch (error) {
        console.error('‚ùå Failed to use save code:', error);
        alert('‚ùå Invalid save code!');
        return false;
    }
}

// Show save code to player
function showSaveCode() {
    const result = generateSaveCode();
    if (!result) return;
    
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center;
        z-index: 10000; font-family: Arial, sans-serif;
    `;
    
    modal.innerHTML = `
        <div style="background: white; padding: 30px; border-radius: 15px; max-width: 500px; text-align: center;">
            <h2 style="color: #333; margin-bottom: 20px;">üì± Transfer Your Progress</h2>
            <p style="color: #666; margin-bottom: 20px;">Use this code to restore your progress on any device:</p>
            
            <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin: 20px 0;">
                <h3 style="color: #333; margin: 0 0 10px 0;">Save Code:</h3>
                <div style="font-size: 24px; font-weight: bold; color: #007AFF; letter-spacing: 2px;">${result.code}</div>
            </div>
            
            <textarea readonly style="width: 100%; height: 60px; font-size: 10px; margin: 10px 0; padding: 10px;" 
                onclick="this.select()">${result.fullData}</textarea>
            <p style="font-size: 12px; color: #999;">Copy both the code AND the text above</p>
            
            <div style="margin-top: 20px;">
                <button onclick="this.parentElement.parentElement.parentElement.remove()" 
                    style="background: #007AFF; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 16px;">
                    Done
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// Show restore from code dialog
function showRestoreCode() {
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center;
        z-index: 10000; font-family: Arial, sans-serif;
    `;
    
    modal.innerHTML = `
        <div style="background: white; padding: 30px; border-radius: 15px; max-width: 500px; text-align: center;">
            <h2 style="color: #333; margin-bottom: 20px;">üì• Restore Your Progress</h2>
            <p style="color: #666; margin-bottom: 20px;">Enter your save code and data:</p>
            
            <input type="text" id="saveCodeInput" placeholder="BLITZ-XXXX-XXXX-XXXX" 
                style="width: 100%; padding: 12px; margin: 10px 0; border: 2px solid #ddd; border-radius: 8px; text-align: center; font-size: 16px; letter-spacing: 1px;">
            
            <textarea id="saveDataInput" placeholder="Paste the full save data here..." 
                style="width: 100%; height: 80px; padding: 12px; margin: 10px 0; border: 2px solid #ddd; border-radius: 8px; font-size: 12px;"></textarea>
            
            <div style="margin-top: 20px;">
                <button onclick="restoreFromInputs()" 
                    style="background: #34C759; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 16px; margin-right: 10px;">
                    Restore Progress
                </button>
                <button onclick="this.parentElement.parentElement.parentElement.remove()" 
                    style="background: #666; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 16px;">
                    Cancel
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// Restore from save code
function restoreFromInputs() {
    const code = document.getElementById('saveCodeInput').value.trim();
    const data = document.getElementById('saveDataInput').value.trim();
    
    if (!code || !data) {
        alert('‚ùå Please enter both the save code and data!');
        return;
    }
    
    try {
        const decodedData = JSON.parse(atob(data));
        
        debug('üì• Restoring save from code...');
        debug(`üí∞ Restoring ${decodedData.profile.totalCoins} coins`);
        
        currentProfile = validateAndMigrateProfile(decodedData.profile);
        currentProfileName = decodedData.profileName || "Restored";
        
        syncProfileToGameState();
        saveGameData('manual_save');
        
        alert(`‚úÖ Progress restored!\nüí∞ ${currentProfile.totalCoins} coins\nüë§ Character: ${currentProfile.currentCharacter}`);
        
        document.querySelector('[style*="z-index: 10000"]').remove();
        
    } catch (error) {
        console.error('‚ùå Failed to restore save:', error);
        alert('‚ùå Invalid save code or data!');
    }
}


// Current save system version - increment when making breaking changes
const SAVE_VERSION = "1.0";
const GAME_ID = "runningBlitzEndlessRunner";

// Default save profile template
const DEFAULT_PROFILE = {
    version: SAVE_VERSION,
    gameId: GAME_ID,
    created: null,
    lastPlayed: null,
    
    // Player progress
    totalCoins: 0,
    highScore: 0,
    totalGamesPlayed: 0,
    totalTimePlayed: 0, // in seconds
    
    // Character data
currentCharacter: 'apple',
unlockedCharacters: {
    apple: true,
    carrot: false,
    pumpkin: false,
    happyface: false,
    monster: false,
    atom: false,
    slime: false,
    ufo: false,
    robot: false,
    dragon: false,
    ghost: false
},

// World data
currentWorld: 'classic',
unlockedWorlds: {
    classic: true
},
    
    // Settings
    soundEffectsEnabled: true,
    backgroundMusicEnabled: true,
    currentTrack: 'ambient',
    modModeEnabled: false,
    
    // Profile customization
    username: null, // Will be auto-generated if null
    avatarType: 'emoji', // 'emoji' or 'image'
    avatarData: 'üèÉ', // emoji character or base64 image data
    
    // Leaderboard (moved into profile)
    personalBests: [],
    
    // Achievement system (ready for future)
    achievements: {},
    unlockedAchievements: [],
    
    // Statistics (ready for future)
    stats: {
        coinsCollected: 0,
        obstaclesAvoided: 0,
        streamsJumped: 0,
        powerUpsCollected: 0,
        meteorsAvoided: 0,
        characterUsageTime: {}
    },
    
    // Future expansion data
    customData: {}
};

// Current active profile
let currentProfile = null;
let currentProfileName = "Default";

// ADD THESE CLOUD SAVE VARIABLES
let playerId = null;
let cloudSaveEnabled = false;

// Initialize Firebase Auth (anonymous)
function initializeCloudSave() {
    console.log('üî• Starting cloud save initialization...');
    
    // Check if already signed in to avoid creating multiple anonymous accounts
    if (firebase.auth().currentUser) {
        console.log('üî• Already authenticated, using existing user');
        playerId = firebase.auth().currentUser.uid;
        cloudSaveEnabled = true;
        
        // IMPORTANT: For anonymous users, always prioritize local data over cloud
        if (firebase.auth().currentUser.isAnonymous) {
            console.log('üë§ Anonymous user - prioritizing local profile data');
            prioritizeLocalProfileForAnonymous();
        } else {
            syncProfileWithCloud();
        }
        return;
    }
    
    firebase.auth().signInAnonymously()
        .then((userCredential) => {
            playerId = userCredential.user.uid;
            cloudSaveEnabled = true;
            debug('üî• Cloud save enabled! Anonymous Player ID:', playerId.substring(0, 8) + '...');
            
            // For new anonymous users, always start with local profile
            console.log('üë§ New anonymous user - using local profile data');
            prioritizeLocalProfileForAnonymous();
        })
        .catch((error) => {
            debug('‚ö†Ô∏è Cloud save unavailable, using local storage:', error);
            cloudSaveEnabled = false;
        });
}

// Prioritize local profile data for anonymous users
function prioritizeLocalProfileForAnonymous() {
    if (!firebase.auth().currentUser || !firebase.auth().currentUser.isAnonymous) {
        return; // Only for anonymous users
    }
    
    console.log('üë§ Setting up unique anonymous profile...');
    
    // Check if we have a local profile already
    const localProfile = currentProfile;
    
    if (localProfile && (localProfile.username || localProfile.totalCoins > 0)) {
        // User has local progress - keep it and upload to cloud
        console.log('üì± Found local progress - preserving it');
        
        // Ensure anonymous user has unique username if they don't have one
        if (!localProfile.username || localProfile.username === 'Anonymous') {
            localProfile.username = generateDefaultUsername();
            console.log('üéÆ Generated unique username for anonymous user:', localProfile.username);
        }
        
        // Ensure they have default avatar if missing
        if (!localProfile.avatarType) {
            localProfile.avatarType = 'emoji';
            localProfile.avatarData = 'üèÉ';
        }
        
        // Save the local profile to cloud (don't sync down)
        currentProfile = localProfile;
        saveProfile();
        showSaveIndicator('üë§ Anonymous Profile Created');
        
    } else {
        // No local profile - create a fresh one
        console.log('üÜï Creating fresh anonymous profile');
        
        currentProfile.username = generateDefaultUsername();
        currentProfile.avatarType = 'emoji';
        currentProfile.avatarData = 'üèÉ';
        
        // Save the new profile
        saveProfile();
        syncProfileToGameState();
        showSaveIndicator('üë§ New Anonymous Profile');
    }
}

// Visual save indicator
function showSaveIndicator(message) {
    let indicator = document.getElementById('saveIndicator');
    if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'saveIndicator';
        indicator.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        `;
        document.body.appendChild(indicator);
    }
    
    indicator.textContent = message;
    indicator.style.opacity = '1';
    
    setTimeout(() => {
        indicator.style.opacity = '0';
    }, 2000);
}

// Sync profile with cloud when Firebase connects
function syncProfileWithCloud() {
    if (!cloudSaveEnabled || !playerId || !currentProfileName) return;
    
    // Special handling for anonymous users
    if (firebase.auth().currentUser && firebase.auth().currentUser.isAnonymous) {
        console.log('üë§ Anonymous user - skipping cloud sync to preserve unique profile');
        prioritizeLocalProfileForAnonymous();
        return;
    }
    
    // Check if cloud has newer data for current player (only for signed-in users)
    firebase.database().ref('profiles/' + playerId + '/' + currentProfileName).once('value')
        .then((snapshot) => {
            const cloudProfile = snapshot.val();
            
            if (cloudProfile) {
                // Found data for current player ID
                const cloudTime = new Date(cloudProfile.lastPlayed || 0).getTime();
                const localTime = new Date(currentProfile.lastPlayed || 0).getTime();
                
                if (cloudTime > localTime) {
                    debug('‚òÅÔ∏è Cloud profile is newer, syncing down...');
                    currentProfile = validateAndMigrateProfile(cloudProfile);
                    syncProfileToGameState();
                    showSaveIndicator('‚òÅÔ∏è Cloud Synced');
                } else {
                    debug('üíæ Local profile is newer, syncing up...');
                    saveProfile();
                }
            } else {
                // No data for current player ID - check for orphaned data from domain change
                debug('üîç No data for current player, checking for orphaned saves...');
                searchForOrphanedSaveData();
            }
        })
        .catch((error) => {
            debug('‚ö†Ô∏è Cloud sync failed:', error);
        });
}

// New function to find save data from old domain
function searchForOrphanedSaveData() {
    console.log('üîç Searching for orphaned save data...');
    
    // IMPORTANT: Only search for orphaned data if we have local data that suggests
    // this device previously had progress (to prevent giving random profiles to new users)
    const hasLocalProgress = checkForLocalProgressIndicators();
    
    if (!hasLocalProgress) {
        console.log('üì± No local progress indicators found - this appears to be a truly new user');
        return;
    }
    
    console.log('üì± Local progress indicators found - searching for orphaned data...');
    
    // Get all profiles to find potential matches
    firebase.database().ref('profiles').once('value')
        .then((snapshot) => {
            const allProfiles = snapshot.val();
            console.log('üìä Found profiles:', allProfiles ? Object.keys(allProfiles).length : 0);
            
            if (!allProfiles) {
                console.log('‚ùå No profiles found in database');
                return;
            }
            
            // Look for profiles that match THIS SPECIFIC device's characteristics
            Object.keys(allProfiles).forEach(oldPlayerId => {
                if (oldPlayerId === playerId) return; // Skip current player
                
                console.log('üîç Checking player:', oldPlayerId.substring(0, 8) + '...');
                
                const oldPlayerProfiles = allProfiles[oldPlayerId];
                if (oldPlayerProfiles && oldPlayerProfiles.Default) {
                    const oldProfile = oldPlayerProfiles.Default;
                    
                    console.log('üìã Found profile with coins:', oldProfile.totalCoins || 0);
                    
                    // Check if this profile matches THIS device's previous data
                    if (isThisDevicesOldProfile(oldProfile)) {
                        console.log('‚úÖ Profile matches THIS device, migrating...');
                        console.log('üí∞ Migrating coins:', oldProfile.totalCoins);
                        
                        // Migrate the matching profile
                        currentProfile = validateAndMigrateProfile(oldProfile);
                        syncProfileToGameState();
                        saveProfile(currentProfileName, 'domain_migration');
                        showSaveIndicator('üîÑ Data Recovered!');
                        updateTotalCoins();
                        
                        console.log('‚úÖ Migration complete!');
                        return;
                    }
                }
            });
        })
        .catch((error) => {
            console.error('‚ùå Orphaned data search failed:', error);
        });
}

// Check if this device has any indicators of previous progress
function checkForLocalProgressIndicators() {
    // Check for any local storage that suggests this device had progress before
    const legacyData = localStorage.getItem('endlessRunnerData');
    const migrationComplete = localStorage.getItem('runningBlitzEndlessRunner_migrationComplete');
    const anyGameData = localStorage.getItem('runningBlitzEndlessRunner_profile_Default');
    
    // Also check browser/device characteristics that might indicate previous use
    const hasGameHistory = localStorage.length > 5; // Arbitrary threshold
    
    return !!(legacyData || anyGameData || (migrationComplete && hasGameHistory));
}

// More strict matching - only migrate if it's very likely THIS device's data
function isThisDevicesOldProfile(profile) {
    if (!profile) return false;
    
    // Get current local data if any
    const localData = localStorage.getItem('runningBlitzEndlessRunner_profile_Default');
    
    if (localData) {
        try {
            const parsed = JSON.parse(localData);
            // If local data has progress, only migrate if cloud has MORE progress
            // This prevents new users from getting old data
            if (parsed.totalCoins > 0) {
                return (profile.totalCoins || 0) > parsed.totalCoins;
            }
        } catch (e) {
            // Ignore parsing errors
        }
    }
    
    // For true orphan detection, require significant progress
    // AND some device-specific indicators
    const hasSignificantProgress = (profile.totalCoins || 0) > 100;
    const hasGameHistory = profile.totalGamesPlayed > 5;
    
    // Only migrate if there's substantial progress AND this looks like a returning user
    return hasSignificantProgress && hasGameHistory && checkForLocalProgressIndicators();
}


function shouldMigrateProfile(profile) {
    if (!profile) return false;
    
    const hasCoins = (profile.totalCoins || 0) > 0;
    const hasScore = (profile.highScore || 0) > 0;
    const hasUnlockedChars = profile.unlockedCharacters && 
        Object.values(profile.unlockedCharacters).some(unlocked => unlocked);
    
    console.log('üîç Migration check:', {
        coins: profile.totalCoins || 0,
        score: profile.highScore || 0,
        hasCoins,
        hasScore,
        hasUnlockedChars,
        shouldMigrate: hasCoins || hasScore || hasUnlockedChars
    });
    
    return hasCoins || hasScore || hasUnlockedChars;
}

// Initialize save system
function initializeSaveSystem() {
    debug('üóÑÔ∏è Initializing future-proof save system...');
    
    // Check for legacy save data and migrate
    migrateLegacySaveData();
    
    // Load or create default profile
    loadProfile("Default");
    
    // Initialize profile with username/avatar - ADD THIS LINE
    initializeProfile();
    
    // Initialize cloud save after profile is loaded
    setTimeout(() => {
        initializeCloudSave();
    }, 1000);
    
    // Load global leaderboard after cloud save is ready
    setTimeout(() => {
        if (cloudSaveEnabled) {
            loadGlobalLeaderboard(); // Load global scores on startup
        }
    }, 3000);

    // Load global leaderboard after cloud save is ready
    setTimeout(() => {
        if (cloudSaveEnabled) {
            loadGlobalLeaderboard(); // Load global scores on startup
            
            // Update any existing global entries with current avatar (after a delay)
            setTimeout(() => {
                updateGlobalLeaderboardAvatar();
            }, 2000);
        }
    }, 3000);
    
    debug('‚úÖ Save system initialized successfully!');
}



// Migrate old save data to new profile system
function migrateLegacySaveData() {
    try {
        // Check if migration has already been completed
        const migrationComplete = localStorage.getItem('runningBlitzEndlessRunner_migrationComplete');
        if (migrationComplete) {
            debug('‚ÑπÔ∏è Legacy migration already completed - skipping');
            return;
        }
        
        // Check for old save format
        const legacySaveData = localStorage.getItem('endlessRunnerData');
        const legacyLeaderboard = localStorage.getItem('endlessRunnerLeaderboard');
        
        if (legacySaveData) {
            debug('üì¶ Found legacy save data - migrating...');
            
            const oldData = JSON.parse(legacySaveData);
            
            // Create new profile with legacy data
            const migratedProfile = JSON.parse(JSON.stringify(DEFAULT_PROFILE));
            
            // Migrate all the old data
            migratedProfile.totalCoins = oldData.totalCoins || 0;
            migratedProfile.currentCharacter = oldData.currentCharacter || 'apple';
            migratedProfile.currentWorld = oldData.currentWorld || 'classic';
            migratedProfile.unlockedWorlds = oldData.unlockedWorlds || {classic: true};
            migratedProfile.soundEffectsEnabled = oldData.soundEffectsEnabled !== undefined ? oldData.soundEffectsEnabled : true;
            migratedProfile.backgroundMusicEnabled = oldData.backgroundMusicEnabled !== undefined ? oldData.backgroundMusicEnabled : true;
            migratedProfile.modModeEnabled = oldData.modModeEnabled || false;
            
            // Migrate character unlocks
            if (oldData.unlockedCharacters) {
                Object.keys(oldData.unlockedCharacters).forEach(char => {
                    if (migratedProfile.unlockedCharacters.hasOwnProperty(char)) {
                        migratedProfile.unlockedCharacters[char] = oldData.unlockedCharacters[char];
                    }
                });
            }
            
            // Set timestamps
            migratedProfile.created = new Date().toISOString();
            migratedProfile.lastPlayed = new Date().toISOString();
            migratedProfile.profileId = generateProfileId();
            migratedProfile.profileName = "Default";
            
            // Migrate leaderboard if it exists
            if (legacyLeaderboard) {
                try {
                    const oldLeaderboard = JSON.parse(legacyLeaderboard);
                    migratedProfile.personalBests = oldLeaderboard;
                } catch (e) {
                    debug('‚ö†Ô∏è Could not migrate leaderboard data');
                }
            }
            
            // Save the migrated profile
            const saveKey = `${GAME_ID}_profile_Default`;
            localStorage.setItem(saveKey, JSON.stringify(migratedProfile));
            updateProfileList("Default");
            
            debug('‚úÖ Legacy data migrated successfully!');
            debug(`üí∞ Restored ${migratedProfile.totalCoins} coins`);
            debug(`üë§ Restored character: ${migratedProfile.currentCharacter}`);
            
            // Keep the old data for a while as backup, but mark it as migrated
            localStorage.setItem('endlessRunnerData_migrated', legacySaveData);
            
            // Mark migration as complete
            localStorage.setItem('runningBlitzEndlessRunner_migrationComplete', 'true');
            
        } else {
            debug('‚ÑπÔ∏è No legacy save data found - starting fresh');
            // Still mark migration as complete so we don't check again
            localStorage.setItem('runningBlitzEndlessRunner_migrationComplete', 'true');
        }
        
    } catch (error) {
        console.error('‚ùå Error during legacy migration:', error);
        debug('üîÑ Creating fresh profile instead');
        // Mark migration as complete even if it failed
        localStorage.setItem('runningBlitzEndlessRunner_migrationComplete', 'true');
    }
}

// Create a new profile
function createProfile(profileName, baseProfile = null) {
    const profile = baseProfile ? JSON.parse(JSON.stringify(baseProfile)) : JSON.parse(JSON.stringify(DEFAULT_PROFILE));
    
    profile.created = new Date().toISOString();
    profile.lastPlayed = new Date().toISOString();
    
    // Generate unique ID for cross-device sync
    profile.profileId = generateProfileId();
    profile.profileName = profileName;
    
    return profile;
}

// Generate unique profile ID
function generateProfileId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
}

// Save current profile (Cloud Enhanced) - with save reasons
function saveProfile(profileName = currentProfileName, saveReason = 'general') {
    if (!currentProfile) {
        console.error('‚ùå No active profile to save!');
        return false;
    }
    
    // Define which reasons should show the save indicator
    const importantSaveReasons = [
        'game_end',
        'character_unlock',
        'world_unlock', 
        'high_score',
        'major_purchase',
        'settings_change',
        'manual_save'
    ];
    
    const showIndicator = importantSaveReasons.includes(saveReason);
    
    try {
        // Update timestamps and current data
        currentProfile.lastPlayed = new Date().toISOString();
        currentProfile.version = SAVE_VERSION;
        
        // Sync current game state to profile
        syncGameStateToProfile();
        
        // Save to localStorage with versioned key (local backup)
        const saveKey = `${GAME_ID}_profile_${profileName}`;
        localStorage.setItem(saveKey, JSON.stringify(currentProfile));
        
        // Update profile list
        updateProfileList(profileName);
        
        // Save to cloud if available
        if (cloudSaveEnabled && playerId) {
            firebase.database().ref('profiles/' + playerId + '/' + profileName).set(currentProfile)
                .then(() => {
                    debug(`‚òÅÔ∏è Profile "${profileName}" saved to cloud! (${saveReason})`);
                    if (showIndicator) {
                        showSaveIndicator('‚òÅÔ∏è Progress Saved');
                    }
                })
                .catch((error) => {
                    debug('‚ö†Ô∏è Cloud save failed, local backup saved:', error);
                    if (showIndicator) {
                        showSaveIndicator('üíæ Local Saved');
                    }
                });
        } else {
            if (showIndicator) {
                showSaveIndicator('üíæ Progress Saved');
            }
        }
        
        debug(`üíæ Profile "${profileName}" saved successfully! (${saveReason})`);
        return true;
        
    } catch (error) {
        console.error('‚ùå Failed to save profile:', error);
        return false;
    }
}

// Load profile
function loadProfile(profileName) {
    try {
        const saveKey = `${GAME_ID}_profile_${profileName}`;
        const savedData = localStorage.getItem(saveKey);
        
        if (savedData) {
            debug(`üìÇ Loading profile "${profileName}"...`);
            
            const profile = JSON.parse(savedData);
            
            // Validate and migrate if necessary
            currentProfile = validateAndMigrateProfile(profile);
            currentProfileName = profileName;
            
            // Apply profile data to game state
            syncProfileToGameState();
            
            debug(`‚úÖ Profile "${profileName}" loaded successfully!`);
debug(`üí∞ Current balance: ${currentProfile.totalCoins} coins`);
debug(`üë§ Current character: ${currentProfile.currentCharacter}`);
            
        } else {
            // Create new profile
            debug(`üÜï Creating new profile "${profileName}"...`);
            
            currentProfile = createProfile(profileName);
            currentProfileName = profileName;
            
            // Set default game state
            syncProfileToGameState();
            
            // Save the new profile
            saveProfile(profileName);
        }
        
        return true;
        
    } catch (error) {
        console.error('‚ùå Failed to load profile:', error);
        
        // Fallback to default profile
        currentProfile = createProfile(profileName);
        currentProfileName = profileName;
        syncProfileToGameState();
        
        return false;
    }
}

// Validate and migrate profile data
function validateAndMigrateProfile(profile) {
    debug(`üîÑ Validating profile (version: ${profile.version || 'unknown'})...`);
    
    // Create a clean profile with current structure
    const migratedProfile = JSON.parse(JSON.stringify(DEFAULT_PROFILE));
    
    // Copy over valid data from old profile
    if (profile.version) {
        migratedProfile.version = profile.version;
    }
    
    // Migrate basic data (always compatible)
    migratedProfile.totalCoins = profile.totalCoins || 0;
    migratedProfile.currentCharacter = profile.currentCharacter || 'apple';
    migratedProfile.currentWorld = profile.currentWorld || 'classic';
    migratedProfile.soundEffectsEnabled = profile.soundEffectsEnabled !== undefined ? profile.soundEffectsEnabled : true;
    migratedProfile.backgroundMusicEnabled = profile.backgroundMusicEnabled !== undefined ? profile.backgroundMusicEnabled : true;
    migratedProfile.modModeEnabled = profile.modModeEnabled || false;
    
    // Migrate character unlocks (merge with new characters)
    if (profile.unlockedCharacters) {
        Object.keys(profile.unlockedCharacters).forEach(char => {
            if (migratedProfile.unlockedCharacters.hasOwnProperty(char)) {
                migratedProfile.unlockedCharacters[char] = profile.unlockedCharacters[char];
            }
        });
    }

    // Migrate world unlocks (merge with new worlds)
if (profile.unlockedWorlds) {
    Object.keys(profile.unlockedWorlds).forEach(world => {
        if (migratedProfile.unlockedWorlds.hasOwnProperty(world)) {
            migratedProfile.unlockedWorlds[world] = profile.unlockedWorlds[world];
        }
    });
}
    
    // Migrate leaderboard data
    if (profile.personalBests) {
        migratedProfile.personalBests = profile.personalBests;
    }
    
    // Migrate timestamps
    migratedProfile.created = profile.created || new Date().toISOString();
    migratedProfile.lastPlayed = new Date().toISOString();
    
    // Migrate profile ID
    migratedProfile.profileId = profile.profileId || generateProfileId();
    migratedProfile.profileName = profile.profileName || currentProfileName;
    
    // Migrate stats (if they exist)
    if (profile.stats) {
        Object.keys(profile.stats).forEach(stat => {
            if (migratedProfile.stats.hasOwnProperty(stat)) {
                migratedProfile.stats[stat] = profile.stats[stat];
            }
        });
    }
    
    // Migrate profile customization
    migratedProfile.username = profile.username || null; // Will be generated later if null
    migratedProfile.avatarType = profile.avatarType || 'emoji';
    migratedProfile.avatarData = profile.avatarData || 'üèÉ';
    
    // Migrate custom data for future compatibility
    if (profile.customData) {
        migratedProfile.customData = profile.customData;
    }
    
    // Update version
    migratedProfile.version = SAVE_VERSION;
    
    debug('‚úÖ Profile validation and migration completed!');
    return migratedProfile;
}

// Sync current game state to profile
function syncGameStateToProfile() {
    if (!currentProfile) return;

    debug('üîÑ Syncing game state to profile...');
    debug('Current totalCoins in game:', totalCoins);
    debug('Current totalCoins in profile before sync:', currentProfile.totalCoins);
    
    currentProfile.totalCoins = totalCoins;
    currentProfile.currentCharacter = currentCharacter;
    currentProfile.unlockedCharacters = {...unlockedCharacters};
    currentProfile.currentWorld = currentWorld;
    currentProfile.unlockedWorlds = {...unlockedWorlds};
    currentProfile.soundEffectsEnabled = soundEffectsEnabled;
    currentProfile.backgroundMusicEnabled = backgroundMusicEnabled;
    currentProfile.modModeEnabled = modModeEnabled;
    currentProfile.currentTrack = currentTrack;
    
    // Sync profile customization (these are managed by the profile screen)
    // Don't overwrite with undefined values
    if (!currentProfile.username) {
        currentProfile.username = generateDefaultUsername();
    }
    if (!currentProfile.avatarType) {
        currentProfile.avatarType = 'emoji';
        currentProfile.avatarData = 'üèÉ';
    }

    debug('Current totalCoins in profile after sync:', currentProfile.totalCoins);

    
    // Update high score
    if (score > (currentProfile.highScore || 0)) {
        currentProfile.highScore = score;
    }
    
    // Sync leaderboard
    currentProfile.personalBests = [...leaderboard];
}

// Sync profile data to game state
function syncProfileToGameState() {
    if (!currentProfile) return;

    debug('üìÇ Syncing profile to game state...');
    debug('Profile totalCoins:', currentProfile.totalCoins);
    debug('Game totalCoins before sync:', totalCoins);
    
    totalCoins = currentProfile.totalCoins || 0;
    currentCharacter = currentProfile.currentCharacter || 'apple';
    unlockedCharacters = {...currentProfile.unlockedCharacters};
    currentWorld = currentProfile.currentWorld || 'classic';
    unlockedWorlds = currentProfile.unlockedWorlds || {classic: true};
    soundEffectsEnabled = currentProfile.soundEffectsEnabled !== undefined ? currentProfile.soundEffectsEnabled : true;
    backgroundMusicEnabled = currentProfile.backgroundMusicEnabled !== undefined ? currentProfile.backgroundMusicEnabled : true;
    modModeEnabled = currentProfile.modModeEnabled || false;
    currentTrack = currentProfile.currentTrack || 'ambient';
    selectedTrack = currentTrack;
    modModeEnabled = currentProfile.modModeEnabled || false;
    
    // Initialize profile customization if missing
    if (!currentProfile.username) {
        currentProfile.username = generateDefaultUsername();
        debug('üéÆ Generated username:', currentProfile.username);
    }
    if (!currentProfile.avatarType) {
        currentProfile.avatarType = 'emoji';
        currentProfile.avatarData = 'üèÉ';
    }

    debug('Game totalCoins after sync:', totalCoins);

    
    // Sync leaderboard
    if (currentProfile.personalBests) {
        leaderboard = [...currentProfile.personalBests];
        if (leaderboard.length > 0) {
            currentHighScore = leaderboard[0].score;
        }
    }
    
// Sync profile data
    if (currentProfile.username) {
        // Update any displayed username elements
        const profileNameElem = document.getElementById('profilePlayerName');
        if (profileNameElem) {
            profileNameElem.textContent = currentProfile.username;
        }
    }

    // Sync high score to a global variable if you need it elsewhere
    if (currentProfile.highScore) {
        window.playerHighScore = currentProfile.highScore;
    }

    // Update UI elements
    updateTotalCoins();
    updateLeaderboardDisplay();
    
    // Update checkboxes
    setTimeout(() => {
        const soundCheckbox = document.getElementById('soundEffectsCheckbox');
        const musicCheckbox = document.getElementById('backgroundMusicCheckbox');
        
        if (soundCheckbox) soundCheckbox.checked = soundEffectsEnabled;
        if (musicCheckbox) musicCheckbox.checked = backgroundMusicEnabled;
    }, 100);
}

// Update global leaderboard display in pause menu tab
function updateGlobalLeaderboardDisplay() {
    const tbody = document.getElementById('globalLeaderboardBody');
    const rankDisplay = document.getElementById('globalPlayerRank');
    
    if (!tbody) return;
    
    // Load fresh data
    loadGlobalLeaderboard();
    
    setTimeout(() => {
        // Clear existing content
        tbody.innerHTML = '';
        
        if (globalLeaderboard.length === 0) {
            tbody.innerHTML = `
                <tr>
                    <td colspan="4" style="text-align: center; padding: 40px; color: white;">
                        üèÜ Be the first on the global leaderboard!<br>
                        <small style="color: #ccc;">Complete a game to see your score here!</small>
                    </td>
                </tr>
            `;
            return;
        }
        
        // Add top 15 scores (more than local leaderboard)
        globalLeaderboard.slice(0, 15).forEach((entry, index) => {
            const rank = index + 1;
            const isCurrentPlayer = entry.playerId === playerId;
            
            let rankDisplay = `#${rank}`;
            if (rank === 1) rankDisplay = 'ü•á';
            else if (rank === 2) rankDisplay = 'ü•à';
            else if (rank === 3) rankDisplay = 'ü•â';
            
            const rowStyle = isCurrentPlayer ? 'background: rgba(0, 255, 0, 0.1); color: #00FF00;' : '';
            
            // Get avatar for this entry
            let avatarHtml = 'üèÉ'; // Default emoji
            if (entry.avatar) {
                if (entry.avatarType === 'image' && entry.avatar) {
                    avatarHtml = `<img src="${entry.avatar}" style="width: 20px; height: 20px; border-radius: 50%; object-fit: cover; vertical-align: middle;">`;
                } else {
                    avatarHtml = entry.avatar || 'üèÉ';
                }
            }

            tbody.innerHTML += `
                <tr style="${rowStyle}">
                    <td>${rankDisplay}</td>
                    <td style="display: flex; align-items: center; gap: 6px;">
                        <span style="font-size: 16px;">${avatarHtml}</span>
                        <span>${entry.playerName || 'Anonymous'}</span>
                    </td>
                    <td>${entry.score.toLocaleString()}</td>
                    <td>${entry.character}</td>
                </tr>
            `;
        });
        
        // Update player rank display
        if (playerGlobalRank && rankDisplay) {
            rankDisplay.textContent = `üèÜ Your Global Rank: #${playerGlobalRank} out of ${globalLeaderboard.length} players`;
            rankDisplay.style.color = '#FFD700';
        } else if (rankDisplay) {
            rankDisplay.textContent = `üåç ${globalLeaderboard.length} players competing worldwide`;
            rankDisplay.style.color = '#ccc';
        }
        
    }, 1000); // Wait for data to load
}

// Update profile list in localStorage
function updateProfileList(profileName) {
    try {
        const profileListKey = `${GAME_ID}_profiles`;
        let profileList = [];
        
        const savedList = localStorage.getItem(profileListKey);
        if (savedList) {
            profileList = JSON.parse(savedList);
        }
        
        // Add profile to list if not already there
        if (!profileList.includes(profileName)) {
            profileList.push(profileName);
            localStorage.setItem(profileListKey, JSON.stringify(profileList));
        }
        
    } catch (error) {
        console.error('‚ùå Failed to update profile list:', error);
    }
}

// Get list of all profiles
function getProfileList() {
    try {
        const profileListKey = `${GAME_ID}_profiles`;
        const savedList = localStorage.getItem(profileListKey);
        
        if (savedList) {
            return JSON.parse(savedList);
        }
        
        return ["Default"];
        
    } catch (error) {
        console.error('‚ùå Failed to get profile list:', error);
        return ["Default"];
    }
}

// Export profile data (for sharing between devices)
function exportProfile(profileName = currentProfileName) {
    try {
        const saveKey = `${GAME_ID}_profile_${profileName}`;
        const profileData = localStorage.getItem(saveKey);
        
        if (profileData) {
            const exportData = {
                exportDate: new Date().toISOString(),
                gameVersion: SAVE_VERSION,
                profileName: profileName,
                profileData: JSON.parse(profileData)
            };
            
            return JSON.stringify(exportData, null, 2);
        }
        
        return null;
        
    } catch (error) {
        console.error('‚ùå Failed to export profile:', error);
        return null;
    }
}

// Import profile data (for sharing between devices)
function importProfile(exportedData, newProfileName = null) {
    try {
        const importData = JSON.parse(exportedData);
        
        // Validate import data
        if (!importData.profileData || !importData.gameVersion) {
            throw new Error('Invalid export data format');
        }
        
        const profileName = newProfileName || importData.profileName || "Imported";
        const profile = validateAndMigrateProfile(importData.profileData);
        
        profile.profileName = profileName;
        
        // Save imported profile
        const saveKey = `${GAME_ID}_profile_${profileName}`;
        localStorage.setItem(saveKey, JSON.stringify(profile));
        
        updateProfileList(profileName);
        
        debug(`üì• Profile "${profileName}" imported successfully!`);
        return true;
        
    } catch (error) {
        console.error('‚ùå Failed to import profile:', error);
        return false;
    }
}

// Wrapper functions for compatibility
function saveGameData(reason = 'general') {
    saveProfile(currentProfileName, reason);
}

function loadGameData(ignoreModMode = false) {
    // The new system handles mod mode automatically
    syncProfileToGameState();
}
        
        // Update total coins display
        function updateTotalCoins() {
            document.getElementById('totalCoins').textContent = `Coins: ${totalCoins}`;
        }


        // Generate a default username
function generateDefaultUsername() {
    const adjectives = ['Swift', 'Bold', 'Epic', 'Quick', 'Super', 'Mega', 'Ultra', 'Fast', 'Cool', 'Star'];
    const nouns = ['Runner', 'Dasher', 'Racer', 'Player', 'Hero', 'Champion', 'Speedster', 'Sprinter', 'Blitzer', 'Master'];
    const adj = adjectives[Math.floor(Math.random() * adjectives.length)];
    const noun = nouns[Math.floor(Math.random() * nouns.length)];
    const number = Math.floor(Math.random() * 1000);
    return `${adj}${noun}${number}`;
}

// Initialize profile with username/avatar if missing
function initializeProfile() {
    if (!currentProfile) {
        currentProfile = {};
    }
    
    // Generate username if missing
    if (!currentProfile.username) {
        currentProfile.username = generateDefaultUsername();
        debug('üéÆ Generated username:', currentProfile.username);
    }
    
    // Set default avatar if missing
    if (!currentProfile.avatarType) {
        currentProfile.avatarType = 'emoji';
        currentProfile.avatarData = 'üèÉ';
    }
    
    // For anonymous users, always ensure they have a unique profile
    if (firebase.auth && firebase.auth().currentUser && firebase.auth().currentUser.isAnonymous) {
        // Make sure anonymous users get a fresh username if it's generic
        if (currentProfile.username === 'Anonymous' || !currentProfile.username) {
            currentProfile.username = generateDefaultUsername();
            debug('üë§ Generated fresh username for anonymous user:', currentProfile.username);
        }
    }
    
    // Save the updated profile
    saveGameData('profile_init');
}

// Trigger avatar upload
function triggerAvatarUpload() {
    document.getElementById('avatarUpload').click();
}

// Handle avatar upload
function handleAvatarUpload(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    // Check file size (limit to 2MB)
    if (file.size > 2 * 1024 * 1024) {
        showProfileErrorNotification('Image too large!', 'Please choose an image under 2MB');
        return;
    }
    
    // Check file type
    if (!file.type.startsWith('image/')) {
        showProfileErrorNotification('Invalid file type!', 'Please select a valid image file');
        return;
    }
    
    const reader = new FileReader();
    reader.onload = function(e) {
        const base64Data = e.target.result;
        
        // Update avatar display
        setAvatarImage(base64Data);
        
    // Save to profile
        if (currentProfile) {
            currentProfile.avatarType = 'image';
            currentProfile.avatarData = base64Data;
            saveGameData('avatar_update');
            
            // Update existing global leaderboard entries
            updateGlobalLeaderboardAvatar();
            
            showProfileNotification('Avatar updated!', 'üñºÔ∏è');
        }
    };
    
    reader.readAsDataURL(file);
}

// Set avatar image
function setAvatarImage(imageData) {
    const avatarContainer = document.getElementById('profileAvatar');
    const avatarEmoji = document.getElementById('avatarEmoji');
    const avatarImage = document.getElementById('avatarImage');
    
    if (imageData.startsWith('data:image/')) {
        // It's an uploaded image
        avatarImage.src = imageData;
        avatarImage.style.display = 'block';
        avatarEmoji.style.display = 'none';
        avatarContainer.style.background = 'none';
    } else {
        // It's an emoji
        avatarEmoji.textContent = imageData;
        avatarEmoji.style.display = 'flex';
        avatarImage.style.display = 'none';
        avatarContainer.style.background = 'linear-gradient(45deg, #4CAF50, #2196F3)';
    }
}

// Edit username
function editUsername() {
    const modal = document.getElementById('usernameEditModal');
    const input = document.getElementById('usernameInput');
    const currentUsername = document.getElementById('profilePlayerName').textContent;
    
    input.value = currentUsername;
    modal.style.display = 'flex';
    
    // Focus input after modal is visible
    setTimeout(() => input.focus(), 100);
}

// Save username
function saveUsername() {
    const input = document.getElementById('usernameInput');
    const newUsername = input.value.trim();
    
    if (!newUsername) {
        showProfileErrorNotification('Username cannot be empty!', 'Please enter a username');
        return;
    }
    
    if (newUsername.length < 3) {
        showProfileErrorNotification('Username too short!', 'Must be at least 3 characters');
        return;
    }
    
    if (newUsername.length > 20) {
        showProfileErrorNotification('Username too long!', 'Must be 20 characters or less');
        return;
    }
    
    // Update profile
    if (currentProfile) {
        currentProfile.username = newUsername;
        saveGameData('username_update');
        
        // Update display
    document.getElementById('profilePlayerName').textContent = newUsername;
    
    // Update existing global leaderboard entries
    updateGlobalLeaderboardAvatar();
    
    showProfileNotification('Username updated!', 'üë§');
    }
    
    closeUsernameModal();
}

// Close username modal
function closeUsernameModal() {
    document.getElementById('usernameEditModal').style.display = 'none';
}

// Show profile notification (similar to other notifications)
function showProfileNotification(message, emoji) {
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        background: linear-gradient(135deg, #2196F3, #1976D2);
        color: white;
        padding: 15px 25px;
        border-radius: 12px;
        font-size: 16px;
        font-weight: bold;
        text-align: center;
        z-index: 7000;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        border: 2px solid rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(10px);
        transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        pointer-events: none;
    `;
    
    notification.innerHTML = `
        <div style="font-size: 24px; margin-bottom: 5px;">${emoji}</div>
        <div>${message}</div>
    `;
    
    document.body.appendChild(notification);
    
    // Animate in
    requestAnimationFrame(() => {
        notification.style.transform = 'translate(-50%, -50%) scale(1)';
    });
    
    // Animate out and remove
    setTimeout(() => {
        notification.style.transform = 'translate(-50%, -50%) scale(0.8)';
        notification.style.opacity = '0';
        
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 300);
    }, 1500);
}

// Initialize profile data with defaults
function initializeProfileData() {
    if (!currentProfile.username) {
        currentProfile.username = generateDefaultUsername();
    }
    if (!currentProfile.avatarType) {
        currentProfile.avatarType = 'emoji';
        currentProfile.avatarData = 'üèÉ';
    }
}


// Show profile error notification
function showProfileErrorNotification(title, message) {
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        background: linear-gradient(135deg, #F44336, #D32F2F);
        color: white;
        padding: 20px 25px;
        border-radius: 14px;
        font-size: 16px;
        font-weight: bold;
        text-align: center;
        z-index: 7000;
        box-shadow: 0 10px 30px rgba(244, 67, 54, 0.4);
        border: 2px solid rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(10px);
        transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        pointer-events: none;
        max-width: 320px;
    `;
    
    notification.innerHTML = `
        <div style="font-size: 36px; margin-bottom: 10px;">‚ö†Ô∏è</div>
        <div style="font-size: 18px; margin-bottom: 6px; text-shadow: 0 2px 4px rgba(0,0,0,0.3);">${title}</div>
        <div style="font-size: 14px; opacity: 0.9; text-shadow: 0 1px 2px rgba(0,0,0,0.3);">${message}</div>
    `;
    
    document.body.appendChild(notification);
    
    // Animate in
    requestAnimationFrame(() => {
        notification.style.transform = 'translate(-50%, -50%) scale(1)';
        notification.style.opacity = '1';
    });
    
    // Animate out and remove
    setTimeout(() => {
        notification.style.transform = 'translate(-50%, -50%) scale(0.8)';
        notification.style.opacity = '0';
        
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 300);
    }, 2500);
}

// Show insufficient funds notification
function showInsufficientFundsNotification(cost, itemType) {
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        background: linear-gradient(135deg, #FF5722, #D84315);
        color: white;
        padding: 25px 30px;
        border-radius: 16px;
        font-size: 18px;
        font-weight: bold;
        text-align: center;
        z-index: 5000;
        box-shadow: 0 12px 40px rgba(255, 87, 34, 0.4);
        border: 2px solid rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(10px);
        transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        pointer-events: none;
        max-width: 320px;
    `;
    
    const currentCoins = totalCoins;
    const needed = cost - currentCoins;
    
    notification.innerHTML = `
        <div style="font-size: 42px; margin-bottom: 12px;">üí∏</div>
        <div style="font-size: 20px; margin-bottom: 8px; text-shadow: 0 2px 4px rgba(0,0,0,0.3);">Not Enough Coins!</div>
        <div style="font-size: 14px; opacity: 0.9; margin-bottom: 8px;">You have: ${currentCoins} coins</div>
        <div style="font-size: 14px; opacity: 0.9; margin-bottom: 8px;">Need: ${cost} coins</div>
        <div style="font-size: 16px; color: #FFD700; text-shadow: 0 1px 2px rgba(0,0,0,0.3);">Play more to earn ${needed} more coins!</div>
    `;
    
    document.body.appendChild(notification);
    
    // Animate in
    requestAnimationFrame(() => {
        notification.style.transform = 'translate(-50%, -50%) scale(1)';
        notification.style.opacity = '1';
    });
    
    // Animate out and remove
    setTimeout(() => {
        notification.style.transform = 'translate(-50%, -50%) scale(0.8)';
        notification.style.opacity = '0';
        
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 400);
    }, 3000);
}
        
        function startGame() {

                // ADD THIS LINE AT THE START
    saveGameData(); // Save current state when starting

// Reset power-up states at game start
shieldActive = false;
coinMultiplierActive = false;
magnetActive = false;
powerUpTimers = {};

// Initialize status bars
initializePowerUpStatusBar();
initializeAbilityStatusBar();
    
    document.getElementById('startScreen').style.display = 'none';

            // Hide any remaining screens
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('characterSelectScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('pauseScreen').style.display = 'none';
            document.getElementById('settingsScreen').style.display = 'none';
            document.getElementById('modalOverlay').style.display = 'none';
            
            // Show game UI elements
            showGameUI();
            
            // Update game state
            gameState = "playing";

// Apply current world settings
const selectedWorld = availableWorlds.find(w => w.id === currentWorld);
if (selectedWorld) {
    applyWorldSettings(selectedWorld);
}

            gameStarted = true;
            gameOver = false;
            gamePaused = false;

            
            
            // Reset game variables
            score = 0;
            distanceTraveled = 0;
            streamSpawnCounter = 0;
            streamCreated = false;
            
            // Reset dynamic difficulty
            resetDynamicDifficulty();
            
            updateScore();

// Start background music with debugging and fallback
debug('üéµ Attempting to start background music...');
debug('üéµ Audio initialized:', audioInitialized);
debug('üéµ Background music enabled:', backgroundMusicEnabled);
debug('üéµ Music playing:', musicPlaying);

// Just start the music - no need to create it
startBackgroundMusic();

// Fallback: try again after a short delay if music didn't start
setTimeout(() => {
    if (!musicPlaying && backgroundMusicEnabled && audioInitialized) {
        debug('üéµ Fallback: Retrying music start...');
        startBackgroundMusic();
    }
}, 1000);

        }
        
        function restartGame() {
            // Clear obstacles, coins and streams
            obstacles.forEach(obstacle => scene.remove(obstacle));
            obstacles = [];

            // Reload obstacles if switching worlds or not loaded
            if (!currentWorldObstaclesLoaded) {
                loadWorldObstacles(currentWorld).then(() => {
                    console.log(`‚úÖ Obstacles reloaded for ${currentWorld} after restart`);
                }).catch(error => {
                    console.error(`Failed to reload obstacles:`, error);
                });
            }
            
            coins.forEach(coin => scene.remove(coin));
            coins = [];

            rareCoins.forEach(rareCoin => scene.remove(rareCoin));
            rareCoins = [];

            powerUps.forEach(powerUp => scene.remove(powerUp));
powerUps = [];

// Reset power-up states completely
shieldActive = false;
coinMultiplierActive = false;
magnetActive = false;
powerUpTimers = {};

// Remove shield effect if active
if (player && player.userData && player.userData.shieldEffect) {
    player.remove(player.userData.shieldEffect);
    player.userData.shieldEffect = null;
}

// Force log to confirm reset
debug('Power-ups reset - Shield:', shieldActive, 'Multiplier:', coinMultiplierActive, 'Magnet:', magnetActive);
            
            waterStreams.forEach(stream => scene.remove(stream));
            waterStreams = [];
            
            // Clear scenery objects
            sceneryObjects.forEach(object => scene.remove(object));
            sceneryObjects = [];

            // Clear meteors
            meteors.forEach(meteor => scene.remove(meteor));
            meteors = [];
            meteorSpawnCounter = 0;
            
            // Clear explosion particles
            explosionParticles.forEach(particle => scene.remove(particle));
            explosionParticles = [];
            
            // Clear sparkle particles
            sparkleParticles.forEach(particle => scene.remove(particle));
            sparkleParticles = [];
            
            // Reset player position and make visible again
player.position.x = 0;
player.position.y = playerY;
player.rotation.x = 0; // Reset rotation
player.visible = true;
currentLane = 1;
jumping = false;
jumpRotation = 0;
streamSpawnCounter = 0;
streamCreated = false;

// Reset dragon fire particles if dragon character
if (currentCharacter === 'dragon' && player.userData && player.userData.fireParticles) {
    player.userData.fireParticles.forEach(particle => {
        particle.visible = false;
        particle.position.set(
            (Math.random() - 0.5) * 0.3,
            0.1 + Math.random() * 0.2,
            1.0
        );
        particle.material.opacity = particle.userData.originalOpacity;
        particle.scale.setScalar(1.0);
    });
}
dragonFireActive = false;
dragonFireCooldown = 0;
            
            // Reset game state
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('pauseScreen').style.display = 'none';
            document.getElementById('settingsScreen').style.display = 'none';
            document.getElementById('modalOverlay').style.display = 'none';
            document.getElementById('pauseBtn').style.display = 'block';
            document.getElementById('speedIndicator').style.display = 'block';
            if (isMobile) {
                document.getElementById('swipeInstructions').style.display = 'block';
            }
            gameOver = false;
            gamePaused = false;
            gameState = "playing";
            score = 0;
            distanceTraveled = 0;
            
            // Reset dynamic difficulty
            resetDynamicDifficulty();
            
            updateScore();

// Restart background music
            if (musicPlaying) {
                stopBackgroundMusic();
            }
            startBackgroundMusic();
        }
        
        function updateScore() {
            document.getElementById('score').textContent = `Score: ${score}`;
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ==================== DESKTOP CONTROLS ====================
// Keyboard input, key handling, and desktop controls
// Dependencies: Game Loop, Player Controls  
// Functions: onKeyDown(), onKeyUp(), handleKeyboard(), etc.

// Add keyboard support for username editing
document.addEventListener('keydown', function(e) {
    const modal = document.getElementById('usernameEditModal');
    if (modal && modal.style.display === 'flex') {
        if (e.key === 'Enter') {
            saveUsername();
        } else if (e.key === 'Escape') {
            closeUsernameModal();
        }
    }
});
        
        function onKeyDown(event) {
            if (gameOver) return;
            
            if (event.key === 'p' || event.key === 'P') {
                togglePause();
                return;
            }
            
            if (event.key === 's' || event.key === 'S') {
                toggleSettingsScreen();
                return;
            }

            // Add this to your keyboard controls
            if (event.key === 'd' || event.key === 'D') {
                DEBUG_MODE = !DEBUG_MODE;
                console.log('Debug mode:', DEBUG_MODE ? 'ON' : 'OFF');
            }
            
            if (!gameStarted || gamePaused) return;
        

            switch (event.key) {
                case 'ArrowLeft':
                    moveLeft();
                    break;
                case 'ArrowRight':
                    moveRight();
                    break;
                case 'ArrowUp':
                case ' ': // Space bar
                    jump();
                    break;
                case 'ArrowDown':
                    quickDrop();
                    break;
            }
        }
        
function togglePause() {
    // Don't do anything if not in playing or paused state
    if (!gameStarted || gameOver || (gameState !== "playing" && gameState !== "paused")) return;
    
    // Toggle pause state
    gamePaused = !gamePaused;
    
    if (gamePaused) {
        // Pause the game
        gameState = "paused";
        document.getElementById('pauseScreen').style.display = 'flex';
        document.getElementById('swipeInstructions').style.display = 'none';
        
        // INSTANT audio cutoff - no hanging sound!
        if (musicPlaying) {
            try {
                // Stop all music layers instantly
                musicLayers.forEach(layer => {
                    if (layer.pattern) {
                        layer.pattern.stop(0); // Stop immediately
                    }
                    if (layer.synth) {
                        layer.synth.volume.rampTo(-60, 0.01); // Instant volume cut
                    }
                });
                
                // Stop transport and cancel scheduled events
                Tone.Transport.stop();
                Tone.Transport.cancel();
                
                musicPlaying = false;
            } catch (error) {
                debug('Audio pause error (non-critical):', error);
            }
        }
        
        // Also stop any preview music
        if (window.previewMusic && window.previewMusic.playing) {
            try {
                stopPreview();
            } catch (error) {
                debug('Preview stop error (non-critical):', error);
            }
        }
        
    } else {
        // Resume the game
        gameState = "playing";
        document.getElementById('pauseScreen').style.display = 'none';
        if (isMobile) {
            document.getElementById('swipeInstructions').style.display = 'block';
        }
        
        // Restart music cleanly if enabled
        if (backgroundMusicEnabled) {
            try {
                // Just restart the music
                startBackgroundMusic();
            } catch (error) {
                debug('Audio resume error (non-critical):', error);
            }
        }
    }
}

        // Show character select screen from game over menu
function showCharacterSelectScreen() {
    // Hide game over screen
    document.getElementById('gameOver').style.display = 'none';
    
    // Show character select screen
    document.getElementById('characterSelectScreen').style.display = 'flex';
    
    // Reset game state
    gameState = "characterSelect";
    
    // Reset the selected character index to current character
    selectedCharacterIndex = characterNames.indexOf(currentCharacter);
    if (selectedCharacterIndex === -1) selectedCharacterIndex = 0;
    
    // Reinitialize character select screen completely
    initCharacterSelectScreen();
}

// Show world select screen from character select (NEW FUNCTION)
function showWorldSelectFromCharacter() {
    // Hide character select screen
    document.getElementById('characterSelectScreen').style.display = 'none';
    
    // Show world select screen
    document.getElementById('worldSelectScreen').style.display = 'flex';
    
    // Reset game state
    gameState = "worldSelect";
    
    // Reset the selected world index to current world
    selectedWorldIndex = availableWorlds.findIndex(w => w.id === currentWorld);
    if (selectedWorldIndex === -1) selectedWorldIndex = 0;
    
    // Initialize world select screen
    initWorldSelectScreen();
}

// Show character select screen from pause menu
function showCharacterSelectScreenFromPause() {
    // Hide pause screen
    document.getElementById('pauseScreen').style.display = 'none';
    
    // Show character select screen
    document.getElementById('characterSelectScreen').style.display = 'flex';
    
    // Reset game state
    gameState = "characterSelect";
    
    // Reset the selected character index to current character
    selectedCharacterIndex = characterNames.indexOf(currentCharacter);
    if (selectedCharacterIndex === -1) selectedCharacterIndex = 0;
    
    // Reinitialize character select screen completely
    initCharacterSelectScreen();
}

        // Restart from pause menu
        function restartFromPause() {
            // First close the pause menu
            document.getElementById('pauseScreen').style.display = 'none';
            
            // Then restart the game
            restartGame();
        }

        // Show settings screen from pause menu
        function toggleSettingsFromPause() {
            // Hide pause screen
            document.getElementById('pauseScreen').style.display = 'none';
            
            // Show settings screen and overlay
            document.getElementById('settingsScreen').style.display = 'flex';
            document.getElementById('modalOverlay').style.display = 'block';
            
            // Game is already paused from pause menu, so we don't need to change gamePaused
            // But we should update the game state
            gameState = "paused"; // Keep it in paused state while in settings
        }

        // Show settings screen from game over menu
        function toggleSettingsFromGameOver() {
            // Hide game over screen
            document.getElementById('gameOver').style.display = 'none';
            
            // Show settings screen and overlay
            document.getElementById('settingsScreen').style.display = 'flex';
            document.getElementById('modalOverlay').style.display = 'block';
            
            // Keep game state as "gameOver" so we know where to return
            gameState = "gameOver";
        }

// Show settings screen during gameplay
        function toggleSettingsFromGame() {
            // Pause the game
            gamePaused = true;
            
            // Show settings screen and overlay
            document.getElementById('settingsScreen').style.display = 'flex';
            document.getElementById('modalOverlay').style.display = 'block';
            
            // Set game state
            gameState = "playing"; // Remember we're coming from playing state
        }

        // Show main menu from pause menu
        function showMainMenuFromPause() {
            // Hide pause screen
            document.getElementById('pauseScreen').style.display = 'none';
            
            // Stop any background music
            if (musicPlaying) {
                try {
                    musicLayers.forEach(layer => {
                        if (layer.pattern) {
                            layer.pattern.stop(0);
                        }
                        if (layer.synth) {
                            layer.synth.volume.rampTo(-60, 0.01);
                        }
                    });
                    Tone.Transport.stop();
                    Tone.Transport.cancel();
                    musicPlaying = false;
                } catch (error) {
                    debug('Audio stop error (non-critical):', error);
                }
            }
            
            // Reset game state
            resetGameForMenu();
            
            // Show main menu
            document.getElementById('mainMenuScreen').style.display = 'flex';
            gameState = "mainMenu";
        }

        // Show main menu from game over screen
        function showMainMenuFromGameOver() {
            // Hide game over screen
            document.getElementById('gameOver').style.display = 'none';
            
            // Reset game state
            resetGameForMenu();
            
            // Show main menu
            document.getElementById('mainMenuScreen').style.display = 'flex';
            gameState = "mainMenu";
        }

// Reset game state when returning to menu
        function resetGameForMenu() {
            // Reset game flags
            gameStarted = false;
            gameOver = false;
            gamePaused = false;
            
            // Reset score and coins display
            score = 0;
            updateScore();
            updateTotalCoins();
            
            // Hide game UI elements
            document.getElementById('score').style.display = 'none';
            document.getElementById('totalCoins').style.display = 'none';
            document.getElementById('pauseBtn').style.display = 'none';
            document.getElementById('speedIndicator').style.display = 'none';
            document.getElementById('powerUpStatusBar').style.display = 'none';
            document.getElementById('swipeInstructions').style.display = 'none';
        }
        
// Show game UI elements when starting game
        function showGameUI() {
            document.getElementById('score').style.display = 'block';
            document.getElementById('totalCoins').style.display = 'block';
            document.getElementById('pauseBtn').style.display = 'block';
            document.getElementById('speedIndicator').style.display = 'block';
            document.getElementById('powerUpStatusBar').style.display = 'flex'; // Important: Use flex, not block
            if (isMobile) {
                document.getElementById('swipeInstructions').style.display = 'block';
            }
        }
        
        function moveLeft() {
            if (currentLane > 0) {
                currentLane--;
            }
        }
        
        function moveRight() {
            if (currentLane < 2) {
                currentLane++;
            }
        }
        
        function jump() {
    if (!jumping) {
        window.AudioSystem.playJumpSound()
        jumping = true;
        jumpDirection = 1;
        jumpRotation = 0; // Reset flip rotation
        
        // Adjust jump height for pumpkin character (higher jumps)
        if (currentCharacter === 'pumpkin') {
            jumpHeight = 2.0;    // Reduced height but still higher than others
            jumpSpeed = 0.08;    // Reduced speed to maintain same duration
        } else {
            jumpHeight = 1.6;    // Reduced height for all other characters
            jumpSpeed = 0.065;   // Reduced speed to maintain same duration
        }
                
                
            }
        }
        
        function quickDrop() {
            // Only work if the character is currently jumping and moving upward
            if (jumping) {
                // If going up, immediately reverse direction
                if (jumpDirection === 1) {
                    jumpDirection = -1;
                    // Increase fall speed for a quicker drop
                    jumpSpeed *= 1.5;
                }
                // If already falling, increase fall speed
                else if (jumpDirection === -1) {
                    // Increase fall speed for a quicker drop
                    jumpSpeed *= 1.2;
                }
            }
        }

      
        
// ==================== SCENERY SYSTEM ====================
// Background scenery, environmental decorations, and world atmosphere
// Dependencies: World System, forest.js, desert.js
// Functions: spawnScenery(), createTallPine(), createMushroomPatch(), etc.

        // Create roadside scenery objects
function spawnScenery() {
    // Check if scenery is loaded
    if (!currentWorldSceneryLoaded) {
        console.warn('Scenery not loaded yet');
        return;
    }
    
    // Get available scenery for current world
    const availableScenery = Array.from(sceneryModels.keys());
    if (availableScenery.length === 0) {
        console.error('No scenery loaded for current world!');
        return;
    }
    
    // Spawn scenery to the sides of the lanes
    const side = Math.random() > 0.5 ? 1 : -1; // Left or right side
    const distance = Math.random() * 3 + 5; // Distance from center
    
    // Pick random scenery type
    const randomScenery = availableScenery[Math.floor(Math.random() * availableScenery.length)];
    
    // Get scenery from GLB
    const sceneryObject = getSceneryFromGLB(randomScenery);
    
    if (!sceneryObject) {
        console.error(`Failed to spawn scenery: ${randomScenery}`);
        return;
    }
    
    // Position the scenery
    sceneryObject.position.x = side * distance;
    sceneryObject.position.z = -50; // Spawn far away
    
    // Add metadata for animations
    sceneryObject.userData.sceneryType = randomScenery;
    
    // Special setup for animated scenery
    if (randomScenery === 'fireflySwarm' || randomScenery === 'ancientOak') {
        // Store animation data for fireflies and orbs
        sceneryObject.traverse((child) => {
            if (child.userData.floatSpeed || child.userData.orbitSpeed) {
                // Preserve animation data
                child.userData.basePosition = child.position.clone();
            }
        });
    }
    
    scene.add(sceneryObject);
    sceneryObjects.push(sceneryObject);
    
    debug(`üå≥ Spawned ${randomScenery} scenery at x:${sceneryObject.position.x}`);
}


        function createTree() {
            const treeGroup = new THREE.Group();
            
            // Tree trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.7
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 1;
            treeGroup.add(trunk);
            
            // Add bark texture
            const barkGeometry = new THREE.CylinderGeometry(0.31, 0.41, 2.01, 8, 4, true);
            const barkMaterial = new THREE.MeshStandardMaterial({
                color: 0x6B4513,
                roughness: 0.9,
                wireframe: true,
                transparent: true,
                opacity: 0.4
            });
            const bark = new THREE.Mesh(barkGeometry, barkMaterial);
            bark.position.y = 1;
            treeGroup.add(bark);
            
            // Tree leaves - layered cones for more natural look
            const leavesGeometries = [
                new THREE.ConeGeometry(1.5, 2, 8),
                new THREE.ConeGeometry(1.2, 1.8, 8),
                new THREE.ConeGeometry(0.9, 1.6, 8)
            ];
            
            const leavesMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x228B22,
                roughness: 0.6
            });
            
            const leaves1 = new THREE.Mesh(leavesGeometries[0], leavesMaterial);
            leaves1.position.y = 2.5;
            treeGroup.add(leaves1);
            
            const leaves2 = new THREE.Mesh(leavesGeometries[1], leavesMaterial);
            leaves2.position.y = 3.2;
            treeGroup.add(leaves2);
            
            const leaves3 = new THREE.Mesh(leavesGeometries[2], leavesMaterial);
            leaves3.position.y = 3.8;
            treeGroup.add(leaves3);
            
            return treeGroup;
        }
        
        function createRockFormation() {
            const rockFormationGroup = new THREE.Group();
            
            // Create several rocks of different sizes and shapes
            for (let i = 0; i < 7; i++) {
                const size = Math.random() * 0.8 + 0.4;
                // Mix different geometries for more natural look
                let rockGeometry;
                const geoType = Math.floor(Math.random() * 3);
                switch (geoType) {
                    case 0:
                        rockGeometry = new THREE.DodecahedronGeometry(size, 1);
                        break;
                    case 1:
                        rockGeometry = new THREE.IcosahedronGeometry(size, 0);
                        break;
                    case 2:
                        rockGeometry = new THREE.OctahedronGeometry(size, 1);
                        break;
                }
                
                // Mix different shades of gray
                const shade = Math.random() * 40 + 90; // 90-130 range for gray
                const rockMaterial = new THREE.MeshStandardMaterial({ 
                    color: new THREE.Color().setRGB(shade/255, shade/255, shade/255),
                    roughness: 0.8,
                    flatShading: true
                });
                
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.set(
                    Math.random() * 2 - 1,
                    size / 2,
                    Math.random() * 2 - 1
                );
                rock.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                rock.scale.set(
                    1 + Math.random() * 0.4 - 0.2,
                    1 + Math.random() * 0.4 - 0.2,
                    1 + Math.random() * 0.4 - 0.2
                );
                rockFormationGroup.add(rock);
            }
            
            // Add some moss on top of some rocks
            const mossGeometry = new THREE.SphereGeometry(0.2, 8, 4);
            const mossMaterial = new THREE.MeshStandardMaterial({
                color: 0x3A5F0B,
                roughness: 1
            });
            
            for (let i = 0; i < 4; i++) {
                const moss = new THREE.Mesh(mossGeometry, mossMaterial);
                moss.position.set(
                    Math.random() * 1.5 - 0.75,
                    Math.random() * 0.5 + 0.8,
                    Math.random() * 1.5 - 0.75
                );
                moss.scale.set(0.6, 0.3, 0.6);
                rockFormationGroup.add(moss);
            }
            
            return rockFormationGroup;
        }
        
        function createFlowers() {
    const flowerGroup = new THREE.Group();
    
    // Skip grass base - flowers will sit directly on the dark side terrain
            
            // Add flowers of different colors
            const flowerColors = [
                0xFF0000, // Red
                0xFFFF00, // Yellow
                0xFF00FF, // Pink
                0xFFFFFF, // White
                0x0000FF, // Blue
                0xFF9900  // Orange
            ];
            
            for (let i = 0; i < 15; i++) {
                // Stem
                const stemGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.5, 8);
                const stemMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
                const stem = new THREE.Mesh(stemGeometry, stemMaterial);
                
                // Position within flower patch area
const angle = Math.random() * Math.PI * 2;
const radius = Math.random() * 1.2; // Slightly larger spread since no grass circle
stem.position.set(
    Math.cos(angle) * radius,
    0.25,
    Math.sin(angle) * radius
);
                
                // Slight random tilt to stems
                stem.rotation.set(
                    Math.random() * 0.3 - 0.15,
                    0,
                    Math.random() * 0.3 - 0.15
                );
                
                // Flower head - choose different shapes for variety
                const flowerType = Math.floor(Math.random() * 3);
                let flower;
                
                if (flowerType === 0) {
                    // Simple sphere flower
                    const flowerGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                    const flowerMaterial = new THREE.MeshStandardMaterial({ 
                        color: flowerColors[Math.floor(Math.random() * flowerColors.length)],
                        emissive: 0x333333,
                        emissiveIntensity: 0.2
                    });
                    flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
                    flower.position.y = 0.5;
                } 
                else if (flowerType === 1) {
                    // Daisy-like flower with petals
                    flower = new THREE.Group();
                    
                    // Center of flower
                    const centerGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                    const centerMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFF00 });
                    const center = new THREE.Mesh(centerGeometry, centerMaterial);
                    flower.add(center);
                    
                    // Add petals
                    const petalColor = flowerColors[Math.floor(Math.random() * flowerColors.length)];
                    const petalMaterial = new THREE.MeshStandardMaterial({ 
                        color: petalColor,
                        emissive: petalColor,
                        emissiveIntensity: 0.1
                    });
                    
                    for (let j = 0; j < 8; j++) {
                        const petalGeometry = new THREE.SphereGeometry(0.04, 8, 8);
                        const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                        const petalAngle = (j / 8) * Math.PI * 2;
                        petal.position.set(
                            Math.cos(petalAngle) * 0.08,
                            0,
                            Math.sin(petalAngle) * 0.08
                        );
                        petal.scale.set(1.5, 0.5, 1.5);
                        flower.add(petal);
                    }
                    
                    flower.position.y = 0.5;
                }
                else {
                    // Tulip-like flower
                    const flowerGeometry = new THREE.ConeGeometry(0.08, 0.15, 8);
                    const flowerMaterial = new THREE.MeshStandardMaterial({ 
                        color: flowerColors[Math.floor(Math.random() * flowerColors.length)],
                        emissive: 0x333333,
                        emissiveIntensity: 0.2
                    });
                    flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
                    flower.position.y = 0.5;
                    flower.rotation.x = Math.PI; // Invert cone to look like a tulip
                }
                
                stem.add(flower);
                flowerGroup.add(stem);
            }
            
            return flowerGroup;
        }
        
        function createBushCluster() {
            const bushClusterGroup = new THREE.Group();
            
            // Create several bushes of different sizes
            for (let i = 0; i < 5; i++) {
                const bushSize = Math.random() * 0.6 + 0.6;
                
                // Base bush
                const bushGeometry = new THREE.SphereGeometry(bushSize, 8, 8);
                const bushMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x228B22, 
                    roughness: 0.7
                });
                const bush = new THREE.Mesh(bushGeometry, bushMaterial);
                
                // Position bushes in a small cluster
                const angle = Math.random() * Math.PI * 2;
                const clusterRadius = Math.random() * 1.2;
                bush.position.set(
                    Math.cos(angle) * clusterRadius,
                    bushSize / 2,
                    Math.sin(angle) * clusterRadius
                );
                
                // Add some variation to the bush color
                const colorVariation = Math.random() * 0.2 - 0.1; // -0.1 to 0.1
                bushMaterial.color.g += colorVariation;
                
                bushClusterGroup.add(bush);
                
                // Add details to each bush
                const detailGeometry = new THREE.SphereGeometry(bushSize * 1.05, 8, 8);
                const detailMaterial = new THREE.MeshStandardMaterial({
                    color: 0x196F3D,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.3
                });
                const detail = new THREE.Mesh(detailGeometry, detailMaterial);
                detail.position.copy(bush.position);
                bushClusterGroup.add(detail);
            }
            
            return bushClusterGroup;
        }
        
        // Create a coin with improved shiny gold appearance
        function spawnCoin() {
            const laneIndex = Math.floor(Math.random() * 3); // Random lane
            const coinGroup = new THREE.Group();
            
            // Create coin with brilliant shiny gold material
// Reuse shared geometry for all coins
if (!window.sharedCoinGeometry) {
    window.sharedCoinGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.05, 16); // Reduced segments
}
const coinGeometry = window.sharedCoinGeometry;
const coinMaterial = new THREE.MeshStandardMaterial({ 
    color: 0xFFD700, // Bright gold
    metalness: 1.0,  // Fully metallic
    roughness: 0.05, // Very shiny
    emissive: 0xFFD700, // Golden glow
    emissiveIntensity: 0.4
});
const coin = new THREE.Mesh(coinGeometry, coinMaterial);
coin.rotation.x = Math.PI / 2;
coinGroup.add(coin);

// Add edge detail to coin with enhanced shine (properly aligned)
const edgeGeometry = new THREE.TorusGeometry(0.3, 0.03, 8, 32);
const edgeMaterial = new THREE.MeshStandardMaterial({ 
    color: 0xFFD700, // Same bright gold
    metalness: 1.0, 
    roughness: 0.03, // Extra shiny
    emissive: 0xFFD700,
    emissiveIntensity: 0.3
});
const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
// No rotation needed - both coin and edge are now in the same orientation
coinGroup.add(edge);

// Add sparkle particles around the coin
for (let i = 0; i < 8; i++) {
    const sparkleGeometry = new THREE.SphereGeometry(0.02, 8, 8);
    const sparkleMaterial = new THREE.MeshBasicMaterial({
        color: 0xFFFFFF,
        transparent: true,
        opacity: 0.8
    });
    
    const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
    
    // Position sparkles around the coin
    const angle = (i / 8) * Math.PI * 2;
    const radius = 0.4 + Math.random() * 0.1;
    sparkle.position.set(
        Math.cos(angle) * radius,
        0,
        Math.sin(angle) * radius
    );
    
    // Animation properties for sparkles
    sparkle.userData = {
        orbitSpeed: 0.02 + Math.random() * 0.02,
        orbitRadius: radius,
        orbitAngle: angle,
        pulseSpeed: 0.05 + Math.random() * 0.05,
        pulsePhase: Math.random() * Math.PI * 2
    };
    
    coinGroup.add(sparkle);
}

// Store sparkles for animation
coinGroup.userData.sparkles = coinGroup.children.filter(child => 
    child.userData && child.userData.orbitSpeed !== undefined
);
            
            // Add dollar sign to the coin (simple geometry representation)
            const dollarSignGroup = new THREE.Group();
            
            // Vertical bar
            const barGeometry = new THREE.BoxGeometry(0.05, 0.3, 0.02);
            const dollarMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFCC00,
                metalness: 1.0, 
                roughness: 0.2,
                emissive: 0xFFAA00,
                emissiveIntensity: 0.3
            });
            const bar = new THREE.Mesh(barGeometry, dollarMaterial);
            dollarSignGroup.add(bar);
            
            // Top and bottom curves
            const topCurveGeometry = new THREE.TorusGeometry(0.08, 0.02, 8, 8, Math.PI);
            const topCurve = new THREE.Mesh(topCurveGeometry, dollarMaterial);
            topCurve.position.set(0.04, 0.08, 0);
            topCurve.rotation.z = Math.PI / 2;
            dollarSignGroup.add(topCurve);
            
            const bottomCurveGeometry = new THREE.TorusGeometry(0.08, 0.02, 8, 8, Math.PI);
            const bottomCurve = new THREE.Mesh(bottomCurveGeometry, dollarMaterial);
            bottomCurve.position.set(-0.04, -0.08, 0);
            bottomCurve.rotation.z = -Math.PI / 2;
            dollarSignGroup.add(bottomCurve);
            
            // Front side dollar sign
dollarSignGroup.position.set(0, 0, 0.03); // Position it just on the surface of the coin
// No rotation - keep dollar sign standing upright
coinGroup.add(dollarSignGroup);

// Back side dollar sign (duplicate)
const dollarSignGroupBack = dollarSignGroup.clone();
dollarSignGroupBack.position.set(0, 0, -0.03); // Position on the back surface
dollarSignGroupBack.rotation.y = Math.PI; // Flip it so it reads correctly from the back
coinGroup.add(dollarSignGroupBack);
            
            // Remove the highlight plane - it was causing visual issues
// Instead, the coin already has sparkle particles for visual appeal
            
            // Position coin in lane, and slightly higher than obstacles for jumping
            coinGroup.position.x = lanes[laneIndex];
            coinGroup.position.y = 1.2; // Higher than obstacles for jumping
            coinGroup.position.z = -50; // Spawn far away
            
            scene.add(coinGroup);
            coins.push(coinGroup);
        }

// Create rare gradient coin - spawns very rarely, worth 100 coins
function spawnRareCoin() {
    const laneIndex = Math.floor(Math.random() * 3); // Random lane
    const rareCoinGroup = new THREE.Group();
    
    // Create coin with brilliant gradient material
    const coinGeometry = new THREE.CylinderGeometry(0.35, 0.35, 0.06, 32); // Slightly bigger
    
    // Create gradient canvas texture
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    const context = canvas.getContext('2d');
    
    // Create radial gradient (purple to blue to teal to green)
    const gradient = context.createRadialGradient(128, 128, 0, 128, 128, 128);
    gradient.addColorStop(0, '#8A2BE2');    // Purple center
    gradient.addColorStop(0.3, '#4169E1');  // Blue
    gradient.addColorStop(0.6, '#20B2AA');  // Teal
    gradient.addColorStop(1, '#32CD32');     // Green edge
    
    context.fillStyle = gradient;
    context.fillRect(0, 0, 256, 256);
    
    const gradientTexture = new THREE.CanvasTexture(canvas);
    
    const rareCoinMaterial = new THREE.MeshStandardMaterial({ 
        map: gradientTexture,
        color: 0xFFFFFF, // White to not affect texture
        metalness: 1.0,  // Fully metallic
        roughness: 0.05, // Very shiny
        emissive: 0x4169E1, // Blue glow
        emissiveIntensity: 0.3
    });
    const rareCoin = new THREE.Mesh(coinGeometry, rareCoinMaterial);
    rareCoin.rotation.x = Math.PI / 2;
    rareCoinGroup.add(rareCoin);
    
    // Add edge detail with vibrant blue-green gradient
const edgeGeometry = new THREE.TorusGeometry(0.35, 0.04, 8, 32);
const edgeMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x00CCFF, // Bright cyan edge
    metalness: 1.0, 
    roughness: 0.01, // Super shiny
    emissive: 0x0088FF,
    emissiveIntensity: 0.7 // Bright glow
});
    const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
    rareCoinGroup.add(edge);
    
    // Create the Solana-style logo using simple geometry
const chevronGroup = new THREE.Group();

// Brighter, more vibrant Solana colors
const solanaColors = [0xBB66FF, 0x00FF88, 0x00FFDD]; // Brighter Purple, Bright Green, Bright Cyan

// Create three Solana-style parallelograms using BoxGeometry (reliable)
for (let i = 0; i < 3; i++) {
    // Create parallelogram using skewed boxes
    const parallelogramGroup = new THREE.Group();
    
    // Main parallelogram body
    const mainGeometry = new THREE.BoxGeometry(0.3, 0.08, 0.02);
    const chevronMaterial = new THREE.MeshStandardMaterial({ 
        color: solanaColors[i],
        metalness: 1.0, 
        roughness: 0.02, // Extra shiny
        emissive: solanaColors[i],
        emissiveIntensity: 0.6 // Much brighter glow
    });
    
    const mainBody = new THREE.Mesh(mainGeometry, chevronMaterial);
    mainBody.rotation.z = 0.3; // Skew angle for Solana look
    parallelogramGroup.add(mainBody);
    
    // Add angled ends to create parallelogram shape
    const endGeometry = new THREE.BoxGeometry(0.06, 0.06, 0.02);
    
    const leftEnd = new THREE.Mesh(endGeometry, chevronMaterial);
    leftEnd.position.set(-0.12, -0.05, 0);
    leftEnd.rotation.z = 0.8;
    parallelogramGroup.add(leftEnd);
    
    const rightEnd = new THREE.Mesh(endGeometry, chevronMaterial);
    rightEnd.position.set(0.12, 0.05, 0);
    rightEnd.rotation.z = 0.8;
    parallelogramGroup.add(rightEnd);
    
    // Position the three parallelograms
    if (i === 0) {
        parallelogramGroup.position.set(0, 0.1, 0);
    } else if (i === 1) {
        parallelogramGroup.position.set(0, 0, 0);
    } else {
        parallelogramGroup.position.set(0, -0.1, 0);
    }
    
    chevronGroup.add(parallelogramGroup);
}
    
    // Front side chevron
    chevronGroup.position.set(0, 0, 0.035);
    rareCoinGroup.add(chevronGroup);
    
    // Back side chevron (duplicate)
    const chevronGroupBack = chevronGroup.clone();
    chevronGroupBack.position.set(0, 0, -0.035);
    chevronGroupBack.rotation.y = Math.PI;
    rareCoinGroup.add(chevronGroupBack);
    
    // Add enhanced sparkle particles with gradient colors
    for (let i = 0; i < 12; i++) {
        const sparkleGeometry = new THREE.SphereGeometry(0.03, 8, 8);
        const sparkleColors = [0x8A2BE2, 0x4169E1, 0x20B2AA, 0x32CD32]; // Gradient colors
        const sparkleColor = sparkleColors[i % sparkleColors.length];
        
        const sparkleMaterial = new THREE.MeshBasicMaterial({
            color: sparkleColor,
            transparent: true,
            opacity: 0.8
        });
        
        const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
        
        const angle = (i / 12) * Math.PI * 2;
        const radius = 0.5 + Math.random() * 0.1;
        sparkle.position.set(
            Math.cos(angle) * radius,
            0,
            Math.sin(angle) * radius
        );
        
        sparkle.userData = {
            orbitSpeed: 0.03 + Math.random() * 0.02,
            orbitRadius: radius,
            orbitAngle: angle,
            pulseSpeed: 0.08 + Math.random() * 0.05,
            pulsePhase: Math.random() * Math.PI * 2
        };
        
        rareCoinGroup.add(sparkle);
    }
    
    // Store sparkles for animation
    rareCoinGroup.userData.sparkles = rareCoinGroup.children.filter(child => 
        child.userData && child.userData.orbitSpeed !== undefined
    );
    rareCoinGroup.userData.rotationSpeed = Math.random() * 0.02 + 0.02; // Faster rotation
    
    // Position coin in lane, higher than regular coins
    rareCoinGroup.position.x = lanes[laneIndex];
    rareCoinGroup.position.y = 1.4; // Slightly higher than regular coins
    rareCoinGroup.position.z = -50; // Spawn far away
    
    scene.add(rareCoinGroup);
    rareCoins.push(rareCoinGroup);
}

        
// ==================== COLLISION SYSTEM ====================
// Collision detection, hit testing, and collision response
// Dependencies: Player Controls, Obstacle System, Power-up System
// Functions: checkCollision(), checkSimpleCollision(), collision handling logic

        // Smart collision - early exit for distant objects
function fastCollisionCheck(object1, object2, threshold = 3.0) {
    const dx = object1.position.x - object2.position.x;
    const dy = object1.position.y - object2.position.y;
    const dz = object1.position.z - object2.position.z;
    const distanceSquared = dx * dx + dy * dy + dz * dz;
    
    // Early exit if objects are too far apart
    if (distanceSquared > threshold * threshold) {
        return false;
    }
    
    // Only do expensive collision check if objects are close
    return checkCollision(object2);
}

        // Optimized collision detection with caching
function checkCollision(object) {
    // For coins and power-ups, use simple distance-based collision (faster)
    const isCoin = coins.includes(object) || rareCoins.includes(object);
    const isPowerUp = powerUps.includes(object);
    
    if (isCoin || isPowerUp) {
        return checkSimpleCollision(object, player, 1.5);
    }

    // For ancient ruins (desert pillars), only check collision with the main pillar - HANDLE FIRST
const isAncientRuin = obstacles.includes(object) && object.userData.obstacleType === 'ancientRuin';

if (isAncientRuin) {
    // Get world positions to check distance first
    const playerPos = new THREE.Vector3();
    const obstaclePos = new THREE.Vector3();
    player.getWorldPosition(playerPos);
    object.getWorldPosition(obstaclePos);
    
    const distance = playerPos.distanceTo(obstaclePos);
    
    // Only check collision if player is very close
    if (distance < 2.0) {
        // Can jump over pillars if high enough
        if (jumping && player.position.y > 1.2) {
            debug('ü¶ò Jumped over ancient pillar!');
            return false;
        }
        
        // Use standard bounding box collision
        const obstacleBox = new THREE.Box3().setFromObject(object);
        const playerBox = new THREE.Box3().setFromObject(player);
        
        return playerBox.intersectsBox(obstacleBox);
    }
    return false;
}

// For quicksand, only check collision with the main pit area
const isQuicksand = obstacles.includes(object) && object.userData.obstacleType === 'quicksand';

// For quicksand
if (object.name === 'quicksand' || object.userData.obstacleType === 'quicksand') {
    // Get the center position of the quicksand
    const quicksandCenter = new THREE.Vector3();
    object.getWorldPosition(quicksandCenter);
    
    const playerPos = new THREE.Vector3();
    player.getWorldPosition(playerPos);
    
    // Only check X and Z distance (ignore Y for ground-level check)
    const distanceXZ = Math.sqrt(
        Math.pow(playerPos.x - quicksandCenter.x, 2) + 
        Math.pow(playerPos.z - quicksandCenter.z, 2)
    );
    
    // Only collide if very close to center (ignore bones on the edges)
    if (distanceXZ < 0.8) {
        if (jumping && player.position.y > 0.8) {
            debug('ü¶ò Jumped over quicksand!');
            return false;
        }
        debug('üí• Fell into quicksand!');
        return true;
    }
    return false;
}
    
    // For Monster character, use precise collision with main body only
if (currentCharacter === 'monster') {
    // Find the main body (central sphere) of the Monster
    let monsterBody = null;
    for (let i = 0; i < player.children.length; i++) {
        const child = player.children[i];
        if (child.userData && child.userData.isMainBody) {
            monsterBody = child;
            break;
        }
    }
    
    if (monsterBody) {
        // Use cached collision boundaries
        const bodyBox = getCachedCollisionBox(monsterBody);
        const objectBox = getCachedCollisionBox(object);
        
        // Check intersection between cached boxes
        return bodyBox.intersectsBox(objectBox);
    }
}

// For Dragon character, use cached collision with body only (ignore wings)
if (currentCharacter === 'dragon') {
    // Use simple distance check for performance, but verify with wings
    if (checkSimpleCollision(object, player, 2.0)) {
        // Double-check with cached bounding box if close
        const objectBox = getCachedCollisionBox(object);
        const playerBox = getCachedCollisionBox(player);
        return playerBox.intersectsBox(objectBox);
    }
    return false;
}
    
    // For UFO character, handle collision differently for coins vs obstacles
if (currentCharacter === 'ufo') {
    // Check if this is a coin (coins are in the coins array)
    const isCoin = coins.includes(object);
    
    if (isCoin) {
        // For coins, use expanded collision area
        const playerBox = new THREE.Box3().setFromObject(player);
        const objectBox = new THREE.Box3().setFromObject(object);
        
        // Expand the UFO's collision box vertically to catch coins above and below
        playerBox.min.y -= 0.3; // Extend downward
        playerBox.max.y += 0.5; // Extend upward more to catch coins
        
        return playerBox.intersectsBox(objectBox);
    } else {
        // For obstacles, create a custom bounding box excluding the tractor beam
        const customBox = new THREE.Box3();
        
        // Only include specific UFO parts (exclude the beam which is usually the last child)
        for (let i = 0; i < player.children.length; i++) {
            const child = player.children[i];
            // Skip the tractor beam (it's positioned at y = -0.6)
            if (child.position.y > -0.4) {
                const childBox = new THREE.Box3().setFromObject(child);
                if (customBox.isEmpty()) {
                    customBox.copy(childBox);
                } else {
                    customBox.union(childBox);
                }
            }
        }
        
        const objectBox = new THREE.Box3().setFromObject(object);
        return customBox.intersectsBox(objectBox);
    }
}

// For meteors, use precise lane-based collision detection
if (meteors.includes(object)) {
    // Check if meteor and player are in the same lane
    const meteorLane = object.userData ? object.userData.targetLane : -1;
    const playerLane = currentLane;
    
    // Only collide if they're in the same lane AND close enough vertically
    if (meteorLane === playerLane) {
        const playerBox = new THREE.Box3().setFromObject(player);
        const meteorBox = new THREE.Box3().setFromObject(object);
        
        // Make collision more precise - only check if meteor is at ground level
        if (object.position.y <= 1.0) { // Meteor is close to ground
            return playerBox.intersectsBox(meteorBox);
        }
    }
    
    return false; // No collision if not in same lane or meteor is too high
}

// Check if this is a fallen tree - only collide with the trunk
const isFallenTree = (object.name === 'fallenTree' || object.userData.obstacleType === 'fallenTree');

if (isFallenTree) {
    // Get player position for distance check
    const playerPos = new THREE.Vector3();
    player.getWorldPosition(playerPos);
    
    // Get tree center position
    const treeCenter = new THREE.Vector3();
    object.getWorldPosition(treeCenter);
    
    // First check if player is even close enough to bother with detailed collision
    const distanceToTree = playerPos.distanceTo(treeCenter);
    if (distanceToTree > 3) {
        return false; // Too far away to collide
    }
    
    // Create a narrow collision box for just the trunk
    // The trunk is horizontal, so it's long in X direction, narrow in Z
    const trunkBox = new THREE.Box3();
    
    // Adjust these values based on your fallen tree model orientation
    // This assumes the tree is lying horizontally along the X axis
    const trunkMin = new THREE.Vector3(
        treeCenter.x - 2,    // Half length of trunk
        treeCenter.y - 0.4,  // Bottom of trunk
        treeCenter.z - 0.4   // Half width of trunk
    );
    const trunkMax = new THREE.Vector3(
        treeCenter.x + 2,    // Half length of trunk
        treeCenter.y + 0.4,  // Top of trunk
        treeCenter.z + 0.4   // Half width of trunk
    );
    
    trunkBox.set(trunkMin, trunkMax);
    
    // Get player bounding box
    const playerBox = new THREE.Box3().setFromObject(player);
    
    // Check if player can jump over
    if (jumping && player.position.y > 1.0) {
        debug('ü¶ò Jumped over fallen tree!');
        return false;
    }
    
    // Check collision with trunk only
    if (playerBox.intersectsBox(trunkBox)) {
        debug('üí• Hit fallen tree trunk!');
        return true;
    }
    
    return false;
}

// Check if this is a rock formation - use lane-based collision
const isRockFormation = obstacles.includes(object) && object.userData.obstacleType === 'rockFormation';

if (isRockFormation) {
    // Get player and rock positions
    const playerPos = new THREE.Vector3();
    const rockPos = new THREE.Vector3();
    player.getWorldPosition(playerPos);
    object.getWorldPosition(rockPos);
    
    // First check Z distance - if too far away, no collision
    const zDistance = Math.abs(playerPos.z - rockPos.z);
    if (zDistance > 1.5) {
        return false; // Too far in front/behind
    }
    
    // Check if player and rock are in the same lane
    const playerLane = Math.round(player.position.x / 2); // Assuming lanes are 2 units apart
    const rockLane = Math.round(object.position.x / 2);
    
    // Only collide if in the same lane
    if (playerLane !== rockLane) {
        return false; // Different lanes, no collision
    }
    
    // Check if player can jump over
    if (jumping && player.position.y > 1.2) {
        debug('ü¶ò Jumped over rock formation!');
        return false;
    }
    
    // If in same lane and close enough, collision detected
    debug('üí• Hit rock formation!');
    return true;
}



// For Robot character, use collision detection ONLY for main body parts (exclude particles)
if (currentCharacter === 'robot') {
    // Create collision box only from robot's main body parts (exclude electromagnetic particles)
    const robotMainBox = new THREE.Box3();
    
    // Only include the first 7 children (body, head, eyes, arms, legs, antenna)
    // Skip the electromagnetic field particles (children 8+)
    for (let i = 0; i < Math.min(7, player.children.length); i++) {
        const child = player.children[i];
        const childBox = new THREE.Box3().setFromObject(child);
        if (robotMainBox.isEmpty()) {
            robotMainBox.copy(childBox);
        } else {
            robotMainBox.union(childBox);
        }
    }
    
    const objectBox = new THREE.Box3().setFromObject(object);
    
    // Check if this is an obstacle and player is jumping
    const isObstacle = obstacles.includes(object);
    if (isObstacle && jumping && player.position.y > 1.2) {
        debug('ü¶ò Robot jumped over obstacle at height:', player.position.y);
        return false; // No collision with obstacles when jumping high enough
    }
    
    // Robot shield - blocks obstacles (but not coins/power-ups)  
    if (robotShieldActive) {
        const isObstacle = obstacles.includes(object);
        const isStream = waterStreams.includes(object);
        const isMeteor = meteors.includes(object);
        
        if (isObstacle || isStream || isMeteor) {
            // Create shield spark effect when blocking
            createShieldSparkEffect(object.position);
            debug('ü§ñ Robot shield blocked obstacle!');
            return false; // No collision when shield is active
        }
    }
    
    return robotMainBox.intersectsBox(objectBox);
}

// For Creature character, use collision detection ONLY for main body (exclude wisps and orbs)
if (currentCharacter === 'creature') {
    // Create collision box only from creature's main body parts (exclude wisps, tentacles, etc.)
    const creatureMainBox = new THREE.Box3();
    
    // Only include the first 2 children (main body and neon core)
    // Skip the eyes, tentacles, wisps, and dark aura (children 2+)
    for (let i = 0; i < Math.min(2, player.children.length); i++) {
        const child = player.children[i];
        const childBox = new THREE.Box3().setFromObject(child);
        if (creatureMainBox.isEmpty()) {
            creatureMainBox.copy(childBox);
        } else {
            creatureMainBox.union(childBox);
        }
    }
    
    const objectBox = new THREE.Box3().setFromObject(object);
    
    // Check if this is an obstacle and player is jumping
    const isObstacle = obstacles.includes(object);
    if (isObstacle && jumping && player.position.y > 1.2) {
        debug('ü¶ò Creature jumped over obstacle at height:', player.position.y);
        return false; // No collision with obstacles when jumping high enough
    }
    
    return creatureMainBox.intersectsBox(objectBox);
}

// For other characters, use cached collision boundaries
const playerBox = getCachedCollisionBox(player);
const objectBox = getCachedCollisionBox(object);

// Check if this is an obstacle (not a coin or power-up) and player is jumping
const isObstacle = obstacles.includes(object);
if (isObstacle && jumping && player.position.y > 1.2) {
    return false; // No collision with obstacles when jumping high enough
}

// Ghost phase ability - can phase through obstacles (but not coins/power-ups)
if (currentCharacter === 'ghost' && ghostPhaseActive) {
    const isObstacle = obstacles.includes(object);
    const isStream = waterStreams.includes(object);
    
    if (isObstacle || isStream) {
        return false; // No collision when phasing
    }
}

// Robot shield - blocks obstacles (but not coins/power-ups)  
if (currentCharacter === 'robot' && robotShieldActive) {
    const isObstacle = obstacles.includes(object);
    const isStream = waterStreams.includes(object);
    const isMeteor = meteors.includes(object);
    
    if (isObstacle || isStream || isMeteor) {
        // Create shield spark effect when blocking
        createShieldSparkEffect(object.position);
        return false; // No collision when shield is active
    }
}

// Use cached collision boundaries for final check
return playerBox.intersectsBox(objectBox);
}
        
        // Create explosion effect when game over
        function createExplosion() {
            // Create explosion particles at player's position
            const numParticles = mobileExplosionCount;
            
            // Explosion colors based on the current character
            let colors = [0xff0000, 0xff7700, 0xffff00]; // Default apple colors
            
            if (currentCharacter === 'carrot') {
                colors = [0xFF8C00, 0xFFA500, 0xFF4500]; // Orange shades
            } else if (currentCharacter === 'pumpkin') {
                colors = [0xFF6600, 0xFF8800, 0xDD5500]; // Pumpkin shades
            } else if (currentCharacter === 'happyface') {
                colors = [0xFFFF00, 0xFFDD00, 0xFFCC00]; // Yellow shades
            } else if (currentCharacter === 'monster') {
                colors = [0x000000, 0x330000, 0x660000]; // Dark red/black shades
            } else if (currentCharacter === 'atom') {
                colors = [0x0088FF, 0x00FFFF, 0x0044AA]; // Blue/cyan shades
            }
            
            for (let i = 0; i < numParticles; i++) {
                // Random size for each particle
                const radius = Math.random() * 0.2 + 0.05;
                const geometry = new THREE.SphereGeometry(radius, 8, 8);
                const material = new THREE.MeshStandardMaterial({ 
                    color: colors[Math.floor(Math.random() * colors.length)],
                    emissive: colors[Math.floor(Math.random() * colors.length)],
                    emissiveIntensity: 0.5
                });
                
                const particle = new THREE.Mesh(geometry, material);
                
                // Set particle at player position
                particle.position.x = player.position.x;
                particle.position.y = player.position.y;
                particle.position.z = player.position.z;
                
                // Give random velocity in all directions
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.3,
                    Math.random() * 0.2 + 0.1,
                    (Math.random() - 0.5) * 0.3
                );
                
                // Add to scene and array
                scene.add(particle);
                explosionParticles.push(particle);
            }
            
            // Hide the player
            player.visible = false;
        }
        
        // Update explosion particles
        function updateExplosion() {
            // Update explosion particles positions based on velocity
            for (let i = explosionParticles.length - 1; i >= 0; i--) {
                const particle = explosionParticles[i];
                
                // Apply gravity and update position
                particle.userData.velocity.y -= 0.01;
                particle.position.x += particle.userData.velocity.x;
                particle.position.y += particle.userData.velocity.y;
                particle.position.z += particle.userData.velocity.z;
                
                // Make particles spin for more dynamic effect
                particle.rotation.x += 0.05;
                particle.rotation.y += 0.05;
                
                // Remove particles that fall below ground
                if (particle.position.y < -1) {
                    scene.remove(particle);
                    explosionParticles.splice(i, 1);
                }
            }
        }
        
        // Game over
function endGame() {
    window.AudioSystem.playCrashSound()
    gameState = "gameOver";
    gameOver = true;
    
    // Hide UI elements
    document.getElementById('pauseBtn').style.display = 'none';
    document.getElementById('speedIndicator').style.display = 'none';
    document.getElementById('modalOverlay').style.display = 'none';
    if (isMobile) {
        document.getElementById('swipeInstructions').style.display = 'none';
    }
    
    // INSTANT audio cutoff - stop everything immediately
    try {
        if (musicPlaying) {
            // Stop background music
            stopBackgroundMusic();
            
            musicPlaying = false;
        }
        
        // Also stop any preview music if playing
        if (window.previewMusic && window.previewMusic.playing) {
            stopPreview();
        }
        
    } catch (error) {
        debug('Audio stop error (non-critical):', error);
    }

    // Create explosion effect
    createExplosion();
    
    // Show game over screen after a short delay to see the explosion
    setTimeout(() => {
        document.getElementById('finalScore').textContent = `Score: ${score}`;
        
        // Show total coins collected this session (no bonus since coins were added in real-time)
        document.getElementById('coinsCollected').textContent = `Final Balance: ${totalCoins} coins`;
        
        // Check if it's a high score and show input form if needed
        debug('üèÜ Checking if score is high score:', score);
        const isHighScore = checkHighScore(score);
        debug('üèÜ Is high score result:', isHighScore);

        if (isHighScore) {
            debug('üèÜ High score achieved and auto-saved!');
            // Score was automatically saved in checkHighScore()
        } else {
            debug('üèÜ Not a high score - no save needed');
        }
        
        // No need to show/hide save message since we removed it
        
        document.getElementById('gameOver').style.display = 'flex';
        
        saveGameData('game_end');
    }, 1500);
}

        // Add this function anywhere with your other game functions
function checkHighScore(currentScore) {
    let leaderboard = JSON.parse(localStorage.getItem('runningBlitzLeaderboard') || '[]');
    
    // It's a high score if leaderboard has less than 10 entries OR current score beats the lowest score
    const isHighScore = leaderboard.length < 10 || currentScore > (leaderboard[leaderboard.length - 1]?.score || 0);

    // Debug the high score update
    debug('üèÜ High score check:', {
        currentScore: currentScore,
        profileHighScore: currentProfile.highScore || 0,
        willUpdate: currentScore > (currentProfile.highScore || 0)
    });

    // Update profile high score regardless of leaderboard position
    if (currentScore > (currentProfile.highScore || 0)) {
        const oldScore = currentProfile.highScore || 0;
        currentProfile.highScore = currentScore;
        currentProfile.lastPlayed = new Date().toISOString();
        saveGameData('high_score');
        
        debug('üèÜ Profile high score updated!', {
            oldScore: oldScore,
            newScore: currentScore
        });
    }
    
    // AUTO-SAVE: If it's a high score, automatically save it to leaderboard
    if (isHighScore) {
        debug('üèÜ Auto-saving high score to leaderboard...');
        autoSaveHighScore(currentScore);
    }
    
    debug(`Checking high score: ${currentScore}, is high score: ${isHighScore}`);
    debug(`Need to beat: ${leaderboard[leaderboard.length - 1]?.score || 0}`);
    return isHighScore;
}


        // ==================== CHARACTER ABILITIES ====================
// Special character powers, abilities, and unique mechanics
// Dependencies: Character System, Audio System, Game Loop
// Functions: activateGhostPhase(), destroyObstaclesWithFire(), etc.

// Handle character-specific abilities
function handleCharacterAbilities() {
    // Update cooldowns
    if (robotShieldCooldown > 0) robotShieldCooldown--;
    if (dragonFireCooldown > 0) dragonFireCooldown--;
    if (ghostPhaseCooldown > 0) ghostPhaseCooldown--;
    
    // Robot Electromagnetic Shield (Performance Optimized)
if (currentCharacter === 'robot') {
    // Animate wireframe shield rotation
    if (player.userData && player.userData.shieldDome && robotShieldActive) {
        const shield = player.userData.shieldDome;
        shield.rotation.y += shield.userData.rotationSpeed || 0.01;
        shield.rotation.x += (shield.userData.rotationSpeed || 0.01) * 0.5;
        
        // Pulse the electromagnetic glow
        shield.material.emissiveIntensity = 0.5 + Math.sin(frameCount * 0.1) * 0.2;
    }
    
    // Auto-activate shield when obstacles are near (if not on cooldown)
    if (!robotShieldActive && robotShieldCooldown <= 0) {
        for (const obstacle of obstacles) {
            const distance = obstacle.position.distanceTo(player.position);
            if (distance < 8 && obstacle.position.z < player.position.z) {
                activateRobotShield();
                break;
            }
        }
    }
    
    // Deactivate shield after duration
    if (robotShieldActive) {
        // Shield lasts 3 seconds (180 frames)
        if (frameCount % 180 === 0) {
            deactivateRobotShield();
        }
    }
}
    
    // Dragon Fire Breath - SIMPLIFIED VERSION
if (currentCharacter === 'dragon') {
    // Auto-destroy obstacles when they get close (no visual fire effect)
    if (dragonFireCooldown <= 0) {
        for (const obstacle of obstacles) {
            // Only check obstacles that are in front of the dragon
            if (obstacle.position.z < player.position.z - 1) {
                // Check if obstacle is in the same lane as the dragon
                const obstacleX = obstacle.position.x;
                const dragonX = lanes[currentLane]; // Dragon's current lane position
                
                // Only destroy obstacles that are:
                // 1. In the exact same lane (within 0.5 units of lane center)
                // 2. Within 6 units in front of the dragon
                if (Math.abs(obstacleX - dragonX) <= 0.5 && 
                    Math.abs(obstacle.position.z - player.position.z) <= 6) {
                    
                    // Create destruction effect without fire particles
                    createObstacleDestruction(obstacle.position);
                    
                    // Remove obstacle
                    scene.remove(obstacle);
                    obstacles.splice(obstacles.indexOf(obstacle), 1);
                    
                    debug('üî• Obstacle destroyed by dragon breath in lane', currentLane);
                    dragonFireCooldown = 240; // 4 second cooldown
                    break;
                }
            }
        }
    }
}
    
    // Ghost Phase Ability
if (currentCharacter === 'ghost') {
    // Initialize charges if starting fresh
    if (ghostPhaseCharges === 0 && ghostPhaseCooldown <= 0) {
        ghostPhaseCharges = 3;
        debug('üëª Ghost starting with 3 phase charges!');
    }
    
    // Restore charges over time (one charge every 5 seconds)
    if (ghostPhaseCharges < 3 && ghostPhaseCooldown <= 0) {
        ghostPhaseCooldown = 300; // 5 seconds to restore next charge
        debug('üëª Ghost charge restoration started...');
    }
    
    // Auto-activate phase when about to hit obstacle (if charges available)
    if (!ghostPhaseActive && ghostPhaseCharges > 0) {
        for (const obstacle of obstacles) {
            const distance = obstacle.position.distanceTo(player.position);
            if (distance < 3 && obstacle.position.z < player.position.z + 1) {
                activateGhostPhase();
                break;
            }
        }
        
        // Also check for water streams
        for (const stream of waterStreams) {
            const distance = stream.position.distanceTo(player.position);
            if (distance < 4 && stream.position.z < player.position.z + 2) {
                activateGhostPhase();
                break;
            }
        }
    }
    
    // Deactivate phase after duration
    if (ghostPhaseActive) {
        // Phase lasts 1 second (60 frames)
        if (frameCount % 60 === 0) {
            deactivateGhostPhase();
        }
    }
}
}

// Robot Shield Functions
function activateRobotShield() {
    robotShieldActive = true;
    robotShieldCooldown = 600; // 10 second cooldown
    
    debug('ü§ñ Robot electromagnetic shield activated!');
    
    // Visual effect - create bright shield dome and brighten particles
    createRobotShieldDome();
    
    if (player.userData && player.userData.fieldParticles) {
        player.userData.fieldParticles.forEach(particle => {
            particle.material.opacity = 1.0; // Much brighter
            particle.material.color.setHex(0x00FFFF);
            particle.material.emissive.setHex(0x0088FF);
            particle.material.emissiveIntensity = 0.8;
        });
    }
}

function deactivateRobotShield() {
    robotShieldActive = false;
    debug('ü§ñ Robot shield deactivated - cooldown: 10 seconds');
    
    // Remove shield dome
    if (player.userData.shieldDome) {
        player.remove(player.userData.shieldDome);
        player.userData.shieldDome = null;
    }
    
    // Visual effect - dim the field particles
    if (player.userData && player.userData.fieldParticles) {
        player.userData.fieldParticles.forEach(particle => {
            particle.material.opacity = 0.3;
            particle.material.color.setHex(0x00DDFF);
            particle.material.emissive.setHex(0x004466);
            particle.material.emissiveIntensity = 0.2;
        });
    }
}

// Create electromagnetic wireframe shield for robot
function createRobotShieldDome() {
    // Remove existing dome if any
    if (player.userData.shieldDome) {
        player.remove(player.userData.shieldDome);
    }
    
    // Create electromagnetic wireframe shield
    const shieldGeometry = new THREE.SphereGeometry(1.0, 12, 12); // Slightly higher detail for better wireframe
    const shieldMaterial = new THREE.MeshBasicMaterial({
        color: 0x00FFFF,        // Bright cyan
        emissive: 0x0088FF,     // Glowing blue
        emissiveIntensity: 0.5, // Electromagnetic glow
        transparent: true,
        opacity: 0.7,           // Semi-transparent
        wireframe: true,        // WIREFRAME MODE - looks electromagnetic!
        side: THREE.DoubleSide  // Visible from inside and outside
    });
    
    const shieldDome = new THREE.Mesh(shieldGeometry, shieldMaterial);
    player.add(shieldDome);
    player.userData.shieldDome = shieldDome;
    
    // Add subtle rotation for electromagnetic field effect
    shieldDome.userData.rotationSpeed = 0.01;
}

// Create simple shield flash effect (performance optimized)
function createShieldSparkEffect(position) {
    // Simple shield flash - just brighten the shield dome briefly
    if (player.userData.shieldDome) {
        // Flash effect by temporarily increasing opacity
        const dome = player.userData.shieldDome;
        dome.material.opacity = 0.8; // Bright flash
        
        // Return to normal opacity after a brief moment
        setTimeout(() => {
            if (dome.material) {
                dome.material.opacity = 0.3; // Back to normal
            }
        }, 100);
    }
    
    // Optional: Play a sound effect instead of visual particles
    // This gives feedback without performance cost
}

// Dragon Fire Functions
function activateDragonFire() {
    dragonFireActive = true;
    dragonFireCooldown = 480; // 8 second cooldown
    
    debug('üêâ Dragon fire breath activated!');
    
    // Make fire particles visible and reset them properly
    if (player.userData && player.userData.fireParticles) {
        player.userData.fireParticles.forEach(particle => {
            particle.visible = true;
            particle.position.set(
                (Math.random() - 0.5) * 0.3,
                0.1 + Math.random() * 0.2,
                1.0
            );
            // Ensure proper opacity and scale
            if (particle.userData) {
                particle.material.opacity = particle.userData.originalOpacity;
            }
            particle.scale.setScalar(1.0);
        });
    }
}

function deactivateDragonFire() {
    dragonFireActive = false;
    debug('üêâ Dragon fire breath deactivated - cooldown: 8 seconds');
    
    // Hide and reset fire particles aggressively
    if (player.userData && player.userData.fireParticles) {
        player.userData.fireParticles.forEach(particle => {
            particle.visible = false;
            // Reset particle position back to dragon's mouth area
            particle.position.set(
                (Math.random() - 0.5) * 0.3,
                0.1 + Math.random() * 0.2,
                particle.userData.baseZ || 0.8
            );
            // Reset opacity and scale
            particle.material.opacity = particle.userData.originalOpacity || 0.7;
            particle.scale.setScalar(1.0);
        });
    }
    
    // Additional cleanup - find any stray fire particles in the scene
    const fireParticlesToRemove = [];
    scene.traverse((object) => {
        if (object.material && 
            object.material.color && 
            (object.material.color.getHex() === 0xFF4500 || 
             object.material.color.getHex() === 0xFF6600 || 
             object.material.color.getHex() === 0xFF8800 || 
             object.material.color.getHex() === 0xFFAA00) &&
            object.geometry && 
            object.geometry.parameters && 
            object.geometry.parameters.radius === 0.04) {
            // This looks like a fire particle
            if (object.parent !== player) {
                fireParticlesToRemove.push(object);
            }
        }
    });
    
    // Remove any stray fire particles
    fireParticlesToRemove.forEach(particle => {
        if (particle.parent) {
            particle.parent.remove(particle);
        } else {
            scene.remove(particle);
        }
        debug('üî• Removed stray fire particle');
    });
}

function destroyObstaclesWithFire() {
    // Destroy obstacles in front of the dragon
    for (let i = obstacles.length - 1; i >= 0; i--) {
        const obstacle = obstacles[i];
        const distance = obstacle.position.distanceTo(player.position);
        
        // Check if obstacle is in fire range (in front of dragon)
        if (distance < 4 && obstacle.position.z > player.position.z - 1 && obstacle.position.z < player.position.z + 3) {
            // Create destruction effect
            createObstacleDestruction(obstacle.position);
            
            // Remove obstacle
            scene.remove(obstacle);
            obstacles.splice(i, 1);
            
            debug('üî• Obstacle destroyed by dragon fire!');
        }
    }
}

// Ghost Phase Functions
function activateGhostPhase() {
    ghostPhaseActive = true;
    ghostPhaseCharges--;
    
    // Start cooldown only if we're out of charges
    if (ghostPhaseCharges <= 0) {
        ghostPhaseCooldown = 300; // 5 seconds to restore first charge
    }
    
    debug(`üëª Ghost phase activated! Charges remaining: ${ghostPhaseCharges}/3`);
}

function deactivateGhostPhase() {
    ghostPhaseActive = false;
    debug('üëª Ghost phase deactivated');
    
    // Start charge restoration immediately if we have no charges left
    if (ghostPhaseCharges <= 0 && ghostPhaseCooldown <= 0) {
        ghostPhaseCooldown = 300; // 5 seconds to restore next charge
        debug('üëª Starting charge restoration...');
    }
}
// Create destruction effect for dragon fire - using existing explosion system
function createObstacleDestruction(position) {
    // Use the existing createSparkle function which works properly
    createSparkle(position);
    
    // Optional: Add a simple flash effect instead of particles
    debug('üí• Obstacle destroyed with sparkle effect!');
}

// Performance helper - only animate objects near player
function shouldAnimateObject(object, maxDistance = 15) {
    return object.position.distanceTo(player.position) < maxDistance;
}



function checkSimpleCollision(obj1, obj2, threshold = 1.5) {
    if (!obj1 || !obj2) return false;
    const distance = obj1.position.distanceTo(obj2.position);
    return distance < threshold;
}

function getCachedCollisionBox(object) {
    return new THREE.Box3().setFromObject(object);
}

function cleanupCollisionCache() {
    // Empty for now
}

        
        // ==================== GAME LOOP & UPDATES ====================
// Main game loop, animation, and real-time updates
// Dependencies: All game systems
// Functions: updateGame(), animate(), gameLoop(), update(), etc.

        // Game animation loop
        function animate() {
    requestAnimationFrame(animate);

    // Enhanced frustum culling - only update visible objects
const frustum = new THREE.Frustum();
const cameraMatrix = new THREE.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
frustum.setFromProjectionMatrix(cameraMatrix);

// Helper function to check if object is in view
function isInCameraView(object) {
    return frustum.intersectsObject(object);
}
    
    // Update the frame counter for all animations
    frameCount++;

    // Staggered updates for performance - different systems update on different frames
    const updateSchedule = {
        butterflies: frameCount % 4 === 0,   // Update butterflies every 4th frame  
        scenery: frameCount % 2 === 0,       // Update scenery every 2nd frame
        particles: frameCount % 2 === 1      // Update particles on alternating frames
    };
    
    // Handle world select screen state
    if (gameState === "worldSelect") {
        // World select screen is handled by its own animation loop
        // Just render the main scene (but don't update game logic)
        renderer.render(scene, camera);
        return;
    }
    
    if (gameState === "playing" && !gameOver && !gamePaused) {
                // Update dynamic difficulty based on time
                updateDynamicDifficulty();
                
                // Update monster character's special animations if selected
if (currentCharacter === 'monster' && player.userData) {
    // Make the dark orb rotate (but don't override jump position)
    player.rotation.y += player.userData.rotateSpeed;
    
    // Only apply bobbing animation when NOT jumping
    if (!jumping) {
        player.position.y = playerY + Math.sin(frameCount * player.userData.bobSpeed) * 0.1;
    }
    
    // Animate the smoky particles
    if (player.children) {
        // Start from index 5 to skip the main body, eyes, mouth and teeth
        for (let i = 5; i < player.children.length; i++) {
            const particle = player.children[i];
            if (particle.userData && particle.userData.initialPosition) {
                // Update angle for orbital motion
                particle.userData.angle += particle.userData.rotationSpeed;
                
                // Orbit around the monster with some oscillation
                const orbitRadius = particle.userData.initialPosition.length() + 
                    Math.sin(frameCount * particle.userData.oscillationSpeed) * 
                    particle.userData.oscillationDistance;
                
                // Calculate new position based on original angle but varying distance
                const newX = orbitRadius * Math.sin(particle.userData.angle);
                const newY = particle.userData.initialPosition.y + 
                    Math.sin(frameCount * 0.1 + i) * 0.05;
                const newZ = orbitRadius * Math.cos(particle.userData.angle);
                
                particle.position.set(newX, newY, newZ);
            }
        }
    }
} 

else if (currentCharacter === 'atom') {
    // Batch atom animations - update every other frame for performance
    if (frameCount % 2 === 0) {
        // Update Atom character animations
        // Rotate all orbitals
        for (let i = 0; i < player.children.length; i++) {
            const child = player.children[i];
            
            // Orbit rotation for the atom's orbital rings
            if (i >= 2 && i <= 4) { // These are the orbital rings
                child.rotation.z += 0.02; // Slightly faster since updating every other frame
            }
            
            // Update electrons
            if (child.userData && child.userData.orbitalIndex !== undefined) {
                const electron = child;
                const orbitalIndex = electron.userData.orbitalIndex;
                const orbitalRadius = electron.userData.orbitalRadius;
                const speed = electron.userData.speed * 2; // Double speed since updating every other frame
                
                // Update electron angle
                electron.userData.angle += speed;
                
                // Position based on orbital orientation
                if (orbitalIndex === 0) {
                    electron.position.x = Math.cos(electron.userData.angle) * orbitalRadius;
                    electron.position.z = Math.sin(electron.userData.angle) * orbitalRadius;
                } else if (orbitalIndex === 1) {
                    electron.position.y = Math.cos(electron.userData.angle) * orbitalRadius;
                    electron.position.z = Math.sin(electron.userData.angle) * orbitalRadius;
                } else {
                    electron.position.x = Math.cos(electron.userData.angle) * orbitalRadius * 0.7;
                    electron.position.y = Math.cos(electron.userData.angle) * orbitalRadius * 0.7;
                    electron.position.z = Math.sin(electron.userData.angle) * orbitalRadius;
                }
            }
            
            // Pulse nucleus sparkles
            if (i === 0) { // Nucleus
                // Update sparkles inside the nucleus
                if (child.children) {
                    child.children.forEach(sparkle => {
                        if (sparkle.userData) {
                            // Pulse size of sparkle
                            const pulseScale = 0.8 + Math.sin(frameCount * sparkle.userData.pulseSpeed + sparkle.userData.pulsePhase) * 0.3;
                            sparkle.scale.set(pulseScale, pulseScale, pulseScale);
                        }
                    });
                }
            }
            
            // Pulse the glow
            if (i === 1) { // Glow sphere
                // Pulse size and opacity
                const pulseScale = 1.0 + Math.sin(frameCount * 0.05) * 0.1;
                child.scale.set(pulseScale, pulseScale, pulseScale);
                child.material.opacity = 0.3 + Math.sin(frameCount * 0.08) * 0.15;
            }
        }
        
        // Add gentle rotation if not jumping
        if (!jumping) {
            player.rotation.y += 0.04; // Double speed since updating every other frame
        }
    }
} else if (currentCharacter === 'ufo' && player.userData) {
    // Rotate the outer ring
    if (player.userData.ring) {
        player.userData.ring.rotation.y += 0.03;
    }
    
    // Pulse the lights
    if (player.userData.lights) {
        player.userData.lights.children.forEach((light, index) => {
            if (light.userData) {
                const pulse = Math.sin(frameCount * light.userData.pulseSpeed + light.userData.pulsePhase);
                light.material.emissiveIntensity = light.userData.originalIntensity + pulse * 0.5;
                
                // Occasional color flash
                if (Math.random() < 0.01) {
                    light.material.color.setHex(0xFFFFFF);
                    light.material.emissive.setHex(0xFFFFFF);
                    setTimeout(() => {
                        light.material.color.setHex(light.userData.originalColor);
                        light.material.emissive.setHex(light.userData.originalColor);
                    }, 100);
                }
            }
        });
    }
    
    // Pulse the dome
    if (player.userData.dome) {
        const domePulse = Math.sin(frameCount * 0.03) * 0.2 + 0.5;
        player.userData.dome.material.emissiveIntensity = domePulse;
    }
    
    // Animate tractor beam
    if (player.userData.beam) {
        const beamPulse = Math.sin(frameCount * 0.05) * 0.1 + 0.2;
        player.userData.beam.material.opacity = beamPulse;
        player.userData.beam.rotation.y += 0.02;
    }
    
    // Float energy particles
    if (player.userData.particles) {
        player.userData.particles.forEach(particle => {
            if (particle.userData) {
                // Orbit motion
                particle.userData.orbitAngle += particle.userData.orbitSpeed;
                const x = Math.cos(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                const z = Math.sin(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                
                // Floating motion
                const floatY = Math.sin(frameCount * particle.userData.floatSpeed + particle.userData.floatOffset) * 0.3;
                
                particle.position.set(x, floatY, z);
                
                // Particle glow pulse
                const glowPulse = Math.sin(frameCount * 0.08 + particle.userData.floatOffset) * 0.3 + 0.7;
                particle.material.opacity = glowPulse;
            }
        });
    }
    
    // Gentle hovering motion when not jumping
    if (!jumping) {
        player.position.y = playerY + Math.sin(frameCount * 0.04) * 0.08;
    }
} else if (currentCharacter === 'dragon' && player.userData) {
    // Animate dragon wings during gameplay
    if (player.userData.wings) {
        const wingFlap = Math.sin(frameCount * 0.15) * 0.3;
        player.userData.wings[0].rotation.z = Math.PI / 3 + wingFlap; // Left wing
        player.userData.wings[1].rotation.z = -Math.PI / 3 - wingFlap; // Right wing
    }
    
    // Animate fire particles when fire breath is active
    if (player.userData.fireParticles) {
        player.userData.fireParticles.forEach((particle, index) => {
            if (dragonFireActive) {
                // Show particle and animate it
                particle.visible = true;
                
                // Keep particles close to dragon mouth with flickering
                const flicker = Math.sin(frameCount * 0.2 + index) * 0.3 + 0.7;
                particle.material.opacity = particle.userData.originalOpacity * flicker;
                particle.scale.setScalar(0.8 + flicker * 0.4);
            } else {
                // Fire is not active - hide particle
                particle.visible = false;
            }
        });
    }
} else if (currentCharacter === 'robot') {
    // Robot running animation - only during gameplay
    if (gameStarted && !gameOver && !gamePaused) {
        // Running body bob - up and down motion
        if (!jumping) {
            const runBob = Math.sin(frameCount * 0.3) * 0.08; // Faster, smaller bob
            player.position.y = playerY + runBob;
        }
        
        // Animate robot arms for running motion
        if (player.children.length >= 6) { // Make sure arms exist
            const leftArm = player.children[4];  // Left arm
            const rightArm = player.children[5]; // Right arm
            
            if (leftArm && rightArm) {
                // Alternating arm swing - opposite arms move opposite directions
                const armSwing = Math.sin(frameCount * 0.3) * 0.4; // Running pace
                
                leftArm.rotation.x = armSwing;        // Left arm forward/back
                rightArm.rotation.x = -armSwing;      // Right arm opposite direction
                
                // Add slight side-to-side motion for more natural running
                leftArm.rotation.z = Math.sin(frameCount * 0.15) * 0.1;
                rightArm.rotation.z = -Math.sin(frameCount * 0.15) * 0.1;
            }
        }
        
        // Slight forward lean while running
        if (!jumping) {
            player.rotation.x = Math.sin(frameCount * 0.3) * 0.05; // Subtle forward/back lean
        }
        
        // Add slight head bob for realism
        if (player.children.length >= 2) {
            const head = player.children[1]; // Head
            if (head) {
                head.rotation.x = Math.sin(frameCount * 0.3 + Math.PI/4) * 0.08; // Slight head bob
            }
        }

// Animate robot legs for running motion
        if (player.children.length >= 8) { // Make sure legs exist
            const leftLeg = player.children[6];  // Left leg
            const rightLeg = player.children[7]; // Right leg
            
            if (leftLeg && rightLeg) {
                // Create the same armSwing calculation for legs
                const armSwing = Math.sin(frameCount * 0.3) * 0.4; // Same as arms
                
                // Forward/back leg swing (opposite to arms for natural running)
                leftLeg.rotation.x = -armSwing * 0.8;   // Left leg opposite to left arm
                rightLeg.rotation.x = armSwing * 0.8;   // Right leg opposite to right arm
                
                // Slight up/down leg movement for realistic stride
                const legLift = Math.abs(Math.sin(frameCount * 0.3)) * 0.05;
                leftLeg.position.y = -0.5 + (armSwing > 0 ? legLift : 0);  // Lift when swinging forward
                rightLeg.position.y = -0.5 + (-armSwing > 0 ? legLift : 0); // Lift when swinging forward
                
                // Add slight side-to-side leg motion for natural gait
                leftLeg.rotation.z = Math.sin(frameCount * 0.15) * 0.05;
                rightLeg.rotation.z = -Math.sin(frameCount * 0.15) * 0.05;
            }
        }

    }
} else if (!jumping && currentCharacter !== 'dragon' && currentCharacter !== 'ghost') {
    // Standard rotation for other characters when not jumping (except robot, dragon, and ghost)
    player.rotation.y += 0.02;
}

// Handle character-specific abilities
handleCharacterAbilities();
                
                // Move player to target lane
                const targetX = lanes[currentLane];
                
                // Adjust movement speed for carrot character (faster lane changes)
                const moveSpeed = currentCharacter === 'carrot' ? 0.15 : 0.1;
                player.position.x += (targetX - player.position.x) * moveSpeed;
                
                // Handle jumping with front flip animation
                if (jumping) {
                    // Apply jump speed with a moderate peak slowdown effect
                    let jumpFactor = 1.0;
                    
                    // Apply a mild slowdown effect near the peak of the jump
                    if (jumpDirection === -1) {
                        // Only slow down during the fall, and only near the top
                        const heightProgress = (player.position.y - playerY) / jumpHeight;
                        if (heightProgress > 0.7) {
                            // Apply more slowdown near the very top (max 40% slowdown)
                            jumpFactor = 0.6 + (0.4 * (1.0 - heightProgress));
                        }
                    }
                    
                    // Apply the adjusted jump speed
                    player.position.y += jumpSpeed * jumpDirection * jumpFactor;
                    
                    // Add front flip animation (but not for UFO or Dragon)
if (currentCharacter !== 'ufo' && currentCharacter !== 'dragon') {
    if (jumpDirection === 1) {
        // Going up - first half of the jump
        jumpRotation += 0.09; // Slightly slower rotation
        // Complete a full rotation (2*PI) over the jump duration
        player.rotation.x = jumpRotation;
    } else {
        // Going down - second half of the jump
        jumpRotation += 0.09; // Slightly slower rotation
        player.rotation.x = jumpRotation;
    }
}
                    
                    // Change direction at peak
                    if (player.position.y >= playerY + jumpHeight) {
                        jumpDirection = -1;
                    }
                    
                    // End jump when back on ground
if (jumpDirection === -1 && player.position.y <= playerY) {
    player.position.y = playerY;
    if (currentCharacter !== 'ufo' && currentCharacter !== 'dragon') {
        player.rotation.x = 0; // Reset rotation (but not for UFO or Dragon)
    }
    jumping = false;
                        
                        // Reset jump speed to normal in case it was modified by quickDrop
if (currentCharacter === 'pumpkin') {
    jumpSpeed = 0.08;
} else {
    jumpSpeed = 0.065;
}
                    }
                }


                
                // Update power-up timers
                if (shieldActive) {
                    powerUpTimers.shield--;
                    if (powerUpTimers.shield <= 0) {
                        shieldActive = false;
                        if (player.userData.shieldEffect) {
                            player.remove(player.userData.shieldEffect);
                            player.userData.shieldEffect = null;
                        }
                        debug('Shield deactivated!');
                    }
                }

                if (coinMultiplierActive) {
                    powerUpTimers.coinMultiplier--;
                    if (powerUpTimers.coinMultiplier <= 0) {
                        coinMultiplierActive = false;
                        debug('Coin multiplier deactivated!');
                    }
                }

                if (magnetActive) {
                    powerUpTimers.magnet--;
                    if (powerUpTimers.magnet <= 0) {
                        magnetActive = false;
                        debug('Magnet deactivated!');
                    }
                }

// Update the status bars
updatePowerUpStatusBar();
updateAbilityStatusBar();
                
                // Staggered updates for better performance
                if (updateSchedule.butterflies) updateButterfliesAndBirds();
                
                // Update water streams
                updateWaterStreams();
                
                // Move ground segments with current speed
groundSegments.forEach(segment => {
    segment.position.z += currentSpeed;
    if (segment.position.z > 55) {
        // Move it to the back
        segment.position.z = -45 * groundSegments.length / 2;
    }
});

// Move side terrain segments with current speed - perfectly synced with ground segments
for (let i = 0; i < groundSegments.length; i++) {
    const groundSegment = groundSegments[i];
    
    // Each ground segment has 4 corresponding side terrain pieces
    const startIndex = i * 4;
    const endIndex = startIndex + 4;
    
    // Sync the 4 side terrain pieces with this ground segment
    for (let j = startIndex; j < endIndex && j < sideTerrainSegments.length; j++) {
        const sideTerrain = sideTerrainSegments[j];
        sideTerrain.position.z = groundSegment.position.z; // Exact sync
    }
}
                
                // Track distance for score
                distanceTraveled += currentSpeed;
                if (Math.floor(distanceTraveled) % 10 === 0) {
                    score++;
                    updateScore();
                }

                // Clean collision cache periodically for performance
if (frameCount % 300 === 0) { // Every 5 seconds
    cleanupCollisionCache(obstacles, 'obstacle');
    cleanupCollisionCache(coins, 'coin');
    cleanupCollisionCache(powerUps, 'powerup');
}
                
                // Spawn obstacles using dynamic spawn rate
                if (frameCount % currentObstacleSpawnRate === 0) {
                    spawnObstacle();
                }

                // Spawn meteors only at Maximum Chaos level (speed level 4+)
if (currentSpeedLevel >= 4) {
    meteorSpawnCounter++;
    
    if (meteorSpawnCounter >= meteorSpawnRate) {
    debug("METEOR SPAWNING NOW!");
    createMeteor();
    meteorSpawnCounter = 0;
    // Randomize next meteor spawn time (slower)
    meteorSpawnRate = 400 + Math.floor(Math.random() * 400); // 400-800 frames (13-27 seconds)
    debug(`Next meteor in ${meteorSpawnRate} frames`);
}
    
    // Only log every 30 frames to reduce spam
    if (meteorSpawnCounter % 30 === 0) {
    debug(`Meteor spawn check - Level: ${currentSpeedLevel}, Counter: ${meteorSpawnCounter}, Rate: ${meteorSpawnRate}`);
}
}
                
                // Track stream spawning
                streamSpawnCounter++;
                streamCreated = false;
                
                // Spawn streams using dynamic spawn rate (much less frequent)
                if (frameCount % currentStreamSpawnRate === 0) {
                    spawnWaterStream();
                }
                
                // Spawn coins
if (frameCount % coinSpawnRate === 0) {
    // 2% chance of spawning rare coin instead of regular coin //RARECOIN
    if (Math.random() < 0.0075) {
        spawnRareCoin();
    } else {
        spawnCoin();
    }
}

// Spawn power-ups with collision avoidance
if (frameCount % powerUpSpawnRate === 0) {
    // Get available lanes (avoid lanes with recent power-ups)
    const availableLanes = [];
    for (let i = 0; i < 3; i++) {
        let laneBlocked = false;
        // Check if any power-up is in this lane and still close
        for (const powerUp of powerUps) {
            if (Math.abs(powerUp.position.x - lanes[i]) < 0.5 && powerUp.position.z > -20) {
                laneBlocked = true;
                break;
            }
        }
        if (!laneBlocked) {
            availableLanes.push(i);
        }
    }
    
    // Only spawn if we have available lanes
    if (availableLanes.length > 0) {
        const powerUpType = Math.random();
        debug("Spawning power-up at frame:", frameCount, "Available lanes:", availableLanes);
        
        if (powerUpType < 0.33) {
            spawnShieldPowerUpInLane(availableLanes);
            debug("Shield power-up spawned");
        } else if (powerUpType < 0.66) {
            spawnCoinMultiplierPowerUpInLane(availableLanes);
            debug("Coin multiplier power-up spawned");
        } else {
            spawnMagnetPowerUpInLane(availableLanes);
            debug("Magnet power-up spawned");
        }
    } else {
        debug("No available lanes for power-up spawn");
    }
}


                
                // Spawn scenery objects (stays constant)
                if (frameCount % scenerySpawnRate === 0) {
                    spawnScenery();
                }
                
                // Move and animate coins with current speed
for (let i = coins.length - 1; i >= 0; i--) {
    const coin = coins[i];
    coin.position.z += currentSpeed;
    
    // Rotate coin for visual appeal
    coin.rotation.y += 0.05;
    
    // Highlight removed - no longer needed
    
    // Animate sparkles only for nearby coins (performance optimization)
if (coin.userData.sparkles && coin.position.distanceTo(player.position) < 10) {
    coin.userData.sparkles.forEach(sparkle => {
        // Orbit around the coin
        sparkle.userData.orbitAngle += sparkle.userData.orbitSpeed;
        sparkle.position.x = Math.cos(sparkle.userData.orbitAngle) * sparkle.userData.orbitRadius;
        sparkle.position.z = Math.sin(sparkle.userData.orbitAngle) * sparkle.userData.orbitRadius;
        
        // Pulse the sparkle size and opacity
        const pulseScale = 0.5 + Math.sin(frameCount * sparkle.userData.pulseSpeed + sparkle.userData.pulsePhase) * 0.5;
        sparkle.scale.set(pulseScale, pulseScale, pulseScale);
        sparkle.material.opacity = 0.6 + Math.sin(frameCount * sparkle.userData.pulseSpeed * 1.5 + sparkle.userData.pulsePhase) * 0.4;
    });
}
                    
                    // Magnet effect - attract coins to player
if (magnetActive) {
    const distance = coin.position.distanceTo(player.position);
    if (distance < 5) { // Magnet range
        const direction = new THREE.Vector3().subVectors(player.position, coin.position).normalize();
        coin.position.add(direction.multiplyScalar(0.2)); // Pull towards player
    }
}

// Check if collected - only if coin is actually near player
const coinDistance = coin.position.distanceTo(player.position);
if (coinDistance < 1.5 && checkCollision(coin)) {
    // Coin collected!
    window.AudioSystem.playCoinSound();
    createSparkle(coin.position.clone());
    scene.remove(coin);
    coins.splice(i, 1);
    
    // Apply coin multiplier to both score and coin balance
    const coinValue = coinMultiplierActive ? 20 : 10; // 2x when multiplier active
    const actualCoins = coinMultiplierActive ? 2 : 1; // 2x coins when multiplier active
    
    score += coinValue;
    totalCoins += actualCoins; // Add coins to balance immediately
    
    updateScore();
    updateTotalCoins(); // Update coin display immediately
    

    
    if (coinMultiplierActive) {
        debug('Coin collected with 2x multiplier!');
    }
}
                    
                    // Remove coins that have passed the player
                    else if (coin.position.z > 5) {
                        scene.remove(coin);
                        coins.splice(i, 1);
                    }
                }

// Move and animate rare coins
                for (let i = rareCoins.length - 1; i >= 0; i--) {
                    const rareCoin = rareCoins[i];
                    rareCoin.position.z += playerSpeed; // Use the existing playerSpeed variable
                    
                    // Rotate rare coin faster for visual appeal
                    rareCoin.rotation.y += rareCoin.userData.rotationSpeed;
                    
                    // Animate sparkles around the rare coin
                    if (rareCoin.userData.sparkles) {
                        rareCoin.userData.sparkles.forEach(sparkle => {
                            // Orbit around the coin
                            sparkle.userData.orbitAngle += sparkle.userData.orbitSpeed;
                            sparkle.position.x = Math.cos(sparkle.userData.orbitAngle) * sparkle.userData.orbitRadius;
                            sparkle.position.z = Math.sin(sparkle.userData.orbitAngle) * sparkle.userData.orbitRadius;
                            
                            // Pulse the sparkle
                            const pulseScale = 0.5 + Math.sin(frameCount * sparkle.userData.pulseSpeed + sparkle.userData.pulsePhase) * 0.5;
                            sparkle.scale.set(pulseScale, pulseScale, pulseScale);
                            sparkle.material.opacity = 0.6 + Math.sin(frameCount * sparkle.userData.pulseSpeed * 1.5 + sparkle.userData.pulsePhase) * 0.4;
                        });
                    }
                    
                    // Magnet effect for rare coins too
if (magnetActive) {
    const distance = rareCoin.position.distanceTo(player.position);
    if (distance < 5) { // Magnet range
        const direction = new THREE.Vector3().subVectors(player.position, rareCoin.position).normalize();
        rareCoin.position.add(direction.multiplyScalar(0.2)); // Pull towards player
    }
}

// Check if collected
if (checkCollision(rareCoin)) {
    // Rare coin collected! Big reward!
    window.AudioSystem.playRareCoinSound();
    createSparkle(rareCoin.position.clone());
    scene.remove(rareCoin);
    rareCoins.splice(i, 1);
    
    // Apply multiplier to rare coins too
    const rareScoreBonus = coinMultiplierActive ? 200 : 100;
    const rareCoinBonus = coinMultiplierActive ? 200 : 100;
    
    score += rareScoreBonus;
    totalCoins += rareCoinBonus;
    updateScore();
    updateTotalCoins();
    
    
    debug(`RARE COIN COLLECTED! +${rareCoinBonus} coins!`);
    if (coinMultiplierActive) {
        debug('Rare coin got 2x multiplier bonus!');
    }
}
                    
                    // Remove rare coins that have passed the player
                    else if (rareCoin.position.z > 5) {
                        scene.remove(rareCoin);
                        rareCoins.splice(i, 1);
                    }
                }

                // Move and animate power-ups
                for (let i = powerUps.length - 1; i >= 0; i--) {
                    const powerUp = powerUps[i];
                    
                    
                    
                    powerUp.position.z += currentSpeed; // Use same speed as other objects
                    
                    // Rotate power-up for visual appeal
                    powerUp.rotation.y += 0.03;
                    
                    // Animate specific power-up effects
                    if (powerUp.userData.type === 'shield' && powerUp.userData.particles) {
                        // Animate shield particles
                        powerUp.userData.particles.forEach(particle => {
                            particle.userData.orbitAngle += particle.userData.orbitSpeed;
                            particle.position.x = Math.cos(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                            particle.position.y = Math.sin(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                        });
                    } else if (powerUp.userData.type === 'magnet' && powerUp.userData.fieldParticles) {
                        // Animate magnet field particles
                        powerUp.userData.fieldParticles.forEach(particle => {
                            particle.userData.orbitAngle += particle.userData.orbitSpeed;
                            particle.position.x = Math.cos(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                            particle.position.y = Math.sin(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                        });
                    }
                    
                    // Check for collision with player using simple distance
const distance = powerUp.position.distanceTo(player.position);

if (distance < 1.5) { // Simple distance-based collision
    activatePowerUp(powerUp.userData.type);
    scene.remove(powerUp);
    powerUps.splice(i, 1);
}
                    
                    // Remove power-ups that have passed the player
                    else if (powerUp.position.z > 5) {
                        debug(`Removing power-up ${powerUp.userData.type} that passed player`);
                        scene.remove(powerUp);
                        powerUps.splice(i, 1);
                    }
                }
                
                // Move obstacles with current speed
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    const obstacle = obstacles[i];
                    obstacle.position.z += currentSpeed;
                    
// Check for collision
if (checkCollision(obstacle)) {
    // Collision detected
    
    if (shieldActive) {
        // Shield protects - remove obstacle instead
        scene.remove(obstacle);
        obstacles.splice(i, 1);
        debug('Shield blocked collision!');
    } else {
        endGame();
    }
}
                    
                    // Remove obstacles that have passed the player
                    if (obstacle.position.z > 5) {
                        scene.remove(obstacle);
                        obstacles.splice(i, 1);
                    }
                }
                
                // Move scenery objects with current speed - only animate nearby objects
for (let i = sceneryObjects.length - 1; i >= 0; i--) {
    const scenery = sceneryObjects[i];
    scenery.position.z += currentSpeed;
    
    // Only run complex animations for nearby scenery
    if (!shouldAnimateObject(scenery, 20)) {
        // Skip animations for distant objects
        if (scenery.position.z > 20) {
            scene.remove(scenery);
            sceneryObjects.splice(i, 1);
        }
        continue;
    }
    
    // Animate forest-specific scenery
    if (currentWorld === 'forest') {
        scenery.children.forEach(child => {
            // Animate ferns swaying
            if (child.userData && child.userData.swaySpeed) {
                child.rotation.z = Math.sin(frameCount * child.userData.swaySpeed + child.userData.swayOffset) * child.userData.swayAmount;
            }
            
            // Animate fireflies floating
            if (child.userData && child.userData.floatSpeed) {
                child.userData.floatAngle += child.userData.floatSpeed;
                const floatX = Math.cos(child.userData.floatAngle) * child.userData.floatRadius;
                const floatY = Math.sin(child.userData.floatAngle * 0.7) * child.userData.floatRadius * 0.5;
                
                child.position.x = child.userData.basePosition.x + floatX;
                child.position.y = child.userData.basePosition.y + floatY;
                
                // Pulse brightness
                const pulse = Math.sin(frameCount * child.userData.pulseSpeed + child.userData.pulsePhase) * 0.5 + 0.5;
                child.material.opacity = 0.4 + pulse * 0.6;
            }
            
            // Animate magical orbs around ancient oaks
            if (child.userData && child.userData.orbitSpeed) {
                child.userData.orbitAngle += child.userData.orbitSpeed;
                child.position.x = Math.cos(child.userData.orbitAngle) * child.userData.orbitRadius;
                child.position.z = Math.sin(child.userData.orbitAngle) * child.userData.orbitRadius;
                
                // Gentle floating motion
                const float = Math.sin(frameCount * child.userData.pulseSpeed) * 0.3;
                child.position.y = child.userData.baseHeight + float;
                
                // Pulse the magical orbs
                const orbPulse = Math.sin(frameCount * child.userData.pulseSpeed) * 0.4 + 0.6;
                child.material.opacity = orbPulse;
                child.scale.setScalar(0.8 + orbPulse * 0.4);
            }
        });
    }

    // Animate underwater-specific scenery
else if (currentWorld === 'underwater' && scenery.userData.sceneryType) {
    scenery.children.forEach(child => {
        // Animate kelp swaying
        if (child.userData && child.userData.swaySpeed) {
            const sway = Math.sin(frameCount * child.userData.swaySpeed + child.userData.swayOffset) * child.userData.swayAmount;
            child.rotation.z = (child.userData.originalRotation || 0) + sway;
            
            // Kelp also bends slightly forward/back
            child.rotation.x = Math.sin(frameCount * child.userData.swaySpeed * 0.7 + child.userData.swayOffset) * child.userData.swayAmount * 0.5;
        }
        
        // Animate fish swimming
        if (child.userData && child.userData.swimSpeed) {
            // Horizontal swimming motion
            const swimX = Math.sin(frameCount * child.userData.swimSpeed + child.userData.swimOffset) * 0.3;
            child.position.x = child.userData.basePosition.x + swimX;
            
            // Gentle vertical floating
            const floatY = Math.sin(frameCount * child.userData.swimSpeed * 0.5) * child.userData.verticalFloat;
            child.position.y = child.userData.basePosition.y + floatY;
            
            // Slight body rotation for swimming motion
            child.rotation.z = Math.sin(frameCount * child.userData.swimSpeed * 2) * 0.1;
            child.rotation.y = Math.sin(frameCount * child.userData.swimSpeed) * 0.2;
        }
        
        // Animate bubbles rising
        if (child.userData && child.userData.riseSpeed) {
            child.position.y += child.userData.riseSpeed;
            
            // Wobble as they rise
            const wobbleX = Math.sin(frameCount * child.userData.wobbleSpeed) * child.userData.wobbleAmount;
            const wobbleZ = Math.cos(frameCount * child.userData.wobbleSpeed) * child.userData.wobbleAmount;
            child.position.x += wobbleX * 0.01;
            child.position.z += wobbleZ * 0.01;
            
            // Reset bubble when it gets too high
            if (child.position.y > 5) {
                child.position.y = child.userData.startY || 0;
                // Reset to original X/Z position
                child.position.x = (Math.random() - 0.5) * 0.3;
                child.position.z = (Math.random() - 0.5) * 0.3;
            }
            
            // Bubbles get slightly bigger as they rise
            const scaleIncrease = 1 + (child.position.y / 10);
            child.scale.setScalar(child.userData.size * scaleIncrease);
        }
        
        // Animate jellyfish
        if (child.userData && child.userData.floatSpeed) {
            // Gentle floating up and down
            const floatY = Math.sin(frameCount * child.userData.floatSpeed) * child.userData.floatRange;
            child.position.y = child.userData.baseY + floatY;
            
            // Pulsing bell animation
            const pulse = Math.sin(frameCount * child.userData.pulseSpeed) * 0.1 + 1;
            if (child.children[0]) { // Bell mesh
                child.children[0].scale.set(pulse, pulse * 0.8, pulse);
            }
            
            // Animate tentacles
            child.children.forEach((tentacle, index) => {
                if (tentacle.userData && tentacle.userData.waveSpeed) {
                    const wave = Math.sin(frameCount * tentacle.userData.waveSpeed + tentacle.userData.waveOffset) * tentacle.userData.waveAmount;
                    tentacle.rotation.x = wave;
                    tentacle.rotation.z = wave * 0.5;
                }
            });
        }
        
        // Animate seaweed on sunken ship
        if (child.userData && child.userData.waveSpeed && scenery.userData.sceneryType === 'sunkenShip') {
            const wave = Math.sin(frameCount * child.userData.waveSpeed) * child.userData.waveAmount;
            child.rotation.z = wave;
            child.rotation.x = Math.PI / 6 + wave * 0.5;
        }
    });
    
    // School of fish group movement
    if (scenery.userData && scenery.userData.schoolSpeed) {
        scenery.userData.schoolDirection += Math.sin(frameCount * 0.001) * 0.01;
        scenery.rotation.y = scenery.userData.schoolDirection;
        
        // Gentle up/down movement for the whole school
        scenery.position.y = scenery.userData.baseY + Math.sin(frameCount * 0.01) * 0.3;
    }
}
    
    // Remove scenery that has passed the player
    if (scenery.position.z > 20) {
        scene.remove(scenery);
        sceneryObjects.splice(i, 1);
    }
}

// Update meteors
for (let i = meteors.length - 1; i >= 0; i--) {
    const meteor = meteors[i];
    
    
    
    // Move meteor down and sync with player's movement
meteor.position.y -= meteor.userData.fallSpeed;
// Move at exactly the same speed as the game world so it crashes right where player is
meteor.position.z += currentSpeed; // Same speed as scene - will hit player's position

// Keep meteor aligned to its target lane (no drift)
meteor.position.x = lanes[meteor.userData.targetLane];
    
    // Rotate meteor
    meteor.rotation.x += meteor.userData.rotationSpeed;
    meteor.rotation.y += meteor.userData.rotationSpeed * 0.7;
    meteor.rotation.z += meteor.userData.rotationSpeed * 0.5;
    
    // Animate floating chunks
    if (meteor.userData.chunks) {
        meteor.userData.chunks.forEach(chunk => {
            chunk.userData.orbitAngle += chunk.userData.orbitSpeed;
            const newX = Math.cos(chunk.userData.orbitAngle) * chunk.userData.orbitRadius;
            const newZ = Math.sin(chunk.userData.orbitAngle) * chunk.userData.orbitRadius;
            chunk.position.x = newX;
            chunk.position.z = newZ;
        });
    }
    
    // Animate fire trail
    if (meteor.userData.trailParticles) {
        meteor.userData.trailParticles.forEach(particle => {
            const flicker = Math.sin(frameCount * particle.userData.flickerSpeed) * 0.3 + 0.7;
            particle.material.opacity = particle.userData.originalOpacity * flicker;
            particle.scale.setScalar(0.8 + flicker * 0.4);
        });
    }
    
    // Check for collision with player (only if meteor is at ground level and same lane)
const meteorLane = meteor.userData.targetLane;
const playerLane = currentLane;

if (meteorLane === playerLane && meteor.position.y <= 1.0 && checkCollision(meteor)) {
    endGame();
}
    
    // Remove meteor if it hits the ground or goes too far ahead
if (meteor.position.y < -1 || meteor.position.z > player.position.z + 15) {
    // Create impact effect when hitting ground
    if (meteor.position.y < -1) {
        createMeteorImpact(meteor.position);
    }
    
    scene.remove(meteor);
    meteors.splice(i, 1);
}
}
                
                // Update sparkle animations
                updateSparkles();
// Update background music intensity
                updateBackgroundMusic();


            } else if (gameOver) {
                // Update explosion animation if game is over
                updateExplosion();
                // Continue updating sparkles even in game over state
                updateSparkles();
                updateButterfliesAndBirds();
            }
            
            renderer.render(scene, camera);
        }
        
        // Initialize on load
        document.addEventListener('DOMContentLoaded', init);

    

        // ==================== AUTOMATIC SAVE SYSTEM ====================
// Save game data when page closes or periodically

// Save every 30 seconds during gameplay
let autoSaveInterval;

function startAutoSave() {
    if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
    }
    
    autoSaveInterval = setInterval(() => {
        if (gameState === "playing" && !gamePaused) {
            debug('üîÑ Auto-saving game progress...');
            saveGameData();
        }
    }, 30000); // Every 30 seconds
}

function stopAutoSave() {
    if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
        autoSaveInterval = null;
    }
}

// Save when page is about to close
window.addEventListener('beforeunload', function(event) {
    debug('üíæ Saving game data before page closes...');
    saveGameData();
});

// Save when page becomes hidden (mobile/tab switching)
document.addEventListener('visibilitychange', function() {
    if (document.hidden) {
        debug('üíæ Saving game data (page hidden)...');
        saveGameData();
    }
});

// Save when window loses focus
window.addEventListener('blur', function() {
    debug('üíæ Saving game data (window lost focus)...');
    saveGameData();
});

// Start auto-save when game starts
startAutoSave();
    </script>

    <script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then(registration => {
        console.log('SW registered: ', registration);
      })
      .catch(registrationError => {
        console.log('SW registration failed: ', registrationError);
      });
  });
}
</script>
</body>
</html>