<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Endless Runner</title>

<!-- Firebase Scripts -->
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>

<link rel="stylesheet" href="menu-styles.css">
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Exo+2:wght@300;400;500;600;700&display=swap" rel="stylesheet">


<script>
// Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyDr_qv6W6AxuXGWG49bTdr0j2DvmMZObnA",
  authDomain: "running-blitz.firebaseapp.com",
  databaseURL: "https://running-blitz-default-rtdb.firebaseio.com",
  projectId: "running-blitz",
  storageBucket: "running-blitz.firebasestorage.app",
  messagingSenderId: "511589639020",
  appId: "1:511589639020:web:a0c3cbc26e293a00834949"
};

// Initialize Firebase
firebase.initializeApp(firebaseConfig);
</script>

    <style>


@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Exo+2:wght@300;400;500;600;700&display=swap');

/* Fix canvas positioning for character/world select screens */
#characterSelectCanvas, #worldSelectCanvas {
    position: absolute !important;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

/* Ensure 3D content shows in preview boxes */
#characterDisplay canvas,
#worldPreview canvas {
    position: absolute !important;
    top: 0;
    left: 0;
    width: 100% !important;
    height: 100% !important;
    border-radius: 20px;
}

/* Prevent flash of unstyled content */
body.loading #score,
body.loading #totalCoins,
body.loading #pauseBtn,
body.loading #speedIndicator,
body.loading #powerUpStatusBar,
body.loading #swipeInstructions {
    display: none !important;
}

        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #000;
            touch-action: none; /* Disable browser's default touch actions */
        }
        #score {
    position: absolute;
    top: 20px;
    right: 20px;
    color: white;
    font-size: 24px;
    z-index: 100;
    text-align: right;
    display: none; /* Hide by default */
}
        #totalCoins {
    position: absolute;
    top: 55px;
    right: 20px;
    color: gold;
    font-size: 20px;
    z-index: 100;
    text-align: right;
    display: none; /* Hide by default */
}
        #pauseBtn {
    position: absolute;
    top: 95px;
    right: 20px;
    width: 40px;
    height: 40px;
    background-color: rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 24px;
    color: white;
    cursor: pointer;
    z-index: 100;
    border: none;
    display: none; /* Hide by default */
}
        
        #speedIndicator {
    position: absolute;
    top: 20px;
    left: 20px;
    padding: 12px 20px;
    background-color: rgba(255, 255, 255, 0.3);
    border-radius: 25px;
    color: white;
    font-size: 18px;
    font-weight: bold;
    z-index: 100;
    border: 2px solid rgba(255, 255, 255, 0.5);
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
    transition: all 0.5s ease;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    min-width: 200px;
    white-space: nowrap;
    text-align: center;
    display: none; /* Hide by default */
}


    
    /* Mobile Responsive Adjustments */
@media (max-width: 768px) {
    .selection-container {
        padding: 1rem;
        height: calc(100% - 70px);
    }
    
    .preview-area {
        gap: 1rem;
    }
    
    .preview-box {
        width: 280px;
        height: 280px;
    }
    
    .preview-box.world-preview {
        width: 320px;
        height: 200px;
    }
    
    .preview-controls {
        flex-wrap: wrap;
        gap: 1rem;
    }
    
    .character-info-card, .world-info-card {
        min-width: 250px;
        padding: 1rem 1.5rem;
    }
    
    .character-info-card h3, .world-info-card h3 {
        font-size: 1.5rem;
    }
    
    .nav-button {
        width: 50px;
        height: 50px;
        font-size: 20px;
    }
    
    .action-buttons-container {
        flex-direction: column;
        width: 100%;
        max-width: 300px;
        margin-top: 0.5rem;
    }
    
    .action-button {
        font-size: 1rem;
        padding: 0.8rem 1.5rem;
        width: 100%;
    }
}

/* Extra small screens */
@media (max-width: 480px) {
    .preview-box {
        width: 240px;
        height: 240px;
    }
    
    .preview-box.world-preview {
        width: 280px;
        height: 180px;
    }
}

/* Speed level animations */
.speed-level-1 {
    background: linear-gradient(45deg, rgba(135, 206, 235, 0.8), rgba(100, 149, 237, 0.8));
    border-color: rgba(135, 206, 235, 0.8);
    box-shadow: 0 0 15px rgba(135, 206, 235, 0.5);
}

.speed-level-2 {
    background: linear-gradient(45deg, rgba(255, 215, 0, 0.8), rgba(255, 165, 0, 0.8));
    border-color: rgba(255, 215, 0, 0.8);
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
    animation: pulse-yellow 1s infinite alternate;
}

.speed-level-3 {
    background: linear-gradient(45deg, rgba(255, 69, 0, 0.8), rgba(255, 140, 0, 0.8));
    border-color: rgba(255, 69, 0, 0.8);
    box-shadow: 0 0 25px rgba(255, 69, 0, 0.7);
    animation: pulse-orange 0.8s infinite alternate;
    border-radius: 15px;
}

.speed-level-4 {
    background: linear-gradient(45deg, rgba(220, 20, 60, 0.9), rgba(255, 0, 0, 0.9));
    border-color: rgba(220, 20, 60, 0.9);
    box-shadow: 0 0 30px rgba(220, 20, 60, 0.8), inset 0 0 10px rgba(255, 0, 0, 0.3);
    animation: intense-flame 0.6s infinite alternate;
    border-radius: 10px;
}

.speed-level-5 {
    background: linear-gradient(45deg, rgba(139, 0, 139, 0.9), rgba(75, 0, 130, 0.9));
    border-color: rgba(139, 0, 139, 0.9);
    box-shadow: 0 0 35px rgba(139, 0, 139, 0.9), inset 0 0 15px rgba(75, 0, 130, 0.4);
    animation: chaos-mode 0.4s infinite;
    border-radius: 5px;
}

@keyframes pulse-yellow {
    0% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.6); }
    100% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.8); }
}

@keyframes pulse-orange {
    0% { box-shadow: 0 0 25px rgba(255, 69, 0, 0.7); }
    100% { box-shadow: 0 0 35px rgba(255, 69, 0, 0.9); }
}

@keyframes intense-flame {
    0% { 
        box-shadow: 0 0 30px rgba(220, 20, 60, 0.8), inset 0 0 10px rgba(255, 0, 0, 0.3);
    }
    100% { 
        box-shadow: 0 0 40px rgba(220, 20, 60, 1.0), inset 0 0 20px rgba(255, 0, 0, 0.5);
    }
}

@keyframes chaos-mode {
    0% { 
        box-shadow: 0 0 35px rgba(139, 0, 139, 0.9), inset 0 0 15px rgba(75, 0, 130, 0.4);
    }
    25% { 
        box-shadow: 0 0 45px rgba(255, 0, 255, 1.0), inset 0 0 25px rgba(138, 43, 226, 0.6);
    }
    50% { 
        box-shadow: 0 0 40px rgba(75, 0, 130, 1.0), inset 0 0 20px rgba(139, 0, 139, 0.5);
    }
    100% { 
        box-shadow: 0 0 50px rgba(139, 0, 139, 1.0), inset 0 0 30px rgba(75, 0, 130, 0.7);
    }
}
        #pauseScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 150;
        }
        #pauseScreen h2 {
            color: white;
            font-size: 48px;
            margin-bottom: 20px;
        }
        #pauseScreen p {
            color: white;
            font-size: 24px;
            margin-bottom: 20px;
        }
        #resumeButton {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 10px;
        }
        #gameOver {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 150;
    text-align: center;
    color: white;
    font-size: 24px;
    padding: 20px;
    box-sizing: border-box;
}
        
        #startScreen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 200;
}
        #startScreen h1 {
            color: white;
            font-size: 48px;
            margin-bottom: 20px;
        }
        #startButton {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .game-button {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
        }
        #settingsScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            background-color: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 150;
            border-radius: 10px;
            padding: 20px;
            overflow-y: auto;
        }
        #settingsScreen h2 {
            color: white;
            font-size: 36px;
            margin-bottom: 20px;
        }
        .settings-section {
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            width: 100%;
            margin-bottom: 20px;
            padding: 15px;
            box-sizing: border-box;
        }
        .settings-section h3 {
            color: white;
            margin-top: 0;
            text-align: center;
        }
        .character-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            width: 100%;
        }
        .character-option {
            display: flex;
            align-items: center;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
        }
        .character-option.selected {
            background-color: rgba(76, 175, 80, 0.3);
        }
        .character-preview {
            width: 60px;
            height: 60px;
            margin-right: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
        }
        .character-info {
            flex-grow: 1;
            color: white;
        }
        .character-action {
            padding: 5px 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .character-action.disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        .mod-option {
            display: flex;
            align-items: center;
            margin: 15px 0;
        }
        .mod-option.enabled {
            background-color: rgba(76, 175, 80, 0.3);
        }
        .mod-info {
            flex-grow: 1;
            color: white;
        }
        .mod-action {
            padding: 8px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .mod-password {
            padding: 10px;
            margin: 10px 0;
            border: none;
            border-radius: 5px;
            width: 100%;
        }
        #closeSettingsButton {
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #333;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #touchArea {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 80%; /* Increased touch area height */
            z-index: 50;
            display: none;
        }
        #swipeInstructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 16px;
            text-align: center;
            z-index: 100;
            display: none; /* Hide by default */
        }
        /* Modal overlay for clicking outside to close */
        #modalOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 140;
            display: none;
        }
        /* Leaderboard styles */
        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            color: white;
        }
        .leaderboard-table th, 
        .leaderboard-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        .leaderboard-table th {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .leaderboard-table tr:nth-child(even) {
            background-color: rgba(255, 255, 255, 0.05);
        }
        .leaderboard-table tr:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .tab-buttons {
            display: flex;
            margin-bottom: 15px;
            width: 100%;
        }
        .tab-button {
            flex: 1;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .tab-button:first-child {
            border-top-left-radius: 5px;
            border-bottom-left-radius: 5px;
        }
        .tab-button:last-child {
            border-top-right-radius: 5px;
            border-bottom-right-radius: 5px;
        }
        .tab-button.active {
            background-color: rgba(76, 175, 80, 0.5);
        }
        .tab-content {
            display: none;
            width: 100%;
        }
        .tab-content.active {
            display: block;
        }

        /* Jukebox Styles */
.track-option {
    display: flex;
    align-items: center;
    padding: 12px;
    margin-bottom: 8px;
    background-color: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 2px solid transparent;
}

.track-option:hover {
    background-color: rgba(255, 255, 255, 0.1);
    transform: translateX(5px);
}

.track-option.selected {
    background-color: rgba(76, 175, 80, 0.2);
    border-color: rgba(76, 175, 80, 0.6);
    box-shadow: 0 0 15px rgba(76, 175, 80, 0.3);
}

.track-info {
    flex-grow: 1;
    color: white;
}

.track-name {
    font-size: 18px;
    font-weight: bold;
    margin-bottom: 4px;
}

.track-description {
    font-size: 14px;
    opacity: 0.8;
    font-style: italic;
}

.track-icon {
    font-size: 24px;
    margin-right: 15px;
    filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.3));
}

.track-status {
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: bold;
    text-transform: uppercase;
}

.track-playing {
    background: linear-gradient(45deg, #4CAF50, #8BC34A);
    color: white;
    animation: pulse-playing 1.5s infinite;
}

.track-selected {
    background: linear-gradient(45deg, #FF9800, #FFC107);
    color: white;
}

@keyframes pulse-playing {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.05); opacity: 0.8; }
    100% { transform: scale(1); opacity: 1; }
}

        #playerNameInput {
            padding: 10px;
            margin: 10px 0;
            width: 100%;
            border: none;
            border-radius: 5px;
            box-sizing: border-box;
            background-color: rgba(255, 255, 255, 0.8);
        }
        #saveScoreButton {
            padding: 10px 20px;
            margin-top: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

/* Audio control checkboxes */
.audio-checkbox {
    position: relative;
    display: inline-block;
    cursor: pointer;
    font-size: 18px;
    user-select: none;
}

.audio-setting-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem 1.5rem;
    background: rgba(15, 20, 25, 0.4);
    border-radius: 10px;
    margin-bottom: 0.8rem;
    max-width: 100%; /* Ensure it doesn't overflow */
}

.audio-label {
    color: #e6edf3;
    font-family: 'Exo 2', sans-serif;
    font-size: 1.1rem;
    flex: 1; /* Take up available space */
}

.audio-checkbox {
    position: relative;
    width: 50px;
    height: 26px;
    margin-left: 1rem; /* Add some spacing from the label */
    flex-shrink: 0; /* Prevent checkbox from shrinking */
}

.audio-checkbox input {
    opacity: 0;
    width: 0;
    height: 0;
}

.checkmark {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(79, 172, 254, 0.2);
    border: 1px solid rgba(79, 172, 254, 0.3);
    border-radius: 13px;
    transition: all 0.3s ease;
}

.checkmark:after {
    content: "";
    position: absolute;
    display: none;
    left: 5px;
    top: 50%;
    transform: translateY(-50%);
    width: 18px;
    height: 18px;
    background-color: #43cbff;
    border-radius: 50%;
    transition: all 0.3s ease;
    box-shadow: 0 0 10px rgba(67, 203, 255, 0.5);
}

.audio-checkbox input:checked ~ .checkmark {
    background-color: rgba(67, 203, 255, 0.2);
    border-color: rgba(67, 203, 255, 0.5);
}

.audio-checkbox input:checked ~ .checkmark:after {
    display: block;
    transform: translateY(-50%) translateX(20px);
}

/* Ensure the settings section doesn't overflow */
.settings-section {
    padding: 1.5rem;
    max-width: 100%;
    box-sizing: border-box;
}

.settings-section h3 {
    margin-bottom: 1rem;
    color: #43cbff;
    font-family: 'Exo 2', sans-serif;
}

.audio-setting-row:last-child {
    border-bottom: none;
}

.audio-label {
    color: white;
    font-size: 16px;
    font-weight: normal;
    flex-grow: 1;
}

/* Adjust checkbox size for compact layout and keep it contained */
.audio-setting-row .audio-checkbox {
    margin-left: 10px;
    flex-shrink: 0;
}

.audio-setting-row .audio-checkbox .checkmark {
    height: 20px;
    width: 20px;
}

.audio-setting-row .audio-checkbox .checkmark:after {
    left: 6px;
    top: 2px;
    width: 5px;
    height: 10px;
}

.audio-setting-row .audio-checkbox .checkmark:after {
    left: 6px;
    top: 2px;
    width: 5px;
    height: 10px;
}

.audio-checkbox input {
    position: absolute;
    opacity: 0;
    cursor: pointer;
    height: 0;
    width: 0;
}

.checkmark {
    position: absolute;
    top: 0;
    left: 0;
    height: 25px;
    width: 25px;
    background-color: rgba(255, 255, 255, 0.2);
    border: 2px solid rgba(255, 255, 255, 0.5);
    border-radius: 5px;
    transition: all 0.3s ease;
}

.audio-checkbox:hover input ~ .checkmark {
    background-color: rgba(255, 255, 255, 0.3);
}

.audio-checkbox input:checked ~ .checkmark {
    background-color: #4CAF50;
    border-color: #4CAF50;
}

.checkmark:after {
    content: "";
    position: absolute;
    display: none;
}

.audio-checkbox input:checked ~ .checkmark:after {
    display: block;
}

.audio-checkbox .checkmark:after {
    left: 8px;
    top: 4px;
    width: 6px;
    height: 12px;
    border: solid white;
    border-width: 0 3px 3px 0;
    transform: rotate(45deg);
}

/* Power-up Status Bar */
#powerUpStatusBar {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: none; /* Hide by default - was flex */
    gap: 20px;
    z-index: 100;
    background: rgba(0, 0, 0, 0.5);
    padding: 10px 20px;
    border-radius: 25px;
    backdrop-filter: blur(10px);
}

.powerup-icon {
    position: relative;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.3);
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    transition: all 0.3s ease;
}

.powerup-icon.inactive {
    opacity: 0.3;
    transform: scale(0.9);
}

.powerup-icon.active {
    opacity: 1;
    transform: scale(1.1);
    box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
}

.powerup-symbol {
    font-size: 24px;
    z-index: 2;
    position: relative;
    filter: drop-shadow(0 0 5px rgba(0, 0, 0, 0.8));
}

.powerup-fill {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 0%;
    background: linear-gradient(to top, 
        rgba(76, 175, 80, 0.8) 0%,
        rgba(76, 175, 80, 0.6) 50%,
        rgba(76, 175, 80, 0.4) 100%
    );
    transition: height 0.1s ease-out;
    border-radius: 50%;
}

/* Specific colors for each power-up */
#shieldIcon .powerup-fill {
    background: linear-gradient(to top, 
        rgba(0, 170, 255, 0.8) 0%,
        rgba(0, 170, 255, 0.6) 50%,
        rgba(0, 170, 255, 0.4) 100%
    );
}

#shieldIcon.active {
    border-color: rgba(0, 170, 255, 0.8);
    box-shadow: 0 0 20px rgba(0, 170, 255, 0.6);
}

#multiplierIcon .powerup-fill {
    background: linear-gradient(to top, 
        rgba(255, 215, 0, 0.8) 0%,
        rgba(255, 215, 0, 0.6) 50%,
        rgba(255, 215, 0, 0.4) 100%
    );
}

#multiplierIcon.active {
    border-color: rgba(255, 215, 0, 0.8);
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
}

#magnetIcon .powerup-fill {
    background: linear-gradient(to top, 
        rgba(255, 100, 100, 0.8) 0%,
        rgba(100, 100, 255, 0.6) 50%,
        rgba(255, 100, 100, 0.4) 100%
    );
}

#magnetIcon.active {
    border-color: rgba(255, 100, 100, 0.8);
    box-shadow: 0 0 20px rgba(255, 100, 100, 0.6);
}

/* Character Ability Status */
.ability-icon {
    position: relative;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.3);
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    transition: all 0.3s ease;
}

.ability-icon.ready {
    opacity: 1;
    transform: scale(1.1);
    border-color: rgba(255, 69, 0, 0.8);
    box-shadow: 0 0 20px rgba(255, 69, 0, 0.6);
}

.ability-icon.cooldown {
    opacity: 0.3;
    transform: scale(0.9);
}

.ability-symbol {
    font-size: 24px;
    z-index: 2;
    position: relative;
    filter: drop-shadow(0 0 5px rgba(0, 0, 0, 0.8));
}

.ability-fill {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 0%;
    background: linear-gradient(to top, 
        rgba(255, 69, 0, 0.8) 0%,
        rgba(255, 140, 0, 0.6) 50%,
        rgba(255, 215, 0, 0.4) 100%
    );
    transition: height 0.1s ease-out;
    border-radius: 50%;
}





/* Screen Management */
.screen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    opacity: 0;
    transform: translateY(50px);
    transition: all 0.5s ease;
    pointer-events: none;
}

.screen.active {
    opacity: 1;
    transform: translateY(0);
    pointer-events: all;
}

/* Title Screen */
.title-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
    text-align: center;
    background: linear-gradient(135deg, #0f1419 0%, #1a2332 50%, #0d1117 100%);
}

.game-title {
    font-size: 6rem;
    font-weight: bold;
    margin-bottom: 1rem;
    text-shadow: 0 0 30px rgba(79, 172, 254, 0.6), 0 0 60px rgba(79, 172, 254, 0.3);
}

.title-letter {
    display: inline-block;
    animation: titleFloat 3s ease-in-out infinite;
    animation-delay: calc(var(--i) * 0.2s);
}

.title-letter:nth-child(1) { --i: 0; color: #4facfe; }  /* D */
.title-letter:nth-child(2) { --i: 1; color: #00f2fe; }  /* a */
.title-letter:nth-child(3) { --i: 2; color: #43cbff; }  /* s */
.title-letter:nth-child(4) { --i: 3; color: #9708cc; }  /* h */
.title-letter:nth-child(5) { --i: 4; color: #43cbff; }  /* (space) */
.title-letter:nth-child(6) { --i: 0; color: #ffffff; }  /* B - restart pattern */
.title-letter:nth-child(7) { --i: 0; color: #ffffff; }  /* l */
.title-letter:nth-child(8) { --i: 0; color: #ffffff; }  /* i */
.title-letter:nth-child(9) { --i: 0; color: #ffffff; }  /* t */
.title-letter:nth-child(10) { --i: 0; color: #ffffff; } /* Z */

@keyframes titleFloat {
    0%, 100% { transform: translateY(0px); }
    50% { transform: translateY(-20px); }
}

.title-subtitle {
    font-family: 'Exo 2', 'Arial', sans-serif;
    font-size: 1.5rem;
    margin-bottom: 3rem;
    opacity: 0.8;
    color: #e6edf3;
}

.start-button {
    padding: 1rem 3rem;
    font-size: 1.2rem;
    font-weight: bold;
    background: linear-gradient(135deg, #1e3a8a, #3730a3, #1e40af);
    border: 2px solid rgba(79, 172, 254, 0.3);
    border-radius: 50px;
    color: #e6edf3;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 10px 30px rgba(30, 58, 138, 0.4), 0 0 20px rgba(79, 172, 254, 0.2);
    backdrop-filter: blur(10px);
}

.start-button:hover {
    transform: translateY(-5px);
    box-shadow: 0 20px 40px rgba(30, 58, 138, 0.6), 0 0 30px rgba(79, 172, 254, 0.4);
    border-color: rgba(79, 172, 254, 0.6);
    background: linear-gradient(135deg, #1e40af, #3730a3, #1d4ed8);
}

/* Authentication Container */
.auth-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1.5rem;
    width: 100%;
    max-width: 400px;
}

.auth-divider {
    display: flex;
    align-items: center;
    width: 100%;
    gap: 1rem;
    opacity: 0.7;
}

.divider-line {
    flex: 1;
    height: 1px;
    background: linear-gradient(90deg, transparent, rgba(79, 172, 254, 0.3), transparent);
}

.divider-text {
    color: #b3c7e6;
    font-size: 0.9rem;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 1px;
}

/* Google Sign-In Button */
.google-signin-button {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 1rem 2rem;
    background: rgba(15, 20, 25, 0.8);
    border: 2px solid rgba(79, 172, 254, 0.3);
    border-radius: 50px;
    color: #e6edf3;
    font-size: 1.1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(15px);
    box-shadow: 0 8px 25px rgba(15, 20, 25, 0.6);
    min-width: 280px;
    justify-content: center;
}

.google-signin-button:hover {
    transform: translateY(-3px);
    border-color: rgba(79, 172, 254, 0.5);
    box-shadow: 0 12px 35px rgba(15, 20, 25, 0.8), 0 0 20px rgba(79, 172, 254, 0.2);
    background: rgba(15, 20, 25, 0.9);
}

.google-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 24px;
    height: 24px;
    background: white;
    border-radius: 4px;
    padding: 2px;
}

.google-text {
    font-family: 'Exo 2', sans-serif;
    letter-spacing: 0.5px;
}

/* Google Sign-In Container */
.google-signin-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
}

.google-benefit-text {
    font-size: 0.85rem;
    color: #b3c7e6;
    opacity: 0.8;
    font-style: italic;
    letter-spacing: 0.3px;
    text-align: center;
    font-weight: 400;
}

/* Authentication Status */
.auth-status {
    width: 100%;
    background: rgba(15, 20, 25, 0.6);
    border: 1px solid rgba(79, 172, 254, 0.3);
    border-radius: 15px;
    padding: 1.5rem;
    backdrop-filter: blur(20px);
    box-shadow: 0 8px 25px rgba(15, 20, 25, 0.6);
}

.user-info {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.user-avatar {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: linear-gradient(135deg, #43cbff, #00f2fe);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
    font-weight: bold;
    color: #0f1419;
    overflow: hidden;
}

.user-avatar img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.user-details {
    flex: 1;
}

.user-name {
    font-weight: bold;
    color: #43cbff;
    font-size: 1.1rem;
    margin-bottom: 0.3rem;
}

.user-email {
    color: #b3c7e6;
    font-size: 0.9rem;
    opacity: 0.8;
}

.sign-out-button {
    padding: 0.5rem 1rem;
    background: rgba(79, 172, 254, 0.1);
    border: 1px solid rgba(79, 172, 254, 0.3);
    border-radius: 20px;
    color: #43cbff;
    font-size: 0.9rem;
    cursor: pointer;
    transition: all 0.3s ease;
}

.sign-out-button:hover {
    background: rgba(79, 172, 254, 0.2);
    border-color: rgba(79, 172, 254, 0.5);
    transform: scale(1.05);
}

/* Loading States */
.google-signin-button.loading {
    opacity: 0.7;
    cursor: not-allowed;
    pointer-events: none;
}

.google-signin-button.loading .google-text::after {
    content: '...';
    animation: loadingDots 1.5s infinite;
}

@keyframes loadingDots {
    0%, 20% { content: '...'; }
    40% { content: ''; }
    60% { content: '.'; }
    80% { content: '..'; }
}

/* Mobile Responsive */
@media (max-width: 768px) {
    .game-title {
        font-size: 4rem;
    }
    
    .auth-container {
        max-width: 90%;
    }
    
    .google-signin-button {
        min-width: 250px;
        padding: 0.8rem 1.5rem;
        font-size: 1rem;
    }
    
    .google-benefit-text {
        font-size: 0.8rem;
        padding: 0 1rem;
    }
    
    .start-button {
        padding: 0.8rem 2rem;
        font-size: 1rem;
    }
    
    .user-info {
        flex-direction: column;
        text-align: center;
        gap: 1rem;
    }
    
    .user-details {
        text-align: center;
    }
}

/* ==================== MAIN MENU SYSTEM ====================*/
/* Glassmorphism Cards */
.menu-container {
    padding: 2rem;
    height: 100%;
}

.menu-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 3rem;
}

.menu-title {
    font-size: 2.5rem;
    font-weight: bold;
    color: #43cbff;
    text-shadow: 0 0 20px rgba(67, 203, 255, 0.4);
    font-family: 'Orbitron', 'Exo 2', sans-serif;
    letter-spacing: 1px;
}

.player-stats {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.coin-display {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    background: rgba(15, 20, 25, 0.6);
    padding: 0.5rem 1rem;
    border-radius: 25px;
    backdrop-filter: blur(20px);
    border: 1px solid rgba(79, 172, 254, 0.3);
    box-shadow: 0 4px 15px rgba(15, 20, 25, 0.5), inset 0 1px 0 rgba(79, 172, 254, 0.1);
    color: #e6edf3;
    font-weight: bold;
}

.coin-icon {
    font-size: 1.2rem;
}

.menu-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 2rem;
    max-width: 800px;
    margin: 0 auto;
}

.menu-card {
    background: rgba(15, 20, 25, 0.4);
    backdrop-filter: blur(25px);
    border: 1px solid rgba(79, 172, 254, 0.2);
    border-radius: 20px;
    padding: 2.5rem 2rem;
    text-align: center;
    cursor: pointer;
    transition: all 0.4s ease;
    box-shadow: 0 10px 30px rgba(15, 20, 25, 0.6), inset 0 1px 0 rgba(79, 172, 254, 0.1);
    position: relative;
    overflow: hidden;
}

.menu-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(67, 203, 255, 0.1), transparent);
    transition: all 0.6s ease;
}

.menu-card:hover::before {
    left: 100%;
}

.menu-card:hover {
    transform: translateY(-12px) scale(1.02);
    background: rgba(15, 20, 25, 0.6);
    border-color: rgba(79, 172, 254, 0.5);
    box-shadow: 0 25px 60px rgba(15, 20, 25, 0.8), 0 0 30px rgba(79, 172, 254, 0.3);
}

.card-icon {
    display: none; /* Hide emojis for cleaner look */
}

.card-title {
    font-family: 'Orbitron', 'Exo 2', sans-serif;
    font-size: 2.2rem;
    font-weight: 900;
    margin-bottom: 0.8rem;
    color: #e6edf3;
    text-shadow: 0 0 20px rgba(67, 203, 255, 0.4), 0 2px 4px rgba(0, 0, 0, 0.8);
    letter-spacing: 3px;
    text-transform: uppercase;
}

.card-subtitle {
    opacity: 0.9;
    font-size: 1rem;
    color: #b3c7e6;
    font-weight: 500;
    letter-spacing: 0.5px;
}

.menu-card:hover .card-subtitle {
    color: #43cbff;
    opacity: 1;
}

/* Individual Button Themes */
.run-card .card-title {
    color: #00f2fe;
}

.run-card:hover {
    border-color: rgba(0, 242, 254, 0.6);
    box-shadow: 0 25px 60px rgba(15, 20, 25, 0.8), 0 0 30px rgba(0, 242, 254, 0.4);
}

.characters-card .card-title {
    color: #43cbff;
}

.characters-card:hover {
    border-color: rgba(67, 203, 255, 0.6);
    box-shadow: 0 25px 60px rgba(15, 20, 25, 0.8), 0 0 30px rgba(67, 203, 255, 0.4);
}

.shop-card .card-title {
    color: #1e40af;
}

.shop-card:hover {
    border-color: rgba(30, 64, 175, 0.6);
    box-shadow: 0 25px 60px rgba(15, 20, 25, 0.8), 0 0 30px rgba(30, 64, 175, 0.4);
}

.settings-card .card-title {
    color: #7c3aed;
}

.settings-card:hover {
    border-color: rgba(124, 58, 237, 0.6);
    box-shadow: 0 25px 60px rgba(15, 20, 25, 0.8), 0 0 30px rgba(124, 58, 237, 0.4);
}

/* Daily Challenges Button */
.daily-challenges-button-container {
    display: flex;
    justify-content: center;
    margin-bottom: 2rem;
}

.daily-challenges-btn {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 1rem 2rem;
    background: rgba(15, 20, 25, 0.5);
    backdrop-filter: blur(25px);
    border: 1px solid rgba(79, 172, 254, 0.3);
    border-radius: 50px;
    color: #e6edf3;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 8px 25px rgba(15, 20, 25, 0.6), inset 0 1px 0 rgba(79, 172, 254, 0.1);
    position: relative;
    max-width: 400px;
    width: 100%;
}

.daily-challenges-btn:hover {
    background: rgba(15, 20, 25, 0.7);
    border-color: rgba(79, 172, 254, 0.5);
    transform: translateY(-3px);
    box-shadow: 0 12px 35px rgba(15, 20, 25, 0.8), 0 0 20px rgba(79, 172, 254, 0.3);
}

.challenges-btn-icon {
    font-size: 2rem;
    min-width: 50px;
    text-align: center;
    animation: challengeGlow 2s ease-in-out infinite alternate;
}

@keyframes challengeGlow {
    0% { text-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
    100% { text-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 30px rgba(255, 215, 0, 0.3); }
}

.challenges-btn-content {
    flex: 1;
    text-align: left;
}

.challenges-btn-title {
    font-size: 1.2rem;
    font-weight: bold;
    color: #43cbff;
    margin-bottom: 0.3rem;
}

.challenges-btn-subtitle {
    font-size: 0.9rem;
    color: #b3c7e6;
    opacity: 0.8;
}

.challenges-btn-badge {
    background: linear-gradient(135deg, #43cbff, #00f2fe);
    color: #0f1419;
    padding: 0.4rem 0.8rem;
    border-radius: 20px;
    font-weight: bold;
    font-size: 0.9rem;
    box-shadow: 0 0 10px rgba(67, 203, 255, 0.3);
}

/* Mobile Responsive */
@media (max-width: 768px) {
    .menu-grid {
        grid-template-columns: 1fr;
        gap: 1rem;
    }
    
    .daily-challenges-btn {
        flex-direction: column;
        text-align: center;
        gap: 0.8rem;
        padding: 1rem 1.5rem;
    }
    
    .challenges-btn-content {
        text-align: center;
    }
}


/* Main Menu Screen - Transparent background to show particles */
#main-menu {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: none;
    flex-direction: column;
    z-index: 3;
    background: none;
    pointer-events: none; /* Allow particles to show through */
}

/* Make sure interactive elements still work */
#main-menu .menu-container {
    pointer-events: auto;
}

#main-menu.active {
    display: flex;
}

#main-menu.active {
    display: flex;
}

/* Menu container with proper spacing */
.menu-container {
    padding: 2rem;
    height: 100%;
    display: flex;
    flex-direction: column;
}

/* Force particle canvas to always be visible behind menu content */
#particle-canvas {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100% !important;
    height: 100% !important;
    pointer-events: none !important;
    z-index: 1 !important; /* Behind menu content but above background */
    display: block !important;
    opacity: 1 !important;
    visibility: visible !important;
}

/* Ensure particles show on main menu */
#main-menu.active ~ #particle-canvas {
    display: block !important;
    visibility: visible !important;
    opacity: 1 !important;
}

/* Remove the overlay that might be blocking particles */
#main-menu::before {
    display: none;
}

/* Add background directly to main menu */
#main-menu {
    background: linear-gradient(135deg, rgba(15, 20, 25, 0.4) 0%, rgba(26, 35, 50, 0.4) 50%, rgba(13, 17, 23, 0.4) 100%);
}

/* Make sure main menu content is properly layered */
#main-menu .menu-header,
#main-menu .daily-challenges-button-container, 
#main-menu .menu-grid {
    position: relative;
    z-index: 2;
}

/* Ensure particles are above everything */
#particle-canvas {
    z-index: 999 !important;
}



/* Force particle canvas to always be visible and on top */
#particle-canvas {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100% !important;
    height: 100% !important;
    pointer-events: none !important;
    z-index: 5 !important;
    display: block !important;
    opacity: 1 !important;
    visibility: visible !important;
}

/* Ensure particle canvas stays on top in main menu */
#main-menu.active ~ #particle-canvas,
#titleScreen.active ~ #particle-canvas {
    z-index: 1 !important;
    display: block !important;
    position: fixed !important;
}

.settings-card {
    position: relative;
    overflow: hidden;
}

.settings-card::after {
    content: '⚙️';
    position: absolute;
    font-size: 8rem;
    opacity: 0.05;
    right: -20px;
    bottom: -20px;
    transform: rotate(0deg);
    transition: transform 0.8s ease;
}

.settings-card:hover::after {
    transform: rotate(180deg);
}

#settings {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: none;
    flex-direction: column;
    background: linear-gradient(135deg, #0f1419 0%, #1a2332 50%, #0d1117 100%);
    z-index: 200;
}

#settings.active {
    display: flex !important;
}

#settings .screen-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1rem 2rem;
    background: rgba(15, 20, 25, 0.8);
    backdrop-filter: blur(15px);
    border-bottom: 1px solid rgba(79, 172, 254, 0.2);
}

#settings .settings-content {
    padding: 2rem;
    overflow-y: auto;
    flex: 1;
}

/* Import fonts if not already imported */
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Exo+2:wght@300;400;500;600;700&display=swap');

/* Screen system from menu */
.screen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    opacity: 0;
    transform: translateY(50px);
    transition: all 0.5s ease;
    pointer-events: none;
}

.screen.active {
    opacity: 1;
    transform: translateY(0);
    pointer-events: all;
}

/* Settings specific styling */
#settings {
    background: linear-gradient(135deg, #0f1419 0%, #1a2332 50%, #0d1117 100%);
    z-index: 200;
}

.screen-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1rem 2rem;
    background: rgba(15, 20, 25, 0.8);
    backdrop-filter: blur(15px);
    border-bottom: 1px solid rgba(79, 172, 254, 0.2);
}

.back-button {
    background: rgba(15, 20, 25, 0.6);
    border: 1px solid rgba(79, 172, 254, 0.3);
    border-radius: 50%;
    width: 50px;
    height: 50px;
    color: #e6edf3;
    font-size: 1.5rem;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    box-shadow: 0 4px 15px rgba(15, 20, 25, 0.5);
}

.back-button:hover {
    background: rgba(15, 20, 25, 0.8);
    border-color: rgba(79, 172, 254, 0.5);
    transform: scale(1.1);
    box-shadow: 0 6px 20px rgba(15, 20, 25, 0.7), 0 0 15px rgba(79, 172, 254, 0.2);
}

.screen-header h2 {
    color: #43cbff;
    font-family: 'Orbitron', 'Exo 2', sans-serif;
    font-size: 2rem;
    text-shadow: 0 0 20px rgba(67, 203, 255, 0.4);
    margin: 0;
}

.spacer {
    width: 50px;
}

.settings-content {
    padding: 2rem;
    overflow-y: auto;
    flex: 1;
}

.setting-group {
    background: rgba(15, 20, 25, 0.5);
    backdrop-filter: blur(25px);
    border: 1px solid rgba(79, 172, 254, 0.2);
    border-radius: 15px;
    padding: 2rem;
    margin-bottom: 2rem;
    box-shadow: 0 8px 25px rgba(15, 20, 25, 0.6), inset 0 1px 0 rgba(79, 172, 254, 0.1);
}

.setting-group h3 {
    margin-bottom: 1.5rem;
    color: #43cbff;
    font-family: 'Exo 2', sans-serif;
    text-align: center;
    font-size: 1.3rem;
    margin-top: 0;
}

.setting-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    color: #e6edf3;
}

.setting-item label {
    color: #e6edf3;
    font-family: 'Exo 2', sans-serif;
}

.setting-item input[type="range"] {
    width: 200px;
}

/* Save & Sync buttons */
.save-options {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.save-btn {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 1.2rem;
    background: rgba(15, 20, 25, 0.6);
    border: 1px solid rgba(79, 172, 254, 0.3);
    border-radius: 15px;
    color: #e6edf3;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(15px);
    text-align: left;
    width: 100%;
}

.save-btn:hover {
    background: rgba(15, 20, 25, 0.8);
    border-color: rgba(79, 172, 254, 0.5);
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(15, 20, 25, 0.7), 0 0 15px rgba(79, 172, 254, 0.2);
}

.save-btn.primary {
    border-color: rgba(67, 203, 255, 0.4);
}

.save-btn.primary:hover {
    border-color: rgba(67, 203, 255, 0.6);
    box-shadow: 0 6px 20px rgba(15, 20, 25, 0.7), 0 0 15px rgba(67, 203, 255, 0.3);
}

.save-btn.secondary {
    border-color: rgba(0, 242, 254, 0.4);
}

.save-btn.secondary:hover {
    border-color: rgba(0, 242, 254, 0.6);
    box-shadow: 0 6px 20px rgba(15, 20, 25, 0.7), 0 0 15px rgba(0, 242, 254, 0.3);
}

.save-btn-icon {
    font-size: 2rem;
    min-width: 50px;
    text-align: center;
}

.save-btn-content {
    flex: 1;
}

.save-btn-title {
    font-size: 1.1rem;
    font-weight: bold;
    color: #43cbff;
    margin-bottom: 0.3rem;
    font-family: 'Exo 2', sans-serif;
}

.save-btn-subtitle {
    font-size: 0.9rem;
    color: #b3c7e6;
    opacity: 0.8;
    font-family: 'Exo 2', sans-serif;
}

/* Jukebox controls */
.jukebox-controls {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
}

.jukebox-btn {
    padding: 0.8rem 1.5rem;
    background: rgba(15, 20, 25, 0.6);
    border: 1px solid rgba(79, 172, 254, 0.3);
    border-radius: 25px;
    color: #e6edf3;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(15px);
    font-family: 'Exo 2', sans-serif;
}

.jukebox-btn:hover {
    background: rgba(15, 20, 25, 0.8);
    border-color: rgba(79, 172, 254, 0.5);
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(15, 20, 25, 0.5), 0 0 10px rgba(79, 172, 254, 0.2);
}

/* Character & World Selection Screens - Glassmorphism Style */
.selection-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    height: calc(100% - 80px);
    padding: 1rem 2rem;
    overflow-y: auto;
}

.preview-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2rem;
    width: 100%;
    max-width: 800px;
}

.preview-box {
    width: 400px;
    height: 400px;
    background: rgba(15, 20, 25, 0.5);
    backdrop-filter: blur(25px);
    border: 1px solid rgba(79, 172, 254, 0.3);
    border-radius: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    box-shadow: 0 15px 35px rgba(15, 20, 25, 0.6), inset 0 1px 0 rgba(79, 172, 254, 0.1);
    overflow: hidden;
}

.preview-box.world-preview {
    width: 500px;
    height: 300px;
}

.preview-box::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle, rgba(67, 203, 255, 0.1) 0%, transparent 70%);
    animation: rotateGlow 15s linear infinite;
}

@keyframes rotateGlow {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.preview-controls {
    display: flex;
    align-items: center;
    gap: 2rem;
    width: 100%;
    justify-content: center;
}

.nav-button {
    width: 60px;
    height: 60px;
    background: rgba(15, 20, 25, 0.6);
    backdrop-filter: blur(15px);
    border: 1px solid rgba(79, 172, 254, 0.3);
    border-radius: 50%;
    color: #43cbff;
    font-size: 24px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 8px 25px rgba(15, 20, 25, 0.6);
}

.nav-button:hover {
    background: rgba(15, 20, 25, 0.8);
    border-color: rgba(79, 172, 254, 0.5);
    transform: scale(1.1);
    box-shadow: 0 12px 35px rgba(15, 20, 25, 0.8), 0 0 20px rgba(79, 172, 254, 0.3);
}

.nav-button span {
    display: block;
    transition: transform 0.3s ease;
}

.nav-button:hover span {
    transform: scale(1.2);
}

.character-info-card, .world-info-card {
    background: rgba(15, 20, 25, 0.6);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(79, 172, 254, 0.2);
    border-radius: 15px;
    padding: 2rem 3rem;
    text-align: center;
    min-width: 300px;
    box-shadow: 0 10px 30px rgba(15, 20, 25, 0.6), inset 0 1px 0 rgba(79, 172, 254, 0.1);
}

.character-info-card h3, .world-info-card h3 {
    color: #43cbff;
    font-size: 2rem;
    margin-bottom: 0.5rem;
    font-family: 'Orbitron', 'Exo 2', sans-serif;
    text-shadow: 0 0 20px rgba(67, 203, 255, 0.4);
    letter-spacing: 1px;
}

.character-subtitle, .world-subtitle {
    color: #b3c7e6;
    font-size: 1.1rem;
    margin-bottom: 1rem;
    opacity: 0.9;
    font-family: 'Exo 2', sans-serif;
}

.unlock-status {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    padding: 0.8rem 1.5rem;
    background: rgba(15, 20, 25, 0.4);
    border-radius: 25px;
    margin-top: 1rem;
    border: 1px solid rgba(79, 172, 254, 0.2);
}

.unlock-status.unlocked {
    background: rgba(52, 199, 89, 0.2);
    border-color: rgba(52, 199, 89, 0.4);
}

.unlock-status.locked {
    background: rgba(255, 87, 34, 0.2);
    border-color: rgba(255, 87, 34, 0.4);
}

.status-icon {
    font-size: 1.2rem;
}

.status-text {
    color: #e6edf3;
    font-weight: 600;
    font-family: 'Exo 2', sans-serif;
}

.action-button {
    padding: 1.2rem 3rem;
    background: rgba(15, 20, 25, 0.7);
    backdrop-filter: blur(20px);
    border: 2px solid rgba(79, 172, 254, 0.3);
    border-radius: 50px;
    color: #e6edf3;
    font-size: 1.3rem;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
    margin-top: 2rem;
    font-family: 'Exo 2', sans-serif;
    letter-spacing: 1px;
    text-transform: uppercase;
    box-shadow: 0 10px 30px rgba(15, 20, 25, 0.6);
}

.action-button.primary {
    background: linear-gradient(135deg, rgba(30, 58, 138, 0.8), rgba(55, 48, 163, 0.8), rgba(30, 64, 175, 0.8));
    border-color: rgba(79, 172, 254, 0.5);
}

.action-button:hover {
    transform: translateY(-3px);
    box-shadow: 0 20px 40px rgba(15, 20, 25, 0.8), 0 0 30px rgba(79, 172, 254, 0.4);
    border-color: rgba(79, 172, 254, 0.7);
}

.action-button.primary:hover {
    background: linear-gradient(135deg, rgba(30, 64, 175, 0.9), rgba(55, 48, 163, 0.9), rgba(29, 78, 216, 0.9));
}

.button-glow {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 300%;
    height: 300%;
    background: radial-gradient(circle, rgba(67, 203, 255, 0.2) 0%, transparent 70%);
    transform: translate(-50%, -50%);
    opacity: 0;
    transition: opacity 0.3s ease;
}

.action-button:hover .button-glow {
    opacity: 1;
    animation: pulseGlow 2s ease-in-out infinite;
}

@keyframes pulseGlow {
    0%, 100% { transform: translate(-50%, -50%) scale(1); }
    50% { transform: translate(-50%, -50%) scale(1.1); }
}

.button-text {
    position: relative;
    z-index: 1;
}

/* Mobile Responsive Adjustments */
@media (max-width: 768px) {
    .preview-box {
        width: 300px;
        height: 300px;
    }
    
    .preview-box.world-preview {
        width: 350px;
        height: 250px;
    }
    
    .preview-controls {
        flex-wrap: wrap;
        gap: 1rem;
    }
    
    .character-info-card, .world-info-card {
        min-width: 250px;
        padding: 1.5rem 2rem;
    }
    
    .nav-button {
        width: 50px;
        height: 50px;
        font-size: 20px;
    }
    
    .action-button {
        font-size: 1.1rem;
        padding: 1rem 2rem;
    }
}

/* Animations for screen transitions */
#characterSelectScreen.active, #worldSelectScreen.active {
    animation: fadeInUp 0.5s ease-out;
}

@keyframes fadeInUp {
    0% {
        opacity: 0;
        transform: translateY(30px);
    }
    100% {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Ensure screens have proper backgrounds */
#characterSelectScreen, #worldSelectScreen {
    background: linear-gradient(135deg, #0f1419 0%, #1a2332 50%, #0d1117 100%);
    z-index: 200;
}

/* Hide canvas during character/world select */
#characterSelectScreen.active ~ canvas,
#worldSelectScreen.active ~ canvas {
    display: block !important;
}

/* Responsive preview boxes */
@media (max-width: 768px) {
    #characterDisplay canvas {
        width: 300px !important;
        height: 300px !important;
    }
    
    #worldPreview canvas {
        width: 350px !important;
        height: 250px !important;
    }
}

.action-buttons-container {
    display: flex;
    gap: 1rem;
    margin-top: 1rem;
    flex-wrap: wrap;
    justify-content: center;
    width: 100%;
    padding: 0 2rem;
}

.action-button.secondary {
    background: linear-gradient(135deg, rgba(67, 203, 255, 0.2), rgba(0, 242, 254, 0.2));
    border-color: rgba(67, 203, 255, 0.5);
}

.action-button.secondary:hover {
    background: linear-gradient(135deg, rgba(67, 203, 255, 0.3), rgba(0, 242, 254, 0.3));
    border-color: rgba(67, 203, 255, 0.7);
}

/* Visual feedback for selected character */
.character-selected-indicator {
    position: absolute;
    top: 1rem;
    right: 1rem;
    background: linear-gradient(135deg, #34C759, #32D74B);
    color: white;
    padding: 0.5rem 1rem;
    border-radius: 20px;
    font-weight: bold;
    font-size: 0.9rem;
    display: none;
    animation: fadeInScale 0.3s ease;
}

@keyframes fadeInScale {
    0% {
        opacity: 0;
        transform: scale(0.8);
    }
    100% {
        opacity: 1;
        transform: scale(1);
    }
}

.action-button.selected {
    background: linear-gradient(135deg, rgba(52, 199, 89, 0.3), rgba(50, 215, 75, 0.3)) !important;
    border-color: rgba(52, 199, 89, 0.6) !important;
}

.action-button.selected:hover {
    background: linear-gradient(135deg, rgba(52, 199, 89, 0.4), rgba(50, 215, 75, 0.4)) !important;
    border-color: rgba(52, 199, 89, 0.8) !important;
}

/* Debug - force particle canvas to front */
#particle-canvas {
    z-index: 9999 !important;
}

/* Daily Challenges Modal */
.challenges-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(15, 20, 25, 0.9);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
    opacity: 0;
    pointer-events: none;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
}

.challenges-modal.active {
    opacity: 1;
    pointer-events: all;
}

.challenges-modal-content {
    background: rgba(15, 20, 25, 0.95);
    border: 2px solid rgba(79, 172, 254, 0.4);
    border-radius: 20px;
    width: 90%;
    max-width: 600px;
    max-height: 80vh;
    overflow: hidden;
    backdrop-filter: blur(30px);
    box-shadow: 0 20px 60px rgba(15, 20, 25, 0.8), 0 0 30px rgba(79, 172, 254, 0.2);
    transform: translateY(50px);
    transition: all 0.3s ease;
}

.challenges-modal.active .challenges-modal-content {
    transform: translateY(0);
}

.challenges-modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1.5rem 2rem;
    border-bottom: 1px solid rgba(79, 172, 254, 0.2);
}

.challenges-modal-header h2 {
    color: #43cbff;
    font-size: 1.8rem;
    margin: 0;
    text-shadow: 0 0 15px rgba(67, 203, 255, 0.3);
}

.close-challenges-btn {
    background: none;
    border: none;
    color: #e6edf3;
    font-size: 2rem;
    cursor: pointer;
    transition: all 0.3s ease;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
}

.close-challenges-btn:hover {
    background: rgba(79, 172, 254, 0.2);
    color: #43cbff;
    transform: scale(1.1);
}

.challenges-modal-body {
    padding: 1.5rem 2rem;
    max-height: 50vh;
    overflow-y: auto;
}

.challenges-subtitle {
    text-align: center;
    color: #b3c7e6;
    margin-bottom: 1.5rem;
    font-style: italic;
}

.challenges-modal-footer {
    padding: 1rem 2rem;
    border-top: 1px solid rgba(79, 172, 254, 0.2);
    background: rgba(15, 20, 25, 0.5);
}

.challenges-reset-info {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    color: #b3c7e6;
    font-size: 0.9rem;
    opacity: 0.8;
}

.reset-icon {
    animation: resetSpin 3s linear infinite;
}

@keyframes resetSpin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.challenge-item {
    background: rgba(15, 20, 25, 0.4);
    border: 1px solid rgba(79, 172, 254, 0.15);
    border-radius: 10px;
    padding: 1rem;
    margin-bottom: 1rem;
    transition: all 0.3s ease;
    backdrop-filter: blur(15px);
}

.challenge-item:hover {
    background: rgba(15, 20, 25, 0.6);
    border-color: rgba(79, 172, 254, 0.3);
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(15, 20, 25, 0.5);
    cursor: pointer;
}

.challenge-item.completed {
    border-color: #43cbff;
    background: rgba(67, 203, 255, 0.1);
    box-shadow: 0 0 15px rgba(67, 203, 255, 0.2);
}

.challenge-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
}

.challenge-title {
    font-weight: bold;
    color: #43cbff;
}

.challenge-reward {
    background: linear-gradient(135deg, #1e40af, #3730a3);
    color: #e6edf3;
    padding: 0.2rem 0.6rem;
    border-radius: 15px;
    font-size: 0.9rem;
    font-weight: bold;
    border: 1px solid rgba(79, 172, 254, 0.3);
}

.challenge-description {
    margin-bottom: 0.8rem;
    opacity: 0.9;
    color: #e6edf3;
}

.challenge-progress {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.progress-bar {
    flex: 1;
    height: 8px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 4px;
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #43cbff, #1e40af);
    border-radius: 4px;
    transition: width 0.5s ease;
    box-shadow: 0 0 10px rgba(67, 203, 255, 0.3);
}

.progress-text {
    font-size: 0.9rem;
    font-weight: bold;
    color: #43cbff;
    min-width: 60px;
    text-align: right;
}

.challenge-complete-badge {
    margin-top: 0.5rem;
    background: linear-gradient(135deg, #43cbff, #00f2fe);
    color: #0f1419;
    padding: 0.3rem 0.8rem;
    border-radius: 15px;
    font-size: 0.8rem;
    font-weight: bold;
    text-align: center;
    box-shadow: 0 0 10px rgba(67, 203, 255, 0.3);
}

/* Challenge Complete Notification */
.challenge-complete-notification {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) translateY(50px);
    background: linear-gradient(135deg, rgba(15, 20, 25, 0.9), rgba(67, 203, 255, 0.2));
    border: 2px solid rgba(67, 203, 255, 0.4);
    border-radius: 20px;
    padding: 2rem;
    box-shadow: 0 20px 60px rgba(15, 20, 25, 0.8), 0 0 30px rgba(67, 203, 255, 0.3);
    backdrop-filter: blur(30px);
    z-index: 2000;
    opacity: 0;
    transition: all 0.5s ease;
    text-align: center;
    min-width: 350px;
}

.challenge-complete-notification.show {
    opacity: 1;
    transform: translate(-50%, -50%) translateY(0);
}

.challenge-complete-content {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.challenge-complete-icon {
    font-size: 3rem;
    animation: challengePulse 1s ease-in-out infinite alternate;
}

@keyframes challengePulse {
    0% { transform: scale(1) rotate(0deg); }
    100% { transform: scale(1.2) rotate(5deg); }
}

.challenge-complete-title {
    font-size: 1.3rem;
    font-weight: bold;
    color: #43cbff;
    margin-bottom: 0.5rem;
    text-shadow: 0 0 15px rgba(67, 203, 255, 0.5);
}

.challenge-complete-name {
    font-size: 1rem;
    color: #e6edf3;
    margin-bottom: 0.5rem;
}

.challenge-complete-reward {
    font-size: 1.1rem;
    font-weight: bold;
    color: #00f2fe;
    text-shadow: 0 0 10px rgba(0, 242, 254, 0.4);
}

/* Challenge completion animation */
@keyframes challengeComplete {
    0% { box-shadow: 0 0 10px rgba(0, 242, 254, 0.5); }
    100% { box-shadow: 0 0 20px rgba(0, 242, 254, 0.8), 0 0 30px rgba(0, 242, 254, 0.3); }
}

#startGameButton {
    display: none !important;
}

#characterSelectScreen {
    overflow: hidden; /* Remove scroll bars */
}

/* Remove scroll bars from character select screen */
#characterSelectScreen {
    overflow: hidden;
    height: 100vh; /* Ensure it fills the viewport */
    display: flex;
    flex-direction: column;
}

/* Adjust spacing between preview and buttons */
#characterSelectScreen .selection-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    padding: 2rem;
    gap: 2rem; /* Reduce this to bring buttons closer */
}

/* Move action buttons closer to the character preview */
#characterSelectScreen .action-buttons-container {
    margin-top: 0; /* Remove any extra top margin */
    padding-top: 1rem; /* Small padding for visual balance */
}

/* Ensure no scroll on body when character select is open */
body:has(#characterSelectScreen.active) {
    overflow: hidden;
}

/* Reset and fix viewport */
* {
    box-sizing: border-box;
}

html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    position: fixed;
}

/* Character select specific fixes */
#characterSelectScreen {
    position: fixed !important;
    inset: 0 !important; /* top: 0, right: 0, bottom: 0, left: 0 */
    width: 100vw !important;
    height: 100vh !important;
    overflow: hidden !important;
    display: flex;
    flex-direction: column;
}

#characterSelectScreen .screen-header {
    flex: 0 0 auto;
    height: 60px; /* Set fixed height */
}

#characterSelectScreen .selection-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    position: relative;
    padding: 2rem 1rem 8rem 1rem; /* Extra bottom padding for buttons */
}

#characterSelectScreen .preview-area {
    margin-bottom: 3rem;
}

#characterSelectScreen .action-buttons-container {
    position: absolute;
    bottom: 5rem; /* Move buttons up from bottom */
    left: 50%;
    transform: translateX(-50%);
}

/* World Select Screen Only */
#worldSelectScreen .selection-container {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 2rem;
}

#worldSelectScreen .preview-area {
    margin-bottom: 2rem; /* Adjust this value to move button up/down */
}

#worldSelectScreen #startGameFromWorldButton {
    /* Remove any absolute positioning */
    position: static !important;
    transform: none !important;
    margin: 0 auto;
    display: block;
}

/* Add this to your existing CSS for a breathing effect */
#worldSelectScreen .preview-area:hover {
    animation: breathe 2s ease-in-out infinite;
}

@keyframes breathe {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

#mainMenuModPassword:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* ==================== PAUSE SCREEN STYLING ==================== */
#pauseScreen {
    background: linear-gradient(135deg, rgba(15, 20, 25, 0.95) 0%, rgba(26, 35, 50, 0.95) 50%, rgba(13, 17, 23, 0.95) 100%);
    backdrop-filter: blur(20px);
}

#pauseScreen h2 {
    font-family: 'Orbitron', 'Exo 2', sans-serif;
    color: #43cbff;
    font-size: 3rem;
    text-shadow: 0 0 30px rgba(67, 203, 255, 0.5), 0 2px 4px rgba(0, 0, 0, 0.8);
    margin-bottom: 1rem;
    letter-spacing: 3px;
    text-transform: uppercase;
}

#pauseScreen p {
    color: #b3c7e6;
    font-family: 'Exo 2', sans-serif;
    font-size: 1.2rem;
    margin-bottom: 2rem;
    opacity: 0.9;
}

/* Glassmorphism game buttons */
#pauseScreen .game-button {
    background: rgba(15, 20, 25, 0.5);
    backdrop-filter: blur(25px);
    border: 1px solid rgba(79, 172, 254, 0.3);
    color: #e6edf3;
    font-family: 'Exo 2', sans-serif;
    font-weight: 600;
    font-size: 1.1rem;
    padding: 1rem 2rem;
    border-radius: 15px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 8px 25px rgba(15, 20, 25, 0.6), inset 0 1px 0 rgba(79, 172, 254, 0.1);
    letter-spacing: 1px;
    text-transform: uppercase;
}

#pauseScreen .game-button:hover {
    background: rgba(15, 20, 25, 0.7);
    border-color: rgba(79, 172, 254, 0.5);
    transform: translateY(-3px);
    box-shadow: 0 12px 35px rgba(15, 20, 25, 0.8), 0 0 20px rgba(79, 172, 254, 0.3);
}

/* Specific button colors */
#resumeButton {
    border-color: rgba(0, 242, 254, 0.4);
}
#resumeButton:hover {
    border-color: rgba(0, 242, 254, 0.6);
    box-shadow: 0 12px 35px rgba(15, 20, 25, 0.8), 0 0 20px rgba(0, 242, 254, 0.3);
}

#pauseMainMenuBtn {
    border-color: rgba(124, 58, 237, 0.4);
}
#pauseMainMenuBtn:hover {
    border-color: rgba(124, 58, 237, 0.6);
    box-shadow: 0 12px 35px rgba(15, 20, 25, 0.8), 0 0 20px rgba(124, 58, 237, 0.3);
}

/* ==================== GAME OVER SCREEN STYLING ==================== */
#gameOver {
    background: linear-gradient(135deg, rgba(15, 20, 25, 0.95) 0%, rgba(26, 35, 50, 0.95) 50%, rgba(13, 17, 23, 0.95) 100%);
    backdrop-filter: blur(20px);
    padding: 3rem;
    border-radius: 20px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
}

#gameOver h2 {
    font-family: 'Orbitron', 'Exo 2', sans-serif;
    color: #ef4444;
    font-size: 3rem;
    text-shadow: 0 0 30px rgba(239, 68, 68, 0.5), 0 2px 4px rgba(0, 0, 0, 0.8);
    margin-bottom: 1.5rem;
    letter-spacing: 3px;
    text-transform: uppercase;
}

#finalScore {
    font-family: 'Orbitron', 'Exo 2', sans-serif;
    color: #43cbff;
    font-size: 2rem !important;
    text-shadow: 0 0 20px rgba(67, 203, 255, 0.4);
    margin-bottom: 0.5rem;
    display: block;
}

#coinsCollected {
    font-family: 'Exo 2', sans-serif;
    color: #ffd700;
    font-size: 1.5rem !important;
    text-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
    margin-bottom: 2rem !important;
}

/* New high score message */
#newHighScoreMessage {
    background: rgba(255, 215, 0, 0.1);
    border: 1px solid rgba(255, 215, 0, 0.3);
    border-radius: 15px;
    padding: 1.5rem;
    margin: 1.5rem 0;
    backdrop-filter: blur(10px);
}

#newHighScoreMessage div {
    font-family: 'Orbitron', 'Exo 2', sans-serif;
    color: #ffd700;
    text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
    animation: goldPulse 2s ease-in-out infinite;
}

@keyframes goldPulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

#playerNameInput {
    background: rgba(15, 20, 25, 0.6);
    border: 1px solid rgba(255, 215, 0, 0.3);
    border-radius: 10px;
    padding: 0.8rem 1rem;
    color: #e6edf3;
    font-family: 'Exo 2', sans-serif;
    font-size: 1rem;
    width: 100%;
    margin: 1rem 0;
    backdrop-filter: blur(10px);
}

#playerNameInput:focus {
    outline: none;
    border-color: rgba(255, 215, 0, 0.5);
    box-shadow: 0 0 15px rgba(255, 215, 0, 0.2);
}

#saveScoreButton {
    background: linear-gradient(135deg, #ffd700, #ffed4e);
    border: none;
    color: #0f1419;
    font-family: 'Exo 2', sans-serif;
    font-weight: bold;
    padding: 0.8rem 2rem;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
}

#saveScoreButton:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(255, 215, 0, 0.5);
}

/* Game over buttons with glassmorphism */
#gameOver .game-button {
    background: rgba(15, 20, 25, 0.5);
    backdrop-filter: blur(25px);
    border: 1px solid rgba(79, 172, 254, 0.3);
    color: #e6edf3;
    font-family: 'Exo 2', sans-serif;
    font-weight: 600;
    font-size: 1.1rem;
    padding: 1rem 2rem;
    border-radius: 15px;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 8px 25px rgba(15, 20, 25, 0.6), inset 0 1px 0 rgba(79, 172, 254, 0.1);
    letter-spacing: 1px;
    text-transform: uppercase;
}

#gameOver .game-button:hover {
    background: rgba(15, 20, 25, 0.7);
    border-color: rgba(79, 172, 254, 0.5);
    transform: translateY(-3px);
    box-shadow: 0 12px 35px rgba(15, 20, 25, 0.8), 0 0 20px rgba(79, 172, 254, 0.3);
}

/* Specific game over button themes */
#restartButton {
    border-color: rgba(0, 242, 254, 0.4);
}
#restartButton:hover {
    border-color: rgba(0, 242, 254, 0.6);
    box-shadow: 0 12px 35px rgba(15, 20, 25, 0.8), 0 0 20px rgba(0, 242, 254, 0.3);
}

#gameOverMainMenuBtn {
    border-color: rgba(124, 58, 237, 0.4);
}
#gameOverMainMenuBtn:hover {
    border-color: rgba(124, 58, 237, 0.6);
    box-shadow: 0 12px 35px rgba(15, 20, 25, 0.8), 0 0 20px rgba(124, 58, 237, 0.3);
}

/* ==================== PAUSE SETTINGS MODAL ==================== */
#settingsScreen {
    background: linear-gradient(135deg, rgba(15, 20, 25, 0.98) 0%, rgba(26, 35, 50, 0.98) 50%, rgba(13, 17, 23, 0.98) 100%);
    backdrop-filter: blur(30px);
    border-radius: 20px;
    max-width: 90%;
    max-height: 90%;
    box-shadow: 0 25px 70px rgba(0, 0, 0, 0.9);
    overflow: hidden;
}

#settingsScreen h2 {
    font-family: 'Orbitron', 'Exo 2', sans-serif;
    color: #43cbff;
    text-shadow: 0 0 20px rgba(67, 203, 255, 0.4);
}

#closeSettingsButton {
    background: rgba(15, 20, 25, 0.6);
    border: 1px solid rgba(79, 172, 254, 0.3);
    border-radius: 15px;
    color: #e6edf3;
    font-family: 'Exo 2', sans-serif;
    font-weight: 600;
    padding: 0.8rem 2rem;
    cursor: pointer;
    transition: all 0.3s ease;
    backdrop-filter: blur(15px);
    margin-top: 2rem;
}

#closeSettingsButton:hover {
    background: rgba(15, 20, 25, 0.8);
    border-color: rgba(79, 172, 254, 0.5);
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(15, 20, 25, 0.7), 0 0 15px rgba(79, 172, 254, 0.2);
}

    </style>
</head>
<body>

<!-- Title Screen -->
<div id="titleScreen" class="screen active">
    <div class="title-container">

<!-- Particle Background Canvas -->
<canvas id="particle-canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1;"></canvas>
    <h1 class="game-title">
            <span class="title-letter">D</span>
            <span class="title-letter">a</span>
            <span class="title-letter">s</span>
            <span class="title-letter">h</span>
            <span class="title-letter"> </span>
            <span class="title-letter">B</span>
            <span class="title-letter">l</span>
            <span class="title-letter">i</span>
            <span class="title-letter">t</span>
            <span class="title-letter">Z</span>
        </h1>
        <div class="title-subtitle">by Alan G.</div>

        <!-- After Title Screen -->
        
        <div class="auth-container">
            <button class="start-button" onclick="showMainMenu()">
                <span class="button-text">Enter Game</span>
            </button>
            
            <div class="auth-divider">
                <span class="divider-line"></span>
                <span class="divider-text">or</span>
                <span class="divider-line"></span>
            </div>
            
            <div class="google-signin-container">
                <button class="google-signin-button" onclick="signInWithGoogle()">
                    <div class="google-icon">
                        <svg width="20" height="20" viewBox="0 0 24 24">
                            <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                            <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                            <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                            <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                        </svg>
                    </div>
                    <span class="google-text">Sign in with Google</span>
                </button>
                <div class="google-benefit-text">(for cloud saves across devices!)</div>
            </div>
            
            <div class="auth-status" id="auth-status" style="display: none;">
                <div class="user-info">
                    <div class="user-avatar" id="user-avatar"></div>
                    <div class="user-details">
                        <div class="user-name" id="user-name">Loading...</div>
                        <div class="user-email" id="user-email">Loading...</div>
                    </div>
                    <button class="sign-out-button" onclick="signOutGoogle()">Sign Out</button>
                </div>
            </div>
        </div>
    </div>
    
    
</div>

<!-- Main Menu Hub -->
<div id="main-menu" class="screen" style="background: linear-gradient(135deg, #0f1419 0%, #1a2332 50%, #0d1117 100%); z-index: 200;">
    <div class="menu-container">
        <div class="menu-header">
            <h2 class="menu-title">Dash BlitZ</h2>
            <div class="player-stats">
                <div class="coin-display">
                    <span class="coin-icon">🪙</span>
                    <span id="coin-count">0</span>
                </div>
            </div>
        </div>
        
        <div class="daily-challenges-button-container">
            <button class="daily-challenges-btn" onclick="showDailyChallenges()">
                <div class="challenges-btn-icon">🏆</div>
                <div class="challenges-btn-content">
                    <div class="challenges-btn-title">Daily Challenges</div>
                    <div class="challenges-btn-subtitle" id="challenges-progress-text">3 challenges available</div>
                </div>
                <div class="challenges-btn-badge" id="challenges-completion-badge" style="display: none;">
                    <span id="completed-count">0</span>/3
                </div>
            </button>
        </div>
        
        <div class="menu-grid">
            <button class="menu-card run-card" onclick="showWorldSelectFromMenu()">
                <div class="card-icon">🏃</div>
                <div class="card-title">RUN</div>
                <div class="card-subtitle">Begin Your Journey</div>
            </button>
            
            <button class="menu-card characters-card" onclick="showCharacterSelectFromMenu()">
                <div class="card-icon">👤</div>
                <div class="card-title">CHARACTERS</div>
                <div class="card-subtitle">Choose Your Hero</div>
            </button>
            
            <button class="menu-card shop-card" onclick="showShopFromMenu()">
                <div class="card-icon">🛍️</div>
                <div class="card-title">SHOP</div>
                <div class="card-subtitle">Unlock & Upgrade</div>
            </button>
            
            <button class="menu-card settings-card" onclick="showSettingsFromMenu()">
                <div class="card-icon">⚙️</div>
                <div class="card-title">SETTINGS</div>
                <div class="card-subtitle">Configure Experience</div>
            </button>
        </div>
    </div>
</div>

<!-- Settings Screen -->
<div id="settings" class="screen">
    <div class="screen-header">
        <button class="back-button" onclick="backFromSettings()">←</button>
        <h2>Settings</h2>
        <div class="spacer"></div>
    </div>
    <div class="settings-content">
        <div class="setting-group">
            <h3>Save & Sync</h3>
            <div class="save-options">
                <button class="save-btn primary" onclick="showSaveCode()">
                    <div class="save-btn-icon">📱</div>
                    <div class="save-btn-content">
                        <div class="save-btn-title">Generate Save Code</div>
                        <div class="save-btn-subtitle">Transfer progress to any device</div>
                    </div>
                </button>
                
                <button class="save-btn secondary" onclick="showRestoreCode()">
                    <div class="save-btn-icon">📥</div>
                    <div class="save-btn-content">
                        <div class="save-btn-title">Restore from Code</div>
                        <div class="save-btn-subtitle">Import progress from another device</div>
                    </div>
                </button>
            </div>
        </div>
        
        <div class="setting-group">
            <h3>Audio</h3>
            <div class="setting-item">
                <label>Music Volume</label>
                <input type="range" id="music-volume" min="0" max="100" value="50">
            </div>
            <div class="setting-item">
                <label>Sound Effects</label>
                <input type="range" id="sfx-volume" min="0" max="100" value="50">
            </div>
        </div>
        
        <div class="setting-group">
            <h3>Jukebox</h3>
            <div class="jukebox-controls">
                <button class="jukebox-btn" onclick="playTrack('theme')">🎵 Theme Song</button>
                <button class="jukebox-btn" onclick="playTrack('action')">🎵 Action Beat</button>
                <button class="jukebox-btn" onclick="playTrack('chill')">🎵 Chill Vibes</button>
            </div>
        </div>

        <div class="setting-group">
    <h3>Developer Options</h3>
    <div class="mod-section" style="background: rgba(15, 20, 25, 0.5); border: 1px solid rgba(79, 172, 254, 0.2); border-radius: 10px; padding: 15px; margin-bottom: 15px;">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
            <div>
                <h4 style="color: #43cbff; margin: 0;">Mod Mode</h4>
                <p style="color: #b3c7e6; margin: 5px 0 0 0; font-size: 0.9rem;">Unlock all content</p>
            </div>
            <button id="mainMenuModButton" class="settings-btn" style="background: linear-gradient(135deg, #1e40af, #3730a3); border: 1px solid rgba(79, 172, 254, 0.3); color: #e6edf3; padding: 8px 20px; border-radius: 20px; cursor: pointer; font-weight: bold;">Enable</button>
        </div>
        <input type="password" id="mainMenuModPassword" placeholder="Enter password" style="width: 100%; padding: 10px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(79, 172, 254, 0.2); border-radius: 5px; color: #e6edf3;">
    </div>
    
    <div id="mainMenuDifficultyOption" style="display: none; background: rgba(15, 20, 25, 0.5); border: 1px solid rgba(79, 172, 254, 0.2); border-radius: 10px; padding: 15px; margin-bottom: 15px;">
        <h4 style="color: #43cbff; margin: 0 0 10px 0;">Force Difficulty Level</h4>
        <p style="color: #b3c7e6; margin: 0 0 10px 0; font-size: 0.9rem;">Override speed level for testing</p>
        <select id="mainMenuDifficultyOverride" style="width: 100%; padding: 10px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(79, 172, 254, 0.2); border-radius: 5px; color: #e6edf3; margin-bottom: 10px;">
            <option value="-1">Normal (Time-Based)</option>
            <option value="0">Level 1 - Cruise</option>
            <option value="1">Level 2 - Accelerating</option>
            <option value="2">Level 3 - Intense</option>
            <option value="3">Level 4 - Blazing</option>
            <option value="4">Level 5 - Maximum Chaos</option>
        </select>
        <button id="mainMenuApplyDifficultyButton" class="settings-btn" style="background: linear-gradient(135deg, #1e40af, #3730a3); border: 1px solid rgba(79, 172, 254, 0.3); color: #e6edf3; padding: 8px 20px; border-radius: 20px; cursor: pointer; font-weight: bold; width: 100%;">Apply</button>
    </div>
    
    <div style="background: rgba(15, 20, 25, 0.5); border: 1px solid rgba(220, 38, 38, 0.3); border-radius: 10px; padding: 15px;">
        <div style="display: flex; align-items: center; justify-content: space-between;">
            <div>
                <h4 style="color: #ef4444; margin: 0;">Reset Game Data</h4>
                <p style="color: #b3c7e6; margin: 5px 0 0 0; font-size: 0.9rem;">Clear all saved progress</p>
            </div>
            <button id="mainMenuResetDataButton" class="settings-btn" style="background: linear-gradient(135deg, #dc2626, #991b1b); border: 1px solid rgba(220, 38, 38, 0.3); color: #fff; padding: 8px 20px; border-radius: 20px; cursor: pointer; font-weight: bold;">Reset</button>
        </div>
    </div>
</div>

    </div>
</div>

<!-- Daily Challenges Modal -->
<div id="daily-challenges-modal" class="challenges-modal">
    <div class="challenges-modal-content">
        <div class="challenges-modal-header">
            <h2>🏆 Daily Challenges</h2>
            <button class="close-challenges-btn" onclick="closeDailyChallenges()">×</button>
        </div>
        <div class="challenges-modal-body">
            <div class="challenges-subtitle">Complete challenges to earn bonus coins!</div>
            <div id="daily-challenges-container">
                <!-- Challenges will be populated by JavaScript -->
            </div>
        </div>
        <div class="challenges-modal-footer">
            <div class="challenges-reset-info">
                <span class="reset-icon">🔄</span>
                <span>Challenges reset daily at midnight</span>
            </div>
        </div>
    </div>
</div>

<!--------- BUTTONS & UI SECTION--------->
<!--==============================-->
<!--==============================-->



<div id="characterSelectScreen" class="screen">
    <div class="screen-header">
        <button class="back-button" onclick="backToMainMenu()">←</button>
        <h2>Select Character</h2>
        <div class="coin-display">
            <span class="coin-icon">🪙</span>
            <span id="character-select-coins">0</span>
        </div>
    </div>
    
    <div class="selection-container">
        <div class="preview-area">
            <div class="preview-box" id="characterDisplay">
                <!-- 3D character model renders here -->
            </div>
            
            <div class="preview-controls">
                <button id="prevCharacterBtn" class="nav-button">
                    <span>◀</span>
                </button>
                
                <div class="character-info-card">
                    <h3 id="characterName">Apple</h3>
                    <p id="characterDescription" class="character-subtitle">Classic runner</p>
                    <div id="characterUnlockStatus" class="unlock-status">
                        <span class="status-icon">✅</span>
                        <span class="status-text">Unlocked</span>
                    </div>
                </div>
                
                <button id="nextCharacterBtn" class="nav-button">
                    <span>▶</span>
                </button>
            </div>
        </div>
        
        <div class="action-buttons-container">
            <button id="selectCharacterButton" class="action-button secondary">
                <span class="button-glow"></span>
                <span class="button-text">SELECT CHARACTER</span>
            </button>
            <button id="startGameButton" class="action-button primary">
                <span class="button-glow"></span>
                <span class="button-text">START RUNNING!</span>
            </button>
        </div>
    </div>
    </div>
</div>
<div id="worldSelectScreen" class="screen">
    <div class="screen-header">
        <button class="back-button" onclick="backToMainMenu()">←</button>
        <h2>Select World</h2>
        <div class="coin-display">
            <span class="coin-icon">🪙</span>
            <span id="world-select-coins">0</span>
        </div>
    </div>
    
    <div class="selection-container">
        <div class="preview-area">
            <div class="preview-box world-preview" id="worldDisplay">
                <div id="worldPreview"></div>
            </div>
            
            <div class="preview-controls">
                <button id="prevWorldBtn" class="nav-button">
                    <span>◀</span>
                </button>
                
                <div class="world-info-card">
                    <h3 id="worldName">Classic Plains</h3>
                    <p id="worldDescription" class="world-subtitle">Rolling green hills and peaceful meadows</p>
                    <div id="worldUnlockStatus" class="unlock-status">
                        <span class="status-icon">✅</span>
                        <span class="status-text">Unlocked</span>
                    </div>
                </div>
                
                <button id="nextWorldBtn" class="nav-button">
                    <span>▶</span>
                </button>
            </div>
        </div>
        
        <button id="startGameFromWorldButton" class="action-button primary">
            <span class="button-glow"></span>
            <span class="button-text">START ADVENTURE!</span>
        </button>
    </div>
</div>

<!-- Game Over Screen -->
<div id="score">Score: 0</div>
    <div id="totalCoins">Coins: 0</div>
    <button id="pauseBtn">⏸️</button>
    <div id="speedIndicator">Speed: 1x</div>
    <div id="gameOver">
    <h2 style="margin-top: 0;">Game Over</h2>
    <span id="finalScore" style="font-size: 24px;"></span><br>
    <span id="coinsCollected" style="font-size: 20px; margin-bottom: 15px; display: inline-block;"></span><br>
    <div id="newHighScoreMessage" style="display: none; color: gold; margin: 10px 0;">
        <div style="margin-bottom: 10px; font-size: 22px;">New High Score!</div>
        <input type="text" id="playerNameInput" placeholder="Enter your name" maxlength="15">
        <button id="saveScoreButton">Save Score</button>
    </div>
    <div class="game-buttons" style="display: flex; flex-direction: column; gap: 10px; width: 100%; max-width: 250px; margin: 0 auto;">
    <button id="restartButton" class="game-button">Restart</button>
    <button id="gameOverSettingsBtn" class="game-button">Settings</button>
    <button id="gameOverMainMenuBtn" class="game-button">Main Menu</button>
</div>
</div>
    <div id="startScreen">
        <h1>3D Endless Runner</h1>
        <p style="color: white; margin-bottom: 20px;">
            Use ← → to move and ↑ or SPACE to jump. Press ↓ to drop quickly!<br>
            Press P to pause the game. Jump over streams and avoid obstacles.<br>
            <span id="mobileInstructions" style="display: none;">On mobile, swipe left/right to move, swipe up to jump, and swipe down to drop quickly.</span>
        </p>
        <button id="startButton">Start Game</button>
    </div>

    <!-- Pause Screen -->
    <div id="pauseScreen">
    <h2>Paused</h2>
    <p>Press P or tap to resume</p>
    <div class="game-buttons" style="display: flex; flex-direction: column; gap: 10px; width: 100%; max-width: 250px; margin: 0 auto;">
    <button id="resumeButton" class="game-button">Resume Game</button>
    <button id="pauseRestartButton" class="game-button">Restart</button>
    <button id="pauseSettingsBtn" class="game-button">Settings</button>
    <button id="pauseMainMenuBtn" class="game-button">Main Menu</button>
</div>
</div>

    <!-- Settings Menu Tabs -->
    <div id="modalOverlay"></div>
<div id="settingsScreen">
    <h2>Settings</h2>
    
    <div class="tab-buttons">
        <button class="tab-button active" data-tab="settings-tab">⚙️ Game Settings</button>
        <button class="tab-button" data-tab="leaderboard-tab">🏆 Leaderboard</button>
        <button class="tab-button" data-tab="global-leaderboard-tab">🌍 Global</button>
    </div>
        
        <div id="settings-tab" class="tab-content active">
    <div class="settings-section">
    <h3>Audio Settings</h3>
    <div class="audio-setting-row">
        <span class="audio-label">Sound Effects</span>
        <label class="audio-checkbox">
            <input type="checkbox" id="soundEffectsCheckbox" checked>
            <span class="checkmark"></span>
        </label>
    </div>
    <div class="audio-setting-row">
        <span class="audio-label">Background Music</span>
        <label class="audio-checkbox">
            <input type="checkbox" id="backgroundMusicCheckbox" checked>
            <span class="checkmark"></span>
        </label>
    </div>
</div>

<div class="settings-section">
    <h3>🎵 Jukebox</h3>
    <p style="color: white; font-size: 14px; margin-bottom: 15px; opacity: 0.8;">Choose your soundtrack for the ultimate running experience!</p>
    <div id="jukeboxTracks">
        <!-- Track options will be populated by JavaScript -->
    </div>
    <div style="margin-top: 15px; padding: 10px; background: rgba(255, 255, 255, 0.1); border-radius: 8px;">
        <button id="previewTrackBtn" class="game-button" style="padding: 8px 16px; font-size: 16px; margin-right: 10px;">🎧 Preview</button>
        <button id="applyTrackBtn" class="game-button" style="padding: 8px 16px; font-size: 16px;">✅ Apply Track</button>
    </div>
</div>
    
        </div>
        
       
        <!-- LEADERBOARD TAB -->
        <div id="leaderboard-tab" class="tab-content">
            <div class="settings-section">
                <h3>Top Scores</h3>
                <table class="leaderboard-table">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Name</th>
                            <th>Score</th>
                            <th>Date</th>
                        </tr>
                    </thead>
                    <tbody id="leaderboardBody">
                        <!-- Leaderboard entries will be added here -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- GLOBAL LEADERBOARD TAB -->
<div id="global-leaderboard-tab" class="tab-content">
    <div class="settings-section">
        <h3>🌍 Global Leaderboard</h3>
        <table class="leaderboard-table">
            <thead>
                <tr>
                    <th>Rank</th>
                    <th>Player</th>
                    <th>Score</th>
                    <th>Character</th>
                </tr>
            </thead>
            <tbody id="globalLeaderboardBody">
                <!-- Global leaderboard entries will be added here -->
            </tbody>
        </table>
        
        <div style="text-align: center; margin-top: 15px;">
            <p id="globalPlayerRank" style="color: #FFD700; font-size: 14px; margin: 10px 0;"></p>
            <button onclick="updateGlobalLeaderboardDisplay()" class="game-button" 
                style="padding: 8px 16px; font-size: 14px; background: #4CAF50;">
                🔄 Refresh Global Scores
            </button>
        </div>
    </div>
</div>

        <button id="closeSettingsButton">Close</button>
    </div>
    <div id="touchArea"></div>
    <div id="swipeInstructions">Swipe ← → to move • Swipe ↑ to jump • Swipe ↓ to drop</div>

    <!-- Shop Screen -->
<div id="shopScreen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; flex-direction: column; z-index: 3; background: linear-gradient(135deg, #0f1419 0%, #1a2332 50%, #0d1117 100%);">
    <div style="display: flex; justify-content: space-between; align-items: center; padding: 2rem; background: rgba(15, 20, 25, 0.8); backdrop-filter: blur(15px); border-bottom: 1px solid rgba(79, 172, 254, 0.2);">
        <button onclick="backToMainMenu()" style="background: rgba(15, 20, 25, 0.6); border: 1px solid rgba(79, 172, 254, 0.3); border-radius: 50%; width: 50px; height: 50px; color: #e6edf3; font-size: 1.5rem; cursor: pointer; transition: all 0.3s ease; backdrop-filter: blur(10px);">←</button>
        <h2 style="color: #43cbff; font-size: 2.5rem; margin: 0; text-shadow: 0 0 20px rgba(67, 203, 255, 0.4); font-family: 'Orbitron', 'Exo 2', sans-serif;">SHOP</h2>
        <div style="display: flex; align-items: center; gap: 0.5rem; background: rgba(15, 20, 25, 0.6); padding: 0.5rem 1rem; border-radius: 25px; backdrop-filter: blur(20px); border: 1px solid rgba(79, 172, 254, 0.3);">
            <span style="font-size: 1.2rem;">🪙</span>
            <span id="shop-coin-count" style="color: #e6edf3; font-weight: bold;">0</span>
        </div>
    </div>
    
    <div style="display: flex; justify-content: center; margin: 1rem 0; gap: 1rem;">
        <button id="shop-characters-tab" class="shop-tab active" onclick="switchShopTab('characters')" style="padding: 0.8rem 2rem; background: rgba(67, 203, 255, 0.15); border: 1px solid #43cbff; border-radius: 25px; color: #43cbff; cursor: pointer; transition: all 0.3s ease; backdrop-filter: blur(15px); font-weight: bold;">Characters</button>
        <button id="shop-worlds-tab" class="shop-tab" onclick="switchShopTab('worlds')" style="padding: 0.8rem 2rem; background: rgba(15, 20, 25, 0.5); border: 1px solid rgba(79, 172, 254, 0.2); border-radius: 25px; color: #e6edf3; cursor: pointer; transition: all 0.3s ease; backdrop-filter: blur(15px);">Worlds</button>
    </div>
    
    <div id="shop-characters-content" class="shop-content active" style="flex: 1; overflow-y: auto; padding: 0 2rem;">
        <div id="shop-characters-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem; padding-bottom: 2rem;">
            <!-- Characters will be populated by JavaScript -->
        </div>
    </div>
    
    <div id="shop-worlds-content" class="shop-content" style="flex: 1; overflow-y: auto; padding: 0 2rem; display: none;">
        <div id="shop-worlds-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem; padding-bottom: 2rem;">
            <!-- Worlds will be populated by JavaScript -->
        </div>
    </div>
</div>

<!-- Power-up Status Bar -->
<div id="powerUpStatusBar">
    <div class="powerup-icon" id="shieldIcon">
        <div class="powerup-symbol">🛡️</div>
        <div class="powerup-fill"></div>
    </div>
    <div class="powerup-icon" id="multiplierIcon">
        <div class="powerup-symbol">💰</div>
        <div class="powerup-fill"></div>
    </div>
    <div class="powerup-icon" id="magnetIcon">
        <div class="powerup-symbol">🧲</div>
        <div class="powerup-fill"></div>
    </div>
    <!-- Character Ability Icon (hidden by default) -->
    <div class="powerup-icon ability-icon" id="characterAbilityIcon" style="display: none;">
        <div class="powerup-symbol ability-symbol">🔥</div>
        <div class="powerup-fill ability-fill"></div>
    </div>
</div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

<!-- Character System - New Modular Approach -->
<script src="characters/shared.js"></script>
<script src="characters/installed/happyface.js"></script>
<script src="characters/installed/ghost.js"></script>
<script src="characters/installed/robot.js"></script>
<script src="characters/installed/dragon.js"></script>
<script src="characters/installed/ufo.js"></script>
<script src="characters/installed/atom.js"></script>
<script src="characters/installed/slime.js"></script>
<script src="characters/installed/apple.js"></script>
<script src="characters/installed/carrot.js"></script>
<script src="characters/installed/pumpkin.js"></script>
<script src="characters/installed/monster.js"></script>
<script src="characters/installed/creature.js"></script>
<!-- CHARACTER INJECTION POINT - Additional characters will be loaded here -->
<script src="worlds/forest.js"></script>
<script src="worlds/desert.js"></script>
<script src="systems/obstacles.js"></script>
<script src="systems/audio.js"></script>
<script src="systems/powerups.js"></script>



    <script>

// Game variables
        let scene, camera, renderer, player, obstacles = [], coins = [], ground;
        let waterStreams = [];
        let rareCoins = []; // Array for rare gradient coins
        let powerUps = []; // Array for power-ups
        let activePowerUps = {}; // Track active power-ups
        let powerUpTimers = {}; // Track power-up durations
        let explosionParticles = [];
        let sparkleParticles = [];
        let sceneryObjects = [];
        let meteors = []; // Array to store falling meteors
        let meteorSpawnCounter = 0; // Counter for meteor spawning
        let meteorSpawnRate = 600; // Frames between meteor spawns (much slower - about every 20 seconds)
        let score = 0;
        let totalCoins = 0;
        let gameStarted = false;
        let gameOver = false;
        let gamePaused = false;
        let playerSpeed = 0.2;

// Power-up states
let shieldActive = false;
let coinMultiplierActive = false;
let magnetActive = false;
let powerUpSpawnRate = 1200; // Power-ups spawn every 20 seconds (1200 frames at 60fps)

// Character ability states
let robotShieldActive = false;
let robotShieldCooldown = 0;
let dragonFireActive = false;
let dragonFireCooldown = 0;
let ghostPhaseActive = false;
let ghostPhaseCharges = 0;
let ghostPhaseCooldown = 0;

// Daily challenge tracking variables
let coinsCollectedThisRun = 0;
let jumpCount = 0;
let powerupsCollectedThisRun = 0;
let laneChangeCount = 0;
let survivalTime = 0;
let nearMissCount = 0;
// gameStartTime is already declared in speed system variables belowlet maxSpeedReached = 0;

        
        // Dynamic difficulty variables (time-based)
        let baseSpeed = 0.25;                    // Starting speed
        let currentSpeed = 0.25;                 // Current game speed
        let maxSpeed = 0.65;                     // Maximum speed cap (increased for 4th level)
        let speedIncrement = 0.1;                // Speed increase per interval
        let currentSpeedMultiplier = 1.0;        // Visual speed indicator
        
        // Time-based speed progression
        let gameStartTime = 0;                   // When the game started
        let speedIncreaseIntervals = [20000, 50000, 100000, 160000]; // 20s, 50s more, 50s more, 60s more (in milliseconds)
        let currentSpeedLevel = 0;               // Which speed level we're at
        
        // Spawn rate variables - start with more obstacles, get more frequent with speed
        let baseObstacleSpawnRate = 80;          // Starting frames between obstacles (more frequent)
        let currentObstacleSpawnRate = 80;       // Current spawn rate
        let minObstacleSpawnRate = 40;           // Minimum spawn rate (very frequent)
        
        let baseStreamSpawnRate = 800;           // Starting frames between streams (very rare)
        let currentStreamSpawnRate = 800;        // Current stream spawn rate
        let minStreamSpawnRate = 500;            // Minimum stream spawn rate (still rare)
        
        let streamSpawnCounter = 0;              // Counter for tracking when to force spawn a stream
        let forcedStreamInterval = 800;          // Force spawn a stream after this many frames (rare)
        let coinSpawnRate = 40;                  // Frames between coin spawns (stays constant)
        let scenerySpawnRate = 25;               // Frames between scenery spawns (stays constant)
        
        let frameCount = 0;
        let lanes = [-2, 0, 2]; // Left, center, right
        let currentLane = 1; // Start in center (index 1)
        let jumping = false;
        let playerY = 0.5; // Player's base Y position (height is 1)
        let jumpHeight = 2;
        let jumpSpeed = 0.1;
        let jumpDirection = 1; // 1 = up, -1 = down
        let jumpRotation = 0; // For front flip animation
        let distanceTraveled = 0;
        let isMobile = false; // Flag for mobile device detection
        let groundSegments = []; // Store ground segments for texture updates
        let sideTerrainSegments = []; // Store side terrain segments for movement
        let groundIndex = 0; // Index for tracking ground segments
        let streamCreated = false; // Flag to track if a stream was created on this frame
        
        // Leaderboard variables
        let leaderboard = [];
        let currentHighScore = 0;
        let pendingScore = 0;
        const MAX_LEADERBOARD_ENTRIES = 10;
        
        // Weather and environment variables
        let skyLight;
        let weatherParticles = [];
        let currentWeather = "clear"; // clear, rain, snow
        let targetWeather = "clear"; // For smooth transitions
        let weatherChangeCounter = 0;
        let weatherChangeDuration = 1800; // Frames until weather change (1 minute at 30fps)
        let weatherTransitionProgress = 0; // For smooth transitions
        let time = 0; // Time of day (0-1), 0 = day, 0.5 = sunset, 1 = night
        let timeCycleSpeed = 0.0001; // How fast time cycles
        let butterflyGroups = [];
        let birds = [];
        let currentSkyColor = new THREE.Color(0x87CEEB); // Starting sky color
        let targetSkyColor = new THREE.Color(0x87CEEB); // Target sky color for transitions

// Game state variables (simplified - no title character models needed)
let gameState = "title"; // title, characterSelect, playing, paused, gameOver
let titleCharacterModels = []; // Store character models for the title screen
let characterSelectModels = []; // Store character models for the selection screen
let selectedCharacterIndex = 0; // Index of the currently selected character
let characterNames = [
    // CHARACTER ROSTER INJECTION POINT - Package manager will modify this array
    "apple", "carrot", "pumpkin", "happyface", "monster", "atom", "slime", "ufo", "robot", "dragon", "ghost", "creature"
    // END CHARACTER ROSTER INJECTION POINT
];

// World system variables
let currentWorld = "classic";
let selectedWorldIndex = 0;
let worldNames = ["classic"];
let unlockedWorlds = {
    classic: true
};
let worldCosts = {};

// World definitions
let availableWorlds = [
    {
        id: 'classic',
        name: 'Classic Plains',
        description: 'Rolling green hills and peaceful meadows',
        cost: 0,
        colors: {
            sky: 0x87CEEB,
            fog: 0xB0E0E6,
            ground: 0x4CAF50
        },
        lighting: {
            ambient: { color: 0xffffff, intensity: 0.6 },
            directional: { color: 0xffffff, intensity: 0.8 }
        }
    },
    {
        id: 'forest',
        name: 'Enchanted Forest',
        description: 'Mystical woodland with towering trees and magical creatures',
        cost: 5000,
        colors: {
            sky: 0x228B22,
            fog: 0x90EE90,
            ground: 0x2F4F2F
        },
        lighting: {
            ambient: { color: 0x404040, intensity: 0.4 },
            directional: { color: 0xFFFFE0, intensity: 0.6 }
        }
    },
    {
        id: 'desert',
        name: 'Desert Mirage',
        description: 'Scorching sand dunes with mysterious mirages and ancient secrets',
        cost: 10000,
        colors: {
            sky: 0xFFE4B5,
            fog: 0xDEB887,
            ground: 0xF4A460
        },
        lighting: {
            ambient: { color: 0xFFE4B5, intensity: 0.7 },
            directional: { color: 0xFFF8DC, intensity: 1.0 }
        }
    }
];

let worldSelectModels = [];
let worldSelectScene, worldSelectCamera, worldSelectRenderer;


        
        // Mod mode variables
let modModeEnabled = false;
const MOD_PASSWORD = "5050";
let difficultyOverride = -1; // -1 = normal, 0-4 = force specific level

// Audio control variables
let soundEffectsEnabled = true;
let backgroundMusicEnabled = true;

// Jukebox system variables
let availableTracks = [
    { id: 'medieval', name: 'The Throne', description: 'Epic fantasy adventure music' },
    { id: 'electronic', name: 'Cybershock', description: 'Futuristic electronic beats' },
    { id: 'ambient', name: 'Field of Memories', description: 'Dreamy ethereal lofi vibes' }
];
let currentTrack = 'ambient'; // Default to ambient music
let selectedTrack = 'ambient'; // Track selected in jukebox

// Object pools for performance optimization
let sparklePool = [];
let explosionPool = [];
let poolSize = 50; // Maximum pooled objects

// ==================== OBJECT POOL SYSTEM ====================
// Performance optimization - pre-created objects for reuse
// Dependencies: None
// Functions: initializeObjectPools(), getSparkleFromPool(), returnSparkleToPool(), etc.

// Shared materials for performance
const SharedMaterials = {
    coin: null,
    coinEdge: null,
    obstacle: null,
    
    init() {
        this.coin = new THREE.MeshStandardMaterial({ 
            color: 0xFFD700,
            metalness: 1.0,
            roughness: 0.05,
            emissive: 0xFFD700,
            emissiveIntensity: 0.4
        });
        
        this.coinEdge = new THREE.MeshStandardMaterial({ 
            color: 0xFFD700,
            metalness: 1.0, 
            roughness: 0.03,
            emissive: 0xFFD700,
            emissiveIntensity: 0.3
        });
        
        this.obstacle = new THREE.MeshStandardMaterial({
            color: 0xff0000,
            roughness: 0.8
        });
    }
};

// Initialize shared materials
SharedMaterials.init();

// Initialize object pools
function initializeObjectPools() {
    // Pre-create sparkle particles
    for (let i = 0; i < poolSize; i++) {
        const sparkleGeometry = new THREE.SphereGeometry(0.05, 8, 8);
        const sparkleMaterial = new THREE.MeshStandardMaterial({
            color: 0xFFD700,
            emissive: 0xFFFFFF,
            emissiveIntensity: 1,
            transparent: true,
            opacity: 0
        });
        const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
        sparkle.visible = false;
        sparklePool.push(sparkle);
    }
    
    // Pre-create explosion particles
    for (let i = 0; i < poolSize; i++) {
        const explosionGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const explosionMaterial = new THREE.MeshStandardMaterial({
            color: 0xff0000,
            emissive: 0xff0000,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0
        });
        const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
        explosion.visible = false;
        explosionPool.push(explosion);
    }
}

// Coin pool for performance
let coinPool = [];
let coinPoolSize = 20;

function initializeCoinPool() {
    for (let i = 0; i < coinPoolSize; i++) {
        const coin = createCoinObject();
        coin.visible = false;
        coinPool.push(coin);
    }
}

function getCoinFromPool() {
    for (let i = 0; i < coinPool.length; i++) {
        if (!coinPool[i].visible) {
            coinPool[i].visible = true;
            return coinPool[i];
        }
    }
    // Pool exhausted, create new coin
    return createCoinObject();
}

function returnCoinToPool(coin) {
    coin.visible = false;
    coin.position.set(0, 0, -100);
    coin.rotation.set(0, 0, 0);
}

// Get sparkle from pool
function getSparkleFromPool() {
    for (let i = 0; i < sparklePool.length; i++) {
        if (!sparklePool[i].visible) {
            return sparklePool[i];
        }
    }
    return null; // Pool exhausted
}

// Return sparkle to pool
function returnSparkleToPool(sparkle) {
    sparkle.visible = false;
    sparkle.material.opacity = 0;
    sparkle.scale.set(1, 1, 1);
    sparkle.position.set(0, 0, 0);
    if (sparkle.userData) {
        sparkle.userData.age = 0;
        sparkle.userData.lifespan = 0;
    }
}

// Get explosion particle from pool
function getExplosionFromPool() {
    for (let i = 0; i < explosionPool.length; i++) {
        if (!explosionPool[i].visible) {
            return explosionPool[i];
        }
    }
    return null; // Pool exhausted
}

// Return explosion particle to pool
function returnExplosionToPool(explosion) {
    explosion.visible = false;
    explosion.material.opacity = 0;
    explosion.scale.set(1, 1, 1);
    explosion.position.set(0, 0, 0);
    if (explosion.userData) {
        explosion.userData.age = 0;
        explosion.userData.lifespan = 0;
    }
}

// Collision boundary cache for performance
let collisionCache = new Map();
let cacheUpdateThreshold = 0.5; // Update cache if object moved more than this distance

// Get cached or calculate collision boundary
function getCachedCollisionBox(object) {
    const objectId = object.uuid;
    const currentPos = object.position.clone();
    
    // Check if we have cached data
    if (collisionCache.has(objectId)) {
        const cached = collisionCache.get(objectId);
        const distance = cached.lastPosition.distanceTo(currentPos);
        
        // If object hasn't moved much, use cached boundary
        if (distance < cacheUpdateThreshold) {
            // Update the cached box position without recalculating
            const offset = new THREE.Vector3().subVectors(currentPos, cached.lastPosition);
            cached.boundingBox.translate(offset);
            cached.lastPosition = currentPos;
            return cached.boundingBox.clone();
        }
    }
    
    // Calculate new bounding box
    const boundingBox = new THREE.Box3().setFromObject(object);
    
    // Cache it
    collisionCache.set(objectId, {
        boundingBox: boundingBox.clone(),
        lastPosition: currentPos
    });
    
    return boundingBox;
}

// Clean up collision cache for removed objects
function cleanupCollisionCache(objectsArray, cacheKey) {
    const activeIds = new Set(objectsArray.map(obj => obj.uuid));
    for (const [id, cached] of collisionCache.entries()) {
        if (id.startsWith(cacheKey) && !activeIds.has(id)) {
            collisionCache.delete(id);
        }
    }
}

// Simplified distance-based collision for coins and power-ups
function checkSimpleCollision(object, player, threshold = 1.5) {
    return object.position.distanceTo(player.position) < threshold;
}
        
        // Character variables
        let currentCharacter = "happyface";
        let unlockedCharacters = {
    apple: true,
    carrot: false,
    pumpkin: false,
    happyface: false,
    monster: false,
    atom: false,
    slime: false,
    ufo: false,
    robot: false,
    dragon: false,
    ghost: false,
    creature: false
};
        let characterCosts = {
    carrot: 200,
    pumpkin: 500,
    happyface: 1000,
    monster: 5000,
    atom: 10000,
    slime: 15000,
    ufo: 20000,
    robot: 25000,
    dragon: 30000,
    ghost: 40000,
    creature: 50000
};
        
        // Touch/swipe variables
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;
        let swipeThreshold = 40; // Reduced threshold for easier swipe detection
        let jumpSwipeThreshold = 30; // Even lower threshold for jump
        
        // Textures
        let grassTexture;
        let waterTexture;
        
        // Time-based difficulty adjustment function
        function updateDynamicDifficulty() {
            // Check if we should increase speed based on time
            const currentTime = Date.now();
            const gameTime = currentTime - gameStartTime;
            
            // Check if we're using difficulty override
if (difficultyOverride >= 0) {
    // Use the forced difficulty level
    currentSpeedLevel = difficultyOverride;
    maxSpeedReached = Math.max(maxSpeedReached, currentSpeedLevel); // ADD THIS LINE
} else {
    // Use normal time-based progression
    // Check each speed interval
    for (let i = currentSpeedLevel; i < speedIncreaseIntervals.length; i++) {
        if (gameTime >= speedIncreaseIntervals[i]) {
            // Time to increase speed!
            currentSpeedLevel = i + 1;
            maxSpeedReached = Math.max(maxSpeedReached, currentSpeedLevel); // ADD THIS LINE
            console.log(`🏃 Speed increased! Current: ${currentSpeedLevel}, Max: ${maxSpeedReached}`);
            currentSpeed = Math.min(baseSpeed + (currentSpeedLevel * speedIncrement), maxSpeed);
                    
                    // Adjust obstacle spawn rates - more aggressive at higher speeds
let speedProgress = currentSpeedLevel / speedIncreaseIntervals.length;

// Make the progression more dramatic for higher speeds
if (currentSpeedLevel >= 3) {
    // At level 3 and 4, make it much more intense
    speedProgress = 0.7 + (currentSpeedLevel - 3) * 0.15; // 0.7, 0.85, 1.0+
}

currentObstacleSpawnRate = Math.floor(Math.max(
    baseObstacleSpawnRate - (speedProgress * (baseObstacleSpawnRate - minObstacleSpawnRate)),
    currentSpeedLevel >= 4 ? 25 : minObstacleSpawnRate // Even more frequent at max level
));
                    
                    // Adjust stream spawn rate - reduce streams at higher speeds since obstacles are more frequent
if (currentSpeedLevel >= 3) {
    // At high speeds, reduce streams since obstacles are much more frequent
    currentStreamSpawnRate = Math.floor(baseStreamSpawnRate * 1.2);
} else {
    currentStreamSpawnRate = Math.floor(Math.max(
        baseStreamSpawnRate - (speedProgress * 0.2 * (baseStreamSpawnRate - minStreamSpawnRate)),
        minStreamSpawnRate
    ));
}
                    
                    // Update speed multiplier for display
                    currentSpeedMultiplier = currentSpeed / baseSpeed;
                    updateSpeedIndicator();
                    
                    // Debug log to see what's happening
                    console.log(`Speed Level: ${currentSpeedLevel}, Speed: ${currentSpeed.toFixed(2)}, Obstacle Rate: ${currentObstacleSpawnRate}, Stream Rate: ${currentStreamSpawnRate}`);
                }
            }
        }
    } // Close the else statement for normal progression
        
        // Update speed indicator display with dynamic theming
function updateSpeedIndicator() {
    const speedIndicator = document.getElementById('speedIndicator');
    
    // Remove all existing speed level classes
    speedIndicator.className = '';
    
    // Apply visual theme based on speed level
    if (currentSpeedLevel === 0) {
        speedIndicator.classList.add('speed-level-1');
    } else if (currentSpeedLevel === 1) {
        speedIndicator.classList.add('speed-level-2');
    } else if (currentSpeedLevel === 2) {
        speedIndicator.classList.add('speed-level-3');
    } else if (currentSpeedLevel === 3) {
        speedIndicator.classList.add('speed-level-4');
    } else if (currentSpeedLevel >= 4) {
        speedIndicator.classList.add('speed-level-5');
    }
    
    // Show only the level names
    let levelText = '';
    if (currentSpeedLevel === 0) {
        levelText = 'CRUISE';
    } else if (currentSpeedLevel === 1) {
        levelText = 'ACCELERATING';
    } else if (currentSpeedLevel === 2) {
        levelText = 'INTENSE';
    } else if (currentSpeedLevel === 3) {
        levelText = 'BLAZING';
    } else if (currentSpeedLevel >= 4) {
        levelText = 'MAXIMUM CHAOS';
    }
    
    // Set only the level name without speed multiplier
    speedIndicator.textContent = levelText;
    
    // Ensure consistent font size for all levels
    speedIndicator.style.fontSize = '18px';
}
        
        // Reset difficulty to starting values
        function resetDynamicDifficulty() {
            gameStartTime = Date.now(); // Reset the timer
            currentSpeedLevel = 0;      // Reset speed level
            currentSpeed = baseSpeed;
            currentObstacleSpawnRate = baseObstacleSpawnRate;
            currentStreamSpawnRate = baseStreamSpawnRate;
            currentSpeedMultiplier = 1.0;
            streamSpawnCounter = 0;
            streamCreated = false;
            maxSpeedReached = 0;        // ADD THIS LINE - Reset max speed tracking
            updateSpeedIndicator();
            
            // Debug log to confirm reset
            console.log(`Game Reset - Speed: ${currentSpeed}, Obstacle Rate: ${currentObstacleSpawnRate}, Stream Rate: ${currentStreamSpawnRate}`);
        }
        
        // Check if it's a mobile device
        function checkMobile() {
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (isMobile) {
                // Show mobile instructions
                document.getElementById('mobileInstructions').style.display = 'inline';
                document.getElementById('touchArea').style.display = 'block';
                document.getElementById('swipeInstructions').style.display = 'block';
                
                // Adjust jump threshold based on screen size for better responsiveness
                const screenHeight = window.innerHeight;
                jumpSwipeThreshold = Math.max(20, Math.min(30, screenHeight / 40));
                swipeThreshold = Math.max(30, Math.min(40, screenHeight / 30));
            }
        }

// Mobile performance settings - define after checkMobile() is called
        let mobileSparkleCount = isMobile ? 8 : 20;        // Fewer sparkles on mobile
        let mobileExplosionCount = isMobile ? 15 : 30;     // Fewer explosion particles
        let mobileWeatherCount = isMobile ? 150 : 500;     // Much fewer weather particles
        let mobileButterflyLimit = isMobile ? 3 : 10;      // Fewer butterflies
        let mobileBirdsLimit = isMobile ? 2 : 5;           // Fewer birds


// ==================== MOBILE CONTROLS ====================
// Touch controls, swipe gestures, and mobile input handling
// Dependencies: Game Loop, Player Controls
// Functions: setupMobileControls(), handleTouch(), etc.

        
        // Setup mobile touch controls with swipe gestures
        function setupMobileControls() {
            const touchArea = document.getElementById('touchArea');
            
            // Simplified swipe detection to prevent freezing
            let lastTouchY = 0;
            
            touchArea.addEventListener('touchstart', function(e) {
                if (!gameStarted || gameOver || gamePaused) return;
                
                e.preventDefault();
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                lastTouchY = touchStartY;
                touchStartTime = Date.now();
            });
            
            touchArea.addEventListener('touchend', function(e) {
                if (!gameStarted || gameOver || gamePaused) return;
                
                e.preventDefault();
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                const touchTime = Date.now() - touchStartTime;
                
                // Simple, reliable swipe detection
                if (touchTime < 300) { // Short swipe = faster response
                    const deltaX = touchEndX - touchStartX;
                    const deltaY = touchStartY - touchEndY; // Note: reversed for Y
                    
                    // Simple thresholds
                    const minSwipeDistance = 30;
                    
                    // Determine primary direction of swipe
                    if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > minSwipeDistance) {
                        // Horizontal swipe
                        if (deltaX > 0) {
                            moveRight();
                        } else {
                            moveLeft();
                        }
                    } 
                    else if (Math.abs(deltaY) > Math.abs(deltaX) && Math.abs(deltaY) > minSwipeDistance) {
                        // Vertical swipe
                        if (deltaY > 0 && !jumping) {
                            // Swipe up to jump (only if not already jumping)
                            jump();
                        } else if (deltaY < 0) {
                            // Swipe down to quick drop
                            quickDrop();
                        }
                    }
                }
            });
        }
        
// ==================== GAME INITIALIZATION ====================
// Core game setup and initialization functions
// Dependencies: THREE.js, Audio System, Object Pools
// Functions: init(), setupGame(), initializeGameElements(), etc.

        // Initialize the game
        function init() {

// Add loading class to prevent UI flash
document.body.classList.add('loading');

            // Check if it's a mobile device FIRST
            checkMobile();

            // In your initialization code
document.addEventListener('DOMContentLoaded', function() {

    // Initialize daily challenges
    initializeDailyChallenges();
    
// When game starts
maxSpeedReached = currentSpeedLevel || 0;

});

// Initialize audio system
    initializeAudio();

    

// Background music system
let backgroundMusic = null;
let musicPlaying = false;
let musicLayers = [];
let currentMusicIntensity = 0;
let targetMusicIntensity = 0;

    // Set initial game state
gameState = "title";

// Hide the original start screen
document.getElementById('startScreen').style.display = 'none';


// Show the new title screen
document.getElementById('titleScreen').style.display = 'flex';
document.getElementById('titleScreen').classList.add('active');
// Initialize advanced particle system
setTimeout(() => {
    createTitleParticles();
}, 100);
console.log('New title screen should be visible now');

// Add particle burst effects on clicks
document.addEventListener('click', (e) => {
    if (gameState === "title" && titleParticleSystem) {
        titleParticleSystem.burst(e.clientX, e.clientY, 'rgba(67, 203, 255, 0.8)');
    }
});
            
            // Initialize new save system
initializeSaveSystem();

// Initialize world system
selectedWorldIndex = availableWorlds.findIndex(w => w.id === currentWorld);
if (selectedWorldIndex === -1) selectedWorldIndex = 0;

// Legacy: Load leaderboard data (will be migrated to profiles)
loadLeaderboard();

// Initialize object pools for performance
initializeObjectPools();
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue background
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 5);
            camera.lookAt(0, 0, -10);
            
            // Create renderer
renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.domElement.style.cssText = `
    display: none;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    pointer-events: auto;
`;
document.body.appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            skyLight = new THREE.DirectionalLight(0xffffff, 0.8);
            skyLight.position.set(10, 20, 0);
            scene.add(skyLight);
            
            // Load textures
            loadTextures();
            
            // Create ground with grass texture
            createGround();
            
            // Create background scenery
            createBackground();
            
            // Create player based on selected character
            createPlayer();
            
            // Add weather systems
            initializeWeatherSystems();
            
            // Initialize dynamic difficulty
            resetDynamicDifficulty();
            
            // Add event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);
            
            // Setup click outside to close settings
            document.getElementById('modalOverlay').addEventListener('click', closeSettingsScreen);
            
            // Setup tab switching in settings
            document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', function() {
                    // Remove active class from all tabs
                    document.querySelectorAll('.tab-button').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    
                    // Add active class to clicked tab
                    this.classList.add('active');
                    const tabId = this.getAttribute('data-tab');
                    document.getElementById(tabId).classList.add('active');
                });
            });
            
            // Update leaderboard display
            updateLeaderboardDisplay();
            
            

            // Setup settings UI
            setupSettingsUI();

            // Main menu settings event listeners
            document.getElementById('mainMenuModButton').onclick = toggleMainMenuModMode;
            document.getElementById('mainMenuResetDataButton').onclick = resetGameData;
            document.getElementById('mainMenuApplyDifficultyButton').onclick = applyMainMenuDifficultyOverride;
            
            // Use onclick instead of addEventListener for more reliability
            document.getElementById('startButton').onclick = startGame;
            document.getElementById('restartButton').onclick = restartGame;
            document.getElementById('gameOverSettingsBtn').onclick = toggleSettingsFromGameOver;
            document.getElementById('resumeButton').onclick = togglePause;
            document.getElementById('pauseRestartButton').onclick = restartFromPause;
            document.getElementById('pauseSettingsBtn').onclick = toggleSettingsFromPause;
            document.getElementById('pauseMainMenuBtn').onclick = returnToMainMenuFromPause;
            document.getElementById('pauseBtn').onclick = togglePause;
            document.getElementById('closeSettingsButton').onclick = closeSettingsScreen;
            document.getElementById('saveScoreButton').onclick = saveHighScore;
            document.getElementById('gameOverMainMenuBtn').onclick = returnToMainMenuFromGameOver;



document.getElementById('soundEffectsCheckbox').addEventListener('change', function() {
    soundEffectsEnabled = this.checked;
    saveGameData('settings_change');
});



document.getElementById('backgroundMusicCheckbox').addEventListener('change', function() {
    backgroundMusicEnabled = this.checked;
    if (!backgroundMusicEnabled && musicPlaying) {
        stopBackgroundMusic();
    } else if (backgroundMusicEnabled && gameStarted && !gameOver && !gamePaused) {
        if (!backgroundMusic) {
            createBackgroundMusic();
        }
        startBackgroundMusic();
    }
    saveGameData('settings_change');
});
            
            // Add mobile touch controls if needed
            if (isMobile) {
                setupMobileControls();
            }
            
            // Update the total coins display
            updateTotalCoins();

            
            // Start animation loop
            animate();

// Remove loading class after initialization
setTimeout(() => {
    document.body.classList.remove('loading');
}, 100);

        }



        // Advanced Canvas-based Particle System (matches new menu)
class TitleParticleSystem {
    constructor() {
        this.canvas = null;
        this.ctx = null;
        this.particles = [];
        this.mouse = { x: 0, y: 0 };
        this.animationId = null;
        this.initialized = false;
    }
    
    init() {
        if (this.initialized) return;
        
        this.canvas = document.getElementById('particle-canvas');
        if (!this.canvas) {
            console.log('⚠️ Particle canvas not found');
            return;
        }
        
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        
        // Mouse tracking for interactive effects
        window.addEventListener('mousemove', (e) => {
            this.mouse.x = e.clientX;
            this.mouse.y = e.clientY;
        });
        
        window.addEventListener('resize', () => this.resize());
        
        this.createParticles();
        this.animate();
        this.initialized = true;
        
        console.log('✨ Advanced particle system initialized!');

        // Reset challenge tracking variables
function resetChallengeTracking() {
    coinsCollectedThisRun = 0;
    jumpCount = 0;
    powerupsCollectedThisRun = 0;
    laneChangeCount = 0;
    survivalTime = 0;
    nearMissCount = 0;
    gameStartTime = Date.now();
    maxSpeedReached = speedLevel || 1; // Start with current speed level
}

// Call this when starting a new game
function startGame() {
    // Your existing start game code...
    resetChallengeTracking();
    gameStartTime = Date.now(); // Track when game started
}
    }
    
    resize() {
        if (!this.canvas) return;
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        console.log('🔧 Canvas resized to:', this.canvas.width, 'x', this.canvas.height);
    }
    
    createParticles() {
        this.particles = [];
        const particleCount = Math.floor((window.innerWidth * window.innerHeight) / 15000);
        
        for (let i = 0; i < particleCount; i++) {
            this.particles.push({
                x: Math.random() * window.innerWidth,
                y: Math.random() * window.innerHeight,
                vx: (Math.random() - 0.5) * 0.5,
                vy: (Math.random() - 0.5) * 0.5,
                size: Math.random() * 2 + 1,
                opacity: Math.random() * 0.4 + 0.1,
                color: this.getParticleColor(i),
                originalOpacity: Math.random() * 0.4 + 0.1,
                pulseSpeed: Math.random() * 0.02 + 0.01,
                pulsePhase: Math.random() * Math.PI * 2
            });
        }
    }
    
    getParticleColor(index) {
        const colors = [
            'rgba(79, 172, 254, 0.8)',  // Blue
            'rgba(67, 203, 255, 0.7)',  // Light blue
            'rgba(0, 242, 254, 0.6)',   // Cyan
            'rgba(151, 8, 204, 0.5)',   // Purple
            'rgba(78, 205, 196, 0.6)',  // Teal
            'rgba(255, 107, 107, 0.5)', // Pink
            'rgba(255, 217, 61, 0.4)'   // Yellow
        ];
        return colors[index % colors.length];
    }
    
    animate() {
    // Only stop particles during actual gameplay
    if (gameState === "playing" || gameState === "paused" || gameState === "gameOver") {
        console.log('🛑 Particles stopped for gameplay, gameState:', gameState);
        this.animationId = null;
        return;
    }

    // Make sure canvas is still in the document
if (this.canvas && this.canvas.parentElement === null) {
    console.log('⚠️ Canvas was removed from DOM, re-adding...');
    document.body.appendChild(this.canvas);
}
    
    if (!this.ctx || !this.canvas) {
        console.log('❌ No canvas or context available');
        return;
    }
    
// console.log('🎨 Drawing particles:', this.particles.length, 'gameState:', gameState);    
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.particles.forEach((particle, index) => {
            // Move particles
            particle.x += particle.vx;
            particle.y += particle.vy;
            
            // Mouse interaction - attraction effect
            const dx = this.mouse.x - particle.x;
            const dy = this.mouse.y - particle.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 100) {
                const force = (100 - distance) / 100;
                particle.vx += dx * force * 0.001;
                particle.vy += dy * force * 0.001;
            }
            
            // Boundary wrapping
            if (particle.x < 0) particle.x = this.canvas.width;
            if (particle.x > this.canvas.width) particle.x = 0;
            if (particle.y < 0) particle.y = this.canvas.height;
            if (particle.y > this.canvas.height) particle.y = 0;
            
            // Pulsing effect
            particle.opacity = particle.originalOpacity + Math.sin(Date.now() * particle.pulseSpeed + particle.pulsePhase) * 0.2;
            
            // Draw particle with glow
            this.ctx.beginPath();
            this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            
            // Glow effect
            this.ctx.shadowColor = particle.color;
            this.ctx.shadowBlur = particle.size * 3;
            this.ctx.fillStyle = particle.color;
            this.ctx.globalAlpha = particle.opacity;
            this.ctx.fill();
            this.ctx.shadowBlur = 0;
            
            // Connect nearby particles with lines
            this.particles.slice(index + 1).forEach(otherParticle => {
                const dx = particle.x - otherParticle.x;
                const dy = particle.y - otherParticle.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 100) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(particle.x, particle.y);
                    this.ctx.lineTo(otherParticle.x, otherParticle.y);
                    this.ctx.strokeStyle = particle.color;
                    this.ctx.globalAlpha = (100 - distance) / 100 * 0.3;
                    this.ctx.lineWidth = 0.5;
                    this.ctx.stroke();
                }
            });
        });
        
        this.ctx.globalAlpha = 1;
        
        // Keep animating unless we're in gameplay states
if (gameState !== "playing" && gameState !== "paused" && gameState !== "gameOver") {
    this.animationId = requestAnimationFrame(() => this.animate());
} else {
    this.animationId = null;
}
    }
    
    burst(x, y, color = 'rgba(67, 203, 255, 0.8)') {
        for (let i = 0; i < 15; i++) {
            this.particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 12,
                vy: (Math.random() - 0.5) * 12,
                size: Math.random() * 4 + 2,
                opacity: 1,
                color: color,
                life: 80,
                originalOpacity: 1,
                pulseSpeed: 0.1,
                pulsePhase: 0,
                burst: true
            });
        }
    }
    
    destroy() {
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
    }
}

// Global particle system instance
let titleParticleSystem = null;

function debugParticles() {
    console.log('🔍 Particle Debug:', {
        gameState: gameState,
        particleSystem: !!titleParticleSystem,
        animationId: titleParticleSystem?.animationId,
        canvas: !!document.getElementById('particle-canvas'),
        canvasDisplay: document.getElementById('particle-canvas')?.style.display,
        canvasVisibility: document.getElementById('particle-canvas')?.style.visibility,
        canvasOpacity: document.getElementById('particle-canvas')?.style.opacity
    });
}

function debugParticleState() {
    const canvas = document.getElementById('particle-canvas');
    console.log('🔍 Particle State Debug:', {
        gameState: gameState,
        system: !!titleParticleSystem,
        animating: titleParticleSystem?.animationId,
        canvas: !!canvas,
        canvasParent: canvas?.parentElement?.id || 'no parent',
        canvasDisplay: canvas?.style.display,
        canvasVisibility: canvas?.style.visibility,
        canvasOpacity: canvas?.style.opacity,
        canvasZIndex: canvas?.style.zIndex
    });
}

// Nuclear option - completely destroy all particles
function nuclearParticleCleanup() {
    console.log('☢️ NUCLEAR PARTICLE CLEANUP');
    
    // Destroy the particle system completely
    if (titleParticleSystem) {
        titleParticleSystem.destroy();
        titleParticleSystem = null;
    }
    
    // Find and remove ALL particle canvases
    const allCanvases = document.querySelectorAll('canvas');
    allCanvases.forEach(canvas => {
        if (canvas.id === 'particle-canvas') {
            canvas.remove();
            console.log('🗑️ Removed particle canvas');
        }
    });
    
    // Cancel any particle animation frames
    if (window.titleParticleAnimationId) {
        cancelAnimationFrame(window.titleParticleAnimationId);
        window.titleParticleAnimationId = null;
    }
    
    console.log('✅ Nuclear cleanup complete');
}

// Force recreate particle system for main menu
function forceRecreateParticles() {
    console.log('🔄 Force recreating particle system...');
    
    // Destroy existing system
    if (titleParticleSystem) {
        titleParticleSystem.destroy();
        titleParticleSystem = null;
    }
    
    // Remove existing canvas
    const existingCanvas = document.getElementById('particle-canvas');
    if (existingCanvas) {
        existingCanvas.remove();
    }
    
    // Create fresh canvas
    const canvas = document.createElement('canvas');
    canvas.id = 'particle-canvas';
    canvas.style.cssText = `
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100% !important;
    height: 100% !important;
    pointer-events: none !important;
    z-index: 2 !important;
    display: block !important;
    opacity: 1 !important;
    visibility: visible !important;
`;
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Add to document
    document.body.appendChild(canvas);
    
    // Create new particle system
    titleParticleSystem = new TitleParticleSystem();
    titleParticleSystem.init();
    
    console.log('✅ Fresh particle system created and started');
}

// Initialize title particles
function createTitleParticles() {
    if (!titleParticleSystem) {
        titleParticleSystem = new TitleParticleSystem();
    }
    titleParticleSystem.init();
    
    // Force immediate animation start
    if (!titleParticleSystem.animationId) {
        titleParticleSystem.animate();
    }
    
    console.log('🎨 Title particles created and started');
}



// Force particle visibility on main menu
function ensureParticlesVisible() {
    const canvas = document.getElementById('particle-canvas');
    if (canvas) {
        canvas.style.cssText = `
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            pointer-events: none !important;
            z-index: 999 !important;
            display: block !important;
            opacity: 1 !important;
            visibility: visible !important;
        `;
        
        // CRITICAL: Fix canvas internal dimensions
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Force particle system resize
        if (titleParticleSystem && titleParticleSystem.resize) {
            titleParticleSystem.resize();
        }
        
        // Restart particles if system exists but not animating
        if (titleParticleSystem && !titleParticleSystem.animationId) {
            titleParticleSystem.animate();
        }
        
        console.log('🔧 Forced particle visibility with canvas size:', canvas.width, 'x', canvas.height);
        return true;
    }
    console.error('❌ Cannot ensure particle visibility - canvas not found');
    return false;
}
        
// ==================== SETTINGS & UI SYSTEM ====================
// Settings menu, UI controls, and user interface management
// Dependencies: Character System, World System
// Functions: setupSettingsUI(), updateCharactersInSettings(), toggleSettings(), etc.

        // Setup settings UI
        function setupSettingsUI() {
// Initialize jukebox
    initializeJukebox();

        
        }

        // Initialize jukebox system
function initializeJukebox() {
    const jukeboxContainer = document.getElementById('jukeboxTracks');
    
    // Clear existing tracks
    jukeboxContainer.innerHTML = '';
    
    // Create track options
    availableTracks.forEach(track => {
        const trackElement = document.createElement('div');
        trackElement.className = 'track-option';
        trackElement.dataset.trackId = track.id;
        
        // Add selected class if this is the current track
        if (track.id === selectedTrack) {
            trackElement.classList.add('selected');
        }
        
        // Set track icon based on type
        let trackIcon = '🎵';
        if (track.id === 'medieval') trackIcon = '⚔️';
        else if (track.id === 'electronic') trackIcon = '🌈';
        else if (track.id === 'ambient') trackIcon = '🌌';
        
        trackElement.innerHTML = `
            <div class="track-icon">${trackIcon}</div>
            <div class="track-info">
                <div class="track-name">${track.name}</div>
                <div class="track-description">${track.description}</div>
            </div>
            <div class="track-status ${track.id === currentTrack ? 'track-playing' : (track.id === selectedTrack ? 'track-selected' : '')}" id="status-${track.id}">
                ${track.id === currentTrack ? 'Playing' : (track.id === selectedTrack ? 'Selected' : '')}
            </div>
        `;
        
        // Add click listener
        trackElement.addEventListener('click', () => selectTrack(track.id));
        
        jukeboxContainer.appendChild(trackElement);
    });
    
    // Add button listeners
    document.getElementById('previewTrackBtn').addEventListener('click', previewSelectedTrack);
    document.getElementById('applyTrackBtn').addEventListener('click', applySelectedTrack);
    
    console.log('🎵 Jukebox system initialized!');
}

// Select a track in the jukebox
function selectTrack(trackId) {
    selectedTrack = trackId;
    
    // Update UI
    document.querySelectorAll('.track-option').forEach(option => {
        option.classList.remove('selected');
        const status = option.querySelector('.track-status');
        if (option.dataset.trackId === currentTrack) {
            status.textContent = 'Playing';
            status.className = 'track-status track-playing';
        } else if (option.dataset.trackId === selectedTrack) {
            status.textContent = 'Selected';
            status.className = 'track-status track-selected';
        } else {
            status.textContent = '';
            status.className = 'track-status';
        }
    });
    
    // Add selected class to clicked track
    document.querySelector(`[data-track-id="${trackId}"]`).classList.add('selected');
    
    console.log(`🎵 Selected track: ${trackId}`);
}

// Preview the selected track
// Preview the selected track
function previewSelectedTrack() {
    console.log(`🎧 Previewing track: ${selectedTrack}`);
    
    // Stop any existing preview
    if (window.previewMusic && window.previewMusic.playing) {
        stopPreview();
    }
    
    // Don't preview if it's already the current track
    if (selectedTrack === currentTrack && musicPlaying) {
        console.log('🎵 Track already playing - no preview needed!');
        alert(`🎵 "${availableTracks.find(t => t.id === selectedTrack)?.name}" is already playing!`);
        return;
    }
    
    // Create and start preview
    startPreview(selectedTrack);
    
    // Update button text to show preview is playing
    const previewBtn = document.getElementById('previewTrackBtn');
    previewBtn.textContent = '⏹️ Stop Preview';
    previewBtn.onclick = stopPreview;
    
    // Auto-stop preview after 15 seconds
    if (window.previewTimeout) {
        clearTimeout(window.previewTimeout);
    }
    window.previewTimeout = setTimeout(() => {
        stopPreview();
    }, 15000); // 15 second preview
}

// Start preview of a specific track
function startPreview(trackId) {
    if (!audioInitialized) {
        alert('🔇 Audio not ready yet! Try clicking the start button first.');
        return;
    }
    
    try {
        console.log(`🎧 Starting preview of: ${trackId}`);
        
        // Create preview music layers
        window.previewMusic = {
            layers: [],
            playing: true,
            trackId: trackId
        };
        
        // Create preview music based on track
        if (trackId === 'medieval') {
            createPreviewMedieval();
        } else if (trackId === 'electronic') {
            createPreviewElectronic();
        } else if (trackId === 'ambient') {
            createPreviewAmbient();
        }
        
        // Start all preview patterns
        window.previewMusic.layers.forEach(layer => {
            if (layer.pattern) {
                layer.pattern.start(0);
            }
        });
        
        // Start transport if not already running
        if (Tone.Transport.state !== 'started') {
            Tone.Transport.start();
        }
        
        console.log(`✅ Preview started for: ${availableTracks.find(t => t.id === trackId)?.name}`);
        
    } catch (error) {
        console.error('❌ Error starting preview:', error);
        alert('❌ Error starting preview! Check console for details.');
    }
}

// Stop preview
function stopPreview() {
    console.log('🛑 Stopping preview...');
    
    if (window.previewMusic && window.previewMusic.layers) {
        // Stop and dispose all preview patterns
        window.previewMusic.layers.forEach(layer => {
            if (layer.pattern) {
                layer.pattern.stop();
                layer.pattern.dispose();
            }
            if (layer.synth && layer.synth.dispose) {
                layer.synth.dispose();
            }
        });
        
        window.previewMusic = null;
    }
    
    // Clear timeout
    if (window.previewTimeout) {
        clearTimeout(window.previewTimeout);
        window.previewTimeout = null;
    }
    
    // Reset button
    const previewBtn = document.getElementById('previewTrackBtn');
    previewBtn.textContent = '🎧 Preview';
    previewBtn.onclick = previewSelectedTrack;
    
    console.log('✅ Preview stopped');
}

// Preview versions of each track (shorter, simpler versions)
function createPreviewMedieval() {
    console.log('🎧 Creating medieval preview...');
    
    // Just drums and lute for preview
    const drumSynth = new Tone.MembraneSynth({
        pitchDecay: 0.08,
        octaves: 12,
        oscillator: { type: "sine" },
        envelope: { attack: 0.01, decay: 0.6, sustain: 0.1, release: 2.0 }
    }).toDestination();
    
    const drumPattern = new Tone.Pattern((time, note) => {
        drumSynth.triggerAttackRelease(note, "4n", time);
    }, ["C1", "C1", "G1", "C1"], "up");
    
    drumPattern.interval = "2n";
    drumSynth.volume.value = -10;
    
    const luteSynth = new Tone.Synth({
        oscillator: { type: "triangle" },
        envelope: { attack: 0.02, decay: 0.4, sustain: 0.3, release: 0.8 }
    }).toDestination();
    
    const lutePattern = new Tone.Pattern((time, note) => {
        luteSynth.triggerAttackRelease(note, "8n", time);
    }, ["D3", "F3", "A3", "D4"], "up");
    
    lutePattern.interval = "4n";
    luteSynth.volume.value = -12;
    
    window.previewMusic.layers = [
        { name: "drums", pattern: drumPattern, synth: drumSynth },
        { name: "lute", pattern: lutePattern, synth: luteSynth }
    ];
}

function createPreviewElectronic() {
    console.log('🎧 Creating electronic preview...');
    
    // Kick and lead synth for preview
    const kickSynth = new Tone.MembraneSynth({
        pitchDecay: 0.05,
        octaves: 10,
        oscillator: { type: "sine" },
        envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4 }
    }).toDestination();
    
    const kickPattern = new Tone.Pattern((time, note) => {
        kickSynth.triggerAttackRelease(note, "8n", time);
    }, ["C1", "C1", "C1", "C1"], "up");
    
    kickPattern.interval = "4n";
    kickSynth.volume.value = -8;
    
    const leadSynth = new Tone.Synth({
        oscillator: { type: "square" },
        envelope: { attack: 0.05, decay: 0.3, sustain: 0.4, release: 1.0 }
    }).toDestination();
    
    const leadPattern = new Tone.Pattern((time, note) => {
        leadSynth.triggerAttackRelease(note, "8n", time);
    }, ["A4", "C5", "E5", "G5"], "up");
    
    leadPattern.interval = "8n";
    leadSynth.volume.value = -10;
    
    // Set faster tempo for electronic music
    Tone.Transport.bpm.value = 128;
    
    window.previewMusic.layers = [
        { name: "kick", pattern: kickPattern, synth: kickSynth },
        { name: "lead", pattern: leadPattern, synth: leadSynth }
    ];
}

function createPreviewAmbient() {
    console.log('🎧 Creating ambient preview...');
    
    // Drone and bells for preview
    const droneSynth = new Tone.Synth({
        oscillator: { type: "sine" },
        envelope: { attack: 2.0, decay: 1.0, sustain: 0.8, release: 3.0 }
    }).toDestination();
    
    const dronePattern = new Tone.Pattern((time, note) => {
        droneSynth.triggerAttackRelease(note, "2n", time);
    }, ["C2", "G2"], "up");
    
    dronePattern.interval = "1n";
    droneSynth.volume.value = -8;
    
    const bellSynth = new Tone.MetalSynth({
        frequency: 200,
        envelope: { attack: 0.001, decay: 1.0, release: 2.0 },
        harmonicity: 5.1,
        modulationIndex: 32,
        resonance: 4000,
        octaves: 1.5
    }).toDestination();
    
    const bellPattern = new Tone.Pattern((time, note) => {
        bellSynth.triggerAttackRelease(note, "4n", time);
    }, ["C4", "E4", "G4", "C5"], "up");
    
    bellPattern.interval = "2n";
    bellSynth.volume.value = -12;
    
    // Set slower tempo for ambient music
    Tone.Transport.bpm.value = 60;
    
    window.previewMusic.layers = [
        { name: "drone", pattern: dronePattern, synth: droneSynth },
        { name: "bells", pattern: bellPattern, synth: bellSynth }
    ];
}

// Apply the selected track
function applySelectedTrack() {
    if (selectedTrack === currentTrack) {
        console.log('🎵 Track already playing!');
        return;
    }
    
    console.log(`🎵 Switching from ${currentTrack} to ${selectedTrack}`);
    
    // Stop current music
    if (musicPlaying) {
        stopBackgroundMusic();
    }
    
    // Update current track
    currentTrack = selectedTrack;
    
    // Recreate music with new track
    createBackgroundMusic();
    
    // Start new music if game is playing and music is enabled
    if (gameStarted && !gameOver && !gamePaused && backgroundMusicEnabled) {
        startBackgroundMusic();
    }
    
    // Update UI
    initializeJukebox();
    
    // Save preference
    saveGameData('settings_change');
    
    console.log(`✅ Successfully switched to: ${availableTracks.find(t => t.id === currentTrack)?.name}`);
}
        
// Leaderboard functions - Updated with data preservation
function mergeLeaderboards() {
    // Get data from both keys
    const oldLeaderboard = JSON.parse(localStorage.getItem('endlessRunnerLeaderboard') || '[]');
    const newLeaderboard = JSON.parse(localStorage.getItem('runningBlitzLeaderboard') || '[]');
    
    // Combine both arrays
    const combinedLeaderboard = [...oldLeaderboard, ...newLeaderboard];
    
    // Remove duplicates and sort by score
    const uniqueLeaderboard = combinedLeaderboard
        .filter((entry, index, self) => 
            index === self.findIndex(e => e.name === entry.name && e.score === entry.score && e.date === entry.date)
        )
        .sort((a, b) => b.score - a.score)
        .slice(0, 10); // Keep only top 10
    
    // Save to both keys for compatibility
    localStorage.setItem('runningBlitzLeaderboard', JSON.stringify(uniqueLeaderboard));
    localStorage.setItem('endlessRunnerLeaderboard', JSON.stringify(uniqueLeaderboard));
    
    console.log('Leaderboards merged:', uniqueLeaderboard);
    return uniqueLeaderboard;
}

function loadLeaderboard() {
    // First merge any existing data
    const mergedData = mergeLeaderboards();
    leaderboard = mergedData;
    
    // Get current high score
    if (leaderboard.length > 0) {
        currentHighScore = leaderboard[0].score;
    }
}

function saveLeaderboard() {
    // Save to both keys for compatibility
    localStorage.setItem('runningBlitzLeaderboard', JSON.stringify(leaderboard));
    localStorage.setItem('endlessRunnerLeaderboard', JSON.stringify(leaderboard));
}

function updateLeaderboardDisplay() {
    // Always merge fresh data when displaying
    const currentLeaderboard = mergeLeaderboards();
    
    const leaderboardBody = document.getElementById('leaderboardBody');
    leaderboardBody.innerHTML = '';
    
    if (currentLeaderboard.length === 0) {
        const row = document.createElement('tr');
        row.innerHTML = `<td colspan="4" style="text-align: center;">No high scores yet!</td>`;
        leaderboardBody.appendChild(row);
        return;
    }
    
    currentLeaderboard.forEach((entry, index) => {
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${index + 1}</td>
            <td>${entry.name}</td>
            <td>${entry.score}</td>
            <td>${entry.character || 'Unknown'}</td>
        `;
        leaderboardBody.appendChild(row);
    });
}

function formatDate(dateString) {
    const date = new Date(dateString);
    return date.toLocaleDateString();
}


        
        function saveHighScore() {
    const playerName = document.getElementById('playerNameInput').value.trim() || 'Anonymous';
    const currentScore = score;
    
    // Get existing leaderboard
    let leaderboard = JSON.parse(localStorage.getItem('runningBlitzLeaderboard') || '[]');
    
    // Add new score
    leaderboard.push({
        name: playerName,
        score: currentScore,
        character: currentCharacter,
        date: new Date().toLocaleDateString()
    });
    
    // Sort by score (highest first)
    leaderboard.sort((a, b) => b.score - a.score);
    
    // Keep only top 10
    leaderboard = leaderboard.slice(0, 10);
    
    // Save back to localStorage
    localStorage.setItem('runningBlitzLeaderboard', JSON.stringify(leaderboard));
    
    // Hide name entry section
    document.getElementById('newHighScoreMessage').style.display = 'none';
    
    // Clear the input for next time
    document.getElementById('playerNameInput').value = '';
    
    console.log('Score saved to leaderboard!', leaderboard);

    // ADD THIS LINE - Submit to global leaderboard
    submitToGlobalLeaderboard(playerName, currentScore, currentCharacter);
    
    // Save profile with high score reason - THIS WILL SHOW THE SAVE INDICATOR
    saveGameData('high_score');
    
    // Optional: Show confirmation
    alert(`Score saved! ${playerName}: ${currentScore} points`);
}

// Allow Enter key to save score
document.getElementById('playerNameInput').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        document.getElementById('saveScoreButton').click();
    }
});

// ===== GLOBAL LEADERBOARD SYSTEM =====
let globalLeaderboard = [];
let playerGlobalRank = null;

// Submit score to global leaderboard
function submitToGlobalLeaderboard(playerName, score, character) {
    if (!cloudSaveEnabled || !playerId) {
        console.log('⚠️ Cannot submit to global leaderboard - cloud save not available');
        return;
    }
    
    const globalEntry = {
        playerId: playerId,
        playerName: playerName,
        score: score,
        character: character,
        timestamp: Date.now(),
        date: new Date().toLocaleDateString(),
        country: 'Unknown' // We'll add geolocation later
    };
    
    // Submit to Firebase global leaderboard
    firebase.database().ref('globalLeaderboard').push(globalEntry)
        .then(() => {
            console.log('🏆 Score submitted to global leaderboard!');
            loadGlobalLeaderboard(); // Refresh to see new rankings
        })
        .catch((error) => {
            console.error('❌ Failed to submit to global leaderboard:', error);
        });
}

// Load global leaderboard from Firebase
function loadGlobalLeaderboard() {
    if (!cloudSaveEnabled) return;
    
    firebase.database().ref('globalLeaderboard')
        .orderByChild('score')
        .limitToLast(100) // Get top 100 scores
        .once('value')
        .then((snapshot) => {
            const data = snapshot.val();
            
            if (data) {
                // Convert to array and sort by score (highest first)
                globalLeaderboard = Object.values(data)
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 50); // Keep top 50
                
                console.log(`🌍 Loaded ${globalLeaderboard.length} global scores`);
                
                // Find player's rank
                findPlayerGlobalRank();
            } else {
                globalLeaderboard = [];
                console.log('🌍 No global scores found - be the first!');
            }
        })
        .catch((error) => {
            console.error('❌ Failed to load global leaderboard:', error);
        });
}

// Find current player's rank in global leaderboard
function findPlayerGlobalRank() {
    if (!playerId) return;
    
    playerGlobalRank = null;
    
    for (let i = 0; i < globalLeaderboard.length; i++) {
        if (globalLeaderboard[i].playerId === playerId) {
            playerGlobalRank = i + 1; // Rank is index + 1
            break;
        }
    }
    
    if (playerGlobalRank) {
        console.log(`🏆 Your global rank: #${playerGlobalRank}`);
    }
}

// Show global leaderboard popup
function showGlobalLeaderboard() {
    loadGlobalLeaderboard(); // Refresh data first
    
    setTimeout(() => { // Wait for data to load
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center;
            z-index: 10000; font-family: Arial, sans-serif;
        `;
        
        let leaderboardHTML = `
            <div style="
                background: rgba(0, 20, 40, 0.95);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.2);
                padding: 30px;
                border-radius: 20px;
                max-width: 500px;
                max-height: 80vh;
                overflow-y: auto;
                text-align: center;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            ">
                <h2 style="color: white; margin-bottom: 20px; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">
                    🌍 Global Leaderboard
                </h2>
        `;
        
        if (globalLeaderboard.length === 0) {
            leaderboardHTML += `
                <p style="color: white; font-size: 18px; margin: 40px 0;">
                    🏆 Be the first player on the global leaderboard!<br>
                    <small style="color: #ccc;">Play a game and your score will appear here!</small>
                </p>
            `;
        } else {
            // Show player's rank if they have one
            if (playerGlobalRank) {
                leaderboardHTML += `
                    <div style="background: rgba(255, 215, 0, 0.2); border: 1px solid #FFD700; border-radius: 10px; padding: 15px; margin-bottom: 20px;">
                        <p style="color: #FFD700; font-size: 16px; margin: 0;">
                            🏆 Your Global Rank: #${playerGlobalRank}
                        </p>
                    </div>
                `;
            }
            
            leaderboardHTML += `
                <div style="text-align: left; max-height: 400px; overflow-y: auto;">
            `;
            
            // Display top scores
            globalLeaderboard.slice(0, 20).forEach((entry, index) => {
                const rank = index + 1;
                const isCurrentPlayer = entry.playerId === playerId;
                
                let rankEmoji = '🏅';
                if (rank === 1) rankEmoji = '🥇';
                else if (rank === 2) rankEmoji = '🥈';
                else if (rank === 3) rankEmoji = '🥉';
                
                const bgColor = isCurrentPlayer ? 'rgba(0, 255, 0, 0.1)' : 'rgba(255, 255, 255, 0.05)';
                const textColor = isCurrentPlayer ? '#00FF00' : 'white';
                
                leaderboardHTML += `
                    <div style="
                        background: ${bgColor};
                        border: 1px solid rgba(255, 255, 255, 0.1);
                        border-radius: 8px;
                        padding: 12px;
                        margin: 8px 0;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    ">
                        <span style="color: ${textColor}; font-weight: bold;">
                            ${rankEmoji} #${rank} ${entry.playerName || 'Anonymous'}
                        </span>
                        <div style="text-align: right;">
                            <div style="color: ${textColor}; font-size: 18px; font-weight: bold;">
                                ${entry.score.toLocaleString()}
                            </div>
                            <div style="color: #ccc; font-size: 12px;">
                                ${entry.character} • ${entry.date}
                            </div>
                        </div>
                    </div>
                `;
            });
            
            leaderboardHTML += `</div>`;
            
            // Show total players
            leaderboardHTML += `
                <p style="color: #ccc; font-size: 14px; margin-top: 20px;">
                    🌍 ${globalLeaderboard.length} players competing worldwide!
                </p>
            `;
        }
        
        leaderboardHTML += `
                <button onclick="this.parentElement.parentElement.remove()" 
                    style="background: #007AFF; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 16px; margin-top: 20px;">
                    Close
                </button>
            </div>
        `;
        
        modal.innerHTML = leaderboardHTML;
        document.body.appendChild(modal);
    }, 1000); // Give time for data to load
}

        
        // Update character display in settings
        function updateCharactersInSettings() {
            // Reset all selections
            document.querySelectorAll('#characterSelect .character-option').forEach(option => {
                option.classList.remove('selected');
            });
            
            // Mark current character as selected
            document.getElementById(`${currentCharacter}-option`).classList.add('selected');
            
            // Update cost displays
            for (const character in characterCosts) {
                const costElement = document.getElementById(`${character}-cost`);
                if (costElement) {
                    if (unlockedCharacters[character]) {
                        costElement.textContent = 'Unlocked';
                    } else {
                        costElement.textContent = `Cost: ${characterCosts[character]} coins`;
                    }
                }
            }
        }
        
        // Weather systems with smooth transitions
        function initializeWeatherSystems() {
            // Initialize with clear weather
            currentWeather = "clear";
            targetWeather = "clear";
            weatherTransitionProgress = 1; // Fully transitioned to start
            
            setWeather("clear");
        }
        
        function setWeather(weatherType) {
            // Start transition to new weather
            targetWeather = weatherType;
            weatherTransitionProgress = 0;
            
            // If no current weather particles exist, instantly create the new weather
            if (weatherParticles.length === 0 && weatherType !== "clear") {
                if (weatherType === "rain") {
                    createRainSystem();
                } else if (weatherType === "snow") {
                    createSnowSystem();
                }
            }
            
            // Reset weather change counter
            weatherChangeCounter = 0;
        }
        



        // ==================== CHARACTER SELECTION SYSTEM ====================
// Character selection screen and character preview functionality
// Dependencies: characters.js, THREE.js
// Functions: initCharacterSelectScreen(), selectCharacter(), previewCharacter(), etc.

        // Initialize Character Selection Screen
function initCharacterSelectScreen() {
    // Clear existing canvas content
    const selectCanvas = document.getElementById('characterSelectCanvas');
    if (selectCanvas) {
        selectCanvas.innerHTML = '';
    }
    
    // Use the character display div directly
    const characterDisplay = document.getElementById('characterDisplay');
    if (!characterDisplay) {
        console.error('Character display element not found!');
        return;
    }
    
    // Clear previous content
    characterDisplay.innerHTML = '';
    
    // Create a new scene for character display
    const characterSelectScene = new THREE.Scene();
    characterSelectScene.background = null; // Transparent to show glassmorphism background
    
    // Create a camera
    const selectCamera = new THREE.PerspectiveCamera(75, 400 / 400, 0.1, 1000);
    selectCamera.position.set(0, 0, 3);
    
    // Create a renderer that fits in the preview box
    const characterSelectRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    characterSelectRenderer.setSize(400, 400);
    characterSelectRenderer.setClearColor(0x000000, 0);
    
    // Add renderer to the character display div
    characterDisplay.appendChild(characterSelectRenderer.domElement);
    
    // Store references globally
    window.characterSelectScene = characterSelectScene;
    window.selectCamera = selectCamera;
    window.characterSelectRenderer = characterSelectRenderer;
    
    // Add lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    characterSelectScene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    characterSelectScene.add(directionalLight);
    
    // Create background effects
    createBackgroundEffects(characterSelectScene);
    
    // Clear existing character models if they exist
    if (characterSelectModels && characterSelectModels.length > 0) {
        characterSelectModels.forEach(charObj => {
            if (charObj.model && charObj.model.parent) {
                charObj.model.parent.remove(charObj.model);
            }
        });
    }
    
    // Create all character models fresh
    characterSelectModels = [];
    
    characterNames.forEach(charType => {
        let charModel;
        
        try {
            switch (charType) {
                // CHARACTER SELECTION SWITCH INJECTION POINT - Package manager will add cases here
                case "apple": charModel = createAppleCharacter(); break;
                case "carrot": charModel = createCarrotCharacter(); break;
                case "pumpkin": charModel = createPumpkinCharacter(); break;
                case "happyface": charModel = createHappyFaceCharacter(); break;
                case "monster": charModel = createMonsterCharacter(); break;
                case "atom": charModel = createAtomCharacter(); break;
                case "slime": charModel = createSlimeCharacter(); break;
                case "ufo": charModel = createUFOCharacter(); break;
                case "robot": charModel = createRobotCharacter(); break;
                case "dragon": charModel = createDragonCharacter(); break;
                case "ghost": charModel = createGhostCharacter(); break;
                case "creature": charModel = createCreatureCharacter(); break;
                // END CHARACTER SELECTION SWITCH INJECTION POINT
                default:
                    console.warn(`Character ${charType} not yet extracted - using Happy Face`);
                    charModel = createHappyFaceCharacter();
                    break;
            }
            
            // Safety check
            if (!charModel) {
                console.error(`Failed to create character: ${charType}, using apple instead`);
                charModel = createAppleCharacter();
            }
            
            console.log(`✅ Created character: ${charType}`, charModel);
            
            // Scale and position
            charModel.scale.set(1.5, 1.5, 1.5);
            charModel.position.set(0, 0, 0);
            charModel.visible = false; // Hide all initially
            
            // Add to scene
            characterSelectScene.add(charModel);
            
            characterSelectModels.push({
                model: charModel,
                type: charType
            });
            
        } catch (error) {
            console.error(`❌ Error creating character ${charType}:`, error);
            
            // Fallback to apple character
            charModel = createAppleCharacter();
            charModel.scale.set(1.5, 1.5, 1.5);
            charModel.position.set(0, 0, 0);
            charModel.visible = false;
            characterSelectScene.add(charModel);
            
            characterSelectModels.push({
                model: charModel,
                type: charType
            });
        }
    });
    
    // Ensure selectedCharacterIndex is valid
    if (selectedCharacterIndex >= characterSelectModels.length) {
        selectedCharacterIndex = 0;
    }
    
    // Show the correct initial character
    characterSelectModels[selectedCharacterIndex].model.visible = true;
    updateCharacterInfo();
    
    // Ensure we start on an unlocked character
    if (!modModeEnabled && !unlockedCharacters[characterNames[selectedCharacterIndex]]) {
        // Find first unlocked character
        for (let i = 0; i < characterNames.length; i++) {
            if (unlockedCharacters[characterNames[i]]) {
                // Hide current model
                if (characterSelectModels[selectedCharacterIndex]) {
                    characterSelectModels[selectedCharacterIndex].model.visible = false;
                }
                
                // Switch to unlocked character
                selectedCharacterIndex = i;
                
                // Show new model
                if (characterSelectModels[selectedCharacterIndex]) {
                    characterSelectModels[selectedCharacterIndex].model.visible = true;
                }
                
                break;
            }
        }
    }
    
    // Update the display
    updateCharacterInfo();
    
    // Clear any existing animation loop
    if (window.characterSelectAnimationId) {
        cancelAnimationFrame(window.characterSelectAnimationId);
    }
    
    // Animation for character selection screen
    function animateCharacterSelect() {
        window.characterSelectAnimationId = requestAnimationFrame(animateCharacterSelect);
        
        if (gameState === "characterSelect") {
            // Rotate the displayed character
            if (characterSelectModels && characterSelectModels[selectedCharacterIndex]) {
                const currentModel = characterSelectModels[selectedCharacterIndex].model;
                const currentType = characterSelectModels[selectedCharacterIndex].type;
                
                // Basic rotation
                if (currentModel && currentModel.visible) {
                    currentModel.rotation.y += 0.01;
                    
                    // Apply specific character animations
                    animateCharacterModel(currentModel, currentType, frameCount);
                }
            }
            
            // Animate background elements
            if (window.characterSelectScene && window.characterSelectScene.userData.particles) {
                animateBackgroundEffects();
            }
            
            // Render
            if (window.characterSelectRenderer && window.characterSelectScene && window.selectCamera) {
                window.characterSelectRenderer.render(window.characterSelectScene, window.selectCamera);
            }
        }
    }
    
    // Start animation
    animateCharacterSelect();
    
    // Setup navigation button event listeners
    setupCharacterNavigation();
}

function setupCharacterNavigation() {
    // Remove any existing event listeners by cloning buttons
    const prevBtn = document.getElementById('prevCharacterBtn');
    const nextBtn = document.getElementById('nextCharacterBtn');
    const selectBtn = document.getElementById('selectCharacterButton');
    const startBtn = document.getElementById('startGameButton');
    
    if (prevBtn) {
        const newPrevBtn = prevBtn.cloneNode(true);
        prevBtn.parentNode.replaceChild(newPrevBtn, prevBtn);
        
        newPrevBtn.addEventListener('click', function() {
            // Hide current model
            if (characterSelectModels[selectedCharacterIndex]) {
                characterSelectModels[selectedCharacterIndex].model.visible = false;
            }
            
            // If mod mode is enabled, show all characters. Otherwise only show unlocked ones
            if (modModeEnabled) {
                // Simple navigation when mod mode is on
                selectedCharacterIndex = (selectedCharacterIndex - 1 + characterNames.length) % characterNames.length;
            } else {
                // Find previous unlocked character
                let prevIndex = selectedCharacterIndex;
                let startIndex = selectedCharacterIndex;
                let attempts = 0;
                
                do {
                    prevIndex = (prevIndex - 1 + characterNames.length) % characterNames.length;
                    attempts++;
                    
                    if (attempts > characterNames.length) {
                        // No other unlocked characters found
                        prevIndex = startIndex;
                        break;
                    }
                } while (!unlockedCharacters[characterNames[prevIndex]] && prevIndex !== startIndex);
                
                selectedCharacterIndex = prevIndex;
            }
            
            // Show new model
            if (characterSelectModels[selectedCharacterIndex]) {
                characterSelectModels[selectedCharacterIndex].model.visible = true;
            }
            
            // Update info display
            updateCharacterInfo();
        });
    }
    
    if (nextBtn) {
        const newNextBtn = nextBtn.cloneNode(true);
        nextBtn.parentNode.replaceChild(newNextBtn, nextBtn);
        
        newNextBtn.addEventListener('click', function() {
            // Hide current model
            if (characterSelectModels[selectedCharacterIndex]) {
                characterSelectModels[selectedCharacterIndex].model.visible = false;
            }
            
            // If mod mode is enabled, show all characters. Otherwise only show unlocked ones
            if (modModeEnabled) {
                // Simple navigation when mod mode is on
                selectedCharacterIndex = (selectedCharacterIndex + 1) % characterNames.length;
            } else {
                // Find next unlocked character
                let nextIndex = selectedCharacterIndex;
                let startIndex = selectedCharacterIndex;
                let attempts = 0;
                
                do {
                    nextIndex = (nextIndex + 1) % characterNames.length;
                    attempts++;
                    
                    if (attempts > characterNames.length) {
                        // No other unlocked characters found
                        nextIndex = startIndex;
                        break;
                    }
                } while (!unlockedCharacters[characterNames[nextIndex]] && nextIndex !== startIndex);
                
                selectedCharacterIndex = nextIndex;
            }
            
            // Show new model
            if (characterSelectModels[selectedCharacterIndex]) {
                characterSelectModels[selectedCharacterIndex].model.visible = true;
            }
            
            // Update info display
            updateCharacterInfo();
        });
    }
    
    if (selectBtn) {
        const newSelectBtn = selectBtn.cloneNode(true);
        selectBtn.parentNode.replaceChild(newSelectBtn, selectBtn);
        
        newSelectBtn.addEventListener('click', function() {
            const selectedChar = characterNames[selectedCharacterIndex];
            
            // Check if character is unlocked
            if (unlockedCharacters[selectedChar] || modModeEnabled) {
                // Set and save the selected character
                currentCharacter = selectedChar;
                createPlayer(); // Update player model
                saveGameData('character_select'); // Save the selection
                
                // Visual feedback
                alert(`✅ ${selectedChar.charAt(0).toUpperCase() + selectedChar.slice(1)} selected!`);
                
                // Update button states
                updateCharacterInfo();
            } else {
                // Character is locked - ask if they want to unlock
                const cost = characterCosts[selectedChar];
                if (confirm(`This character costs ${cost} coins. Do you want to unlock it?`)) {
                    tryUnlockCharacter(selectedChar);
                    updateCharacterInfo(); // Refresh display after attempt
                }
            }
        });
    }
    
    if (startBtn) {
        const newStartBtn = startBtn.cloneNode(true);
        startBtn.parentNode.replaceChild(newStartBtn, startBtn);
        
        newStartBtn.addEventListener('click', function() {
            // Make sure we're using the current character (not just what's displayed)
            console.log(`Starting game with character: ${currentCharacter}`);
            
            // Hide character selection screen and show world selection
            document.getElementById('characterSelectScreen').style.display = 'none';
            document.getElementById('characterSelectScreen').classList.remove('active');
            
            document.getElementById('worldSelectScreen').style.display = 'flex';
            document.getElementById('worldSelectScreen').classList.add('active');
            
            // Initialize world selection screen
            initWorldSelectScreen();
            
            // Update game state
            gameState = "worldSelect";
        });
    }
}

        // ==================== WORLD SELECTION SYSTEM ====================
// World selection screen and world preview functionality
// Dependencies: worlds/forest.js, worlds/desert.js, Character System
// Functions: initWorldSelectScreen(), selectWorld(), previewWorld(), switchWorld(), etc.

        // Initialize World Selection Screen
function initWorldSelectScreen() {
    // Use the world preview div directly
    const worldPreview = document.getElementById('worldPreview');
    if (!worldPreview) {
        console.error('World preview element not found!');
        return;
    }
    
    // Clear previous content
    worldPreview.innerHTML = '';
    
    // Create a new scene for world preview
    worldSelectScene = new THREE.Scene();
    worldSelectScene.background = null; // Transparent background
    
    // Create a camera
    worldSelectCamera = new THREE.PerspectiveCamera(75, 500 / 300, 0.1, 1000);
    worldSelectCamera.position.set(0, 2.5, 3);
    worldSelectCamera.lookAt(0, 0, 0);
    
    // Create a renderer
    worldSelectRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    worldSelectRenderer.setSize(500, 300);
    worldSelectRenderer.setClearColor(0x000000, 0);
    
    // Style the renderer
    worldSelectRenderer.domElement.style.position = 'absolute';
    worldSelectRenderer.domElement.style.top = '0';
    worldSelectRenderer.domElement.style.left = '0';
    worldSelectRenderer.domElement.style.width = '100%';
    worldSelectRenderer.domElement.style.height = '100%';
    worldSelectRenderer.domElement.style.borderRadius = '20px';
    
    // Add to the preview container
    worldPreview.appendChild(worldSelectRenderer.domElement);
    
    // Add lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    worldSelectScene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    worldSelectScene.add(directionalLight);
    
    // Create world preview models
    createWorldPreviews();
    
    // Show the correct initial world
    updateWorldDisplay();
    
    // Clear any existing animation loop
    if (window.worldSelectAnimationId) {
        cancelAnimationFrame(window.worldSelectAnimationId);
    }
    
    // Animation for world selection screen
    function animateWorldSelect() {
        window.worldSelectAnimationId = requestAnimationFrame(animateWorldSelect);
        
        if (gameState === "worldSelect") {
            // Rotate the displayed world preview
            if (worldSelectModels && worldSelectModels[selectedWorldIndex]) {
                const currentModel = worldSelectModels[selectedWorldIndex];
                
                if (currentModel && currentModel.visible) {
                    currentModel.rotation.y += 0.005;
                    
                    // Add gentle floating motion
                    const baseY = currentModel.userData.baseY || 0;
                    currentModel.position.y = baseY + Math.sin(frameCount * 0.02) * 0.08;
                }
            }
            
            // Render
            if (worldSelectRenderer && worldSelectScene && worldSelectCamera) {
                worldSelectRenderer.render(worldSelectScene, worldSelectCamera);
            }
        }
    }
    
    // Start animation
    animateWorldSelect();
    
    // Setup navigation buttons
    setupWorldSelectButtons();
}

// Create world preview models
function createWorldPreviews() {
    // Clear existing models
    worldSelectModels.forEach(model => {
        if (model && model.parent) {
            model.parent.remove(model);
        }
    });
    worldSelectModels = [];
    
    availableWorlds.forEach(world => {
        const worldPreview = createWorldPreviewModel(world);
        worldPreview.visible = false; // Hide all initially
        worldSelectScene.add(worldPreview);
        worldSelectModels.push(worldPreview);
    });
    
    // Show the first world
    if (worldSelectModels.length > 0) {
        worldSelectModels[selectedWorldIndex].visible = true;
    }
}

// Create a 3D preview model for a world
function createWorldPreviewModel(world) {
    const previewGroup = new THREE.Group();
    
    if (world.id === 'classic') {
    // Create classic plains preview
    
    // Ground platform
    const groundGeometry = new THREE.BoxGeometry(4, 0.2, 4);
    const groundMaterial = new THREE.MeshStandardMaterial({
        color: world.colors.ground,
        roughness: 0.8
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.position.y = -0.1;
    previewGroup.add(ground);
    
    // Add some grass
    for (let i = 0; i < 8; i++) {
        const grassGeometry = new THREE.ConeGeometry(0.05, 0.3, 4);
        const grassMaterial = new THREE.MeshStandardMaterial({
            color: 0x228B22
        });
        const grass = new THREE.Mesh(grassGeometry, grassMaterial);
        grass.position.set(
            (Math.random() - 0.5) * 3,
            0.05,
            (Math.random() - 0.5) * 3
        );
        previewGroup.add(grass);
    }
    
    // Add a small tree
    const trunkGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.6, 8);
    const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
    trunk.position.set(1, 0.3, 1);
    previewGroup.add(trunk);
    
    const leavesGeometry = new THREE.SphereGeometry(0.4, 8, 8);
    const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
    const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
    leaves.position.set(1, 0.8, 1);
    previewGroup.add(leaves);
    
    // Add some flowers
    for (let i = 0; i < 5; i++) {
        const flowerGeometry = new THREE.SphereGeometry(0.03, 6, 6);
        const flowerColors = [0xFF0000, 0xFFFF00, 0xFF00FF, 0xFFFFFF];
        const flowerMaterial = new THREE.MeshStandardMaterial({
            color: flowerColors[Math.floor(Math.random() * flowerColors.length)]
        });
        const flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
        flower.position.set(
            (Math.random() - 0.5) * 2,
            0.1,
            (Math.random() - 0.5) * 2
        );
        previewGroup.add(flower);
    }
} else if (world.id === 'forest') {
    // Create forest preview
    
    // Dark forest ground
    const groundGeometry = new THREE.BoxGeometry(4, 0.2, 4);
    const groundMaterial = new THREE.MeshStandardMaterial({
        color: world.colors.ground,
        roughness: 0.9
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.position.y = -0.1;
    previewGroup.add(ground);
    
    // Add tall pine trees
    for (let i = 0; i < 4; i++) {
        const trunkGeometry = new THREE.CylinderGeometry(0.08, 0.12, 1.2, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.set(
            (Math.random() - 0.5) * 3,
            0.6,
            (Math.random() - 0.5) * 3
        );
        previewGroup.add(trunk);
        
        // Pine cone shape leaves
        const leavesGeometry = new THREE.ConeGeometry(0.5, 1.0, 8);
        const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x1F4F2F });
        const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
        leaves.position.copy(trunk.position);
        leaves.position.y += 0.8;
        previewGroup.add(leaves);
    }
    
    // Add mushrooms
    for (let i = 0; i < 6; i++) {
        const stemGeometry = new THREE.CylinderGeometry(0.03, 0.04, 0.15, 6);
        const stemMaterial = new THREE.MeshStandardMaterial({ color: 0xF5DEB3 });
        const stem = new THREE.Mesh(stemGeometry, stemMaterial);
        stem.position.set(
            (Math.random() - 0.5) * 2,
            0.075,
            (Math.random() - 0.5) * 2
        );
        previewGroup.add(stem);
        
        const capGeometry = new THREE.SphereGeometry(0.06, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
        const capMaterial = new THREE.MeshStandardMaterial({ 
            color: i % 2 === 0 ? 0xFF4500 : 0x8B4513 
        });
        const cap = new THREE.Mesh(capGeometry, capMaterial);
        cap.position.copy(stem.position);
        cap.position.y += 0.12;
        previewGroup.add(cap);
    }
    
    // Add ferns
    for (let i = 0; i < 8; i++) {
        const fernGeometry = new THREE.PlaneGeometry(0.2, 0.3);
        const fernMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x228B22,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.8
        });
        const fern = new THREE.Mesh(fernGeometry, fernMaterial);
        fern.position.set(
            (Math.random() - 0.5) * 3,
            0.15,
            (Math.random() - 0.5) * 3
        );
        fern.rotation.y = Math.random() * Math.PI * 2;
        previewGroup.add(fern);
    }
} else if (world.id === 'desert') {
    // Create desert preview
    
    // Sandy ground
    const groundGeometry = new THREE.BoxGeometry(4, 0.2, 4);
    const groundMaterial = new THREE.MeshStandardMaterial({
        color: world.colors.ground,
        roughness: 0.9
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.position.y = -0.1;
    previewGroup.add(ground);
    
    // Add sand dunes
    for (let i = 0; i < 3; i++) {
        const duneGeometry = new THREE.SphereGeometry(0.8, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
        const duneMaterial = new THREE.MeshStandardMaterial({
            color: 0xF4A460,
            roughness: 0.9
        });
        const dune = new THREE.Mesh(duneGeometry, duneMaterial);
        dune.position.set(
            (Math.random() - 0.5) * 3,
            0,
            (Math.random() - 0.5) * 3
        );
        dune.scale.set(1, 0.5, 1);
        previewGroup.add(dune);
    }
    
    // Add a small cactus
    const cactusGeometry = new THREE.CylinderGeometry(0.1, 0.12, 0.8, 8);
    const cactusMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
    const cactus = new THREE.Mesh(cactusGeometry, cactusMaterial);
    cactus.position.set(1.2, 0.4, 0.8);
    previewGroup.add(cactus);
    
    // Add cactus flower
    const flowerGeometry = new THREE.SphereGeometry(0.05, 6, 6);
    const flowerMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xFF69B4,
        emissive: 0xFF1493,
        emissiveIntensity: 0.3
    });
    const flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
    flower.position.set(1.2, 0.85, 0.8);
    previewGroup.add(flower);
    
    // Add some rocks
    for (let i = 0; i < 4; i++) {
        const rockGeometry = new THREE.DodecahedronGeometry(0.08, 1);
        const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x8B7355 });
        const rock = new THREE.Mesh(rockGeometry, rockMaterial);
        rock.position.set(
            (Math.random() - 0.5) * 2.5,
            0.05,
            (Math.random() - 0.5) * 2.5
        );
        rock.rotation.set(
            Math.random() * Math.PI,
            Math.random() * Math.PI,
            Math.random() * Math.PI
        );
        previewGroup.add(rock);
    }
    
    // Add heat shimmer effect
    const shimmerGeometry = new THREE.PlaneGeometry(4, 0.5);
    const shimmerMaterial = new THREE.MeshBasicMaterial({
        color: 0xFFFFFF,
        transparent: true,
        opacity: 0.1,
        side: THREE.DoubleSide
    });
    const shimmer = new THREE.Mesh(shimmerGeometry, shimmerMaterial);
    shimmer.rotation.x = -Math.PI / 2;
    shimmer.position.y = 0.01;
    previewGroup.add(shimmer);
}
    
    // Scale up the preview to fill the rectangle better
previewGroup.scale.set(1.5, 1.5, 1.5);

// Center the preview perfectly in the rectangle  
previewGroup.position.set(0, 0.3, 0); // Raise it up slightly
previewGroup.userData.baseY = 0.3; // Store base position for floating animation

return previewGroup;
}

        // Setup world select navigation buttons
function setupWorldSelectButtons() {
    // Remove any existing event listeners by cloning buttons
    const prevBtn = document.getElementById('prevWorldBtn');
    const nextBtn = document.getElementById('nextWorldBtn');
    const startBtn = document.getElementById('startGameFromWorldButton');

    // Clone buttons to remove all event listeners
    const newPrevBtn = prevBtn.cloneNode(true);
    const newNextBtn = nextBtn.cloneNode(true);
    const newStartBtn = startBtn.cloneNode(true);
    
    prevBtn.parentNode.replaceChild(newPrevBtn, prevBtn);
    nextBtn.parentNode.replaceChild(newNextBtn, nextBtn);
    startBtn.parentNode.replaceChild(newStartBtn, startBtn);

    // Add fresh event listeners
    document.getElementById('prevWorldBtn').addEventListener('click', function() {
    console.log('Starting at index:', selectedWorldIndex, '(', availableWorlds[selectedWorldIndex].id, ')');
    
    // Hide current model
    if (worldSelectModels && worldSelectModels[selectedWorldIndex]) {
        worldSelectModels[selectedWorldIndex].visible = false;
    }
    
    // If mod mode is enabled, show all worlds. Otherwise only show unlocked ones
    if (modModeEnabled) {
        // Simple navigation when mod mode is on
        selectedWorldIndex = (selectedWorldIndex - 1 + availableWorlds.length) % availableWorlds.length;
        console.log('Mod mode ON - moved to index:', selectedWorldIndex);
    } else {
        // Find previous unlocked world
        let prevIndex = selectedWorldIndex;
        let startIndex = selectedWorldIndex;
        let attempts = 0;
        
        do {
            prevIndex = (prevIndex - 1 + availableWorlds.length) % availableWorlds.length;
            console.log(`Checking index ${prevIndex} (${availableWorlds[prevIndex].id}): unlocked = ${unlockedWorlds[availableWorlds[prevIndex].id]}`);
            attempts++;
            
            if (attempts > availableWorlds.length) {
                console.log('⚠️ No other unlocked worlds found, staying at current');
                prevIndex = startIndex;
                break;
            }
        } while (!unlockedWorlds[availableWorlds[prevIndex].id] && prevIndex !== startIndex);
        
        selectedWorldIndex = prevIndex;
        console.log('Final index:', selectedWorldIndex);
    }
    
    // Show new model
    if (worldSelectModels && worldSelectModels[selectedWorldIndex]) {
        worldSelectModels[selectedWorldIndex].visible = true;
    }
    
    // Update info display
    updateWorldDisplay();
});

document.getElementById('nextWorldBtn').addEventListener('click', function() {
    
    // Hide current model
    if (worldSelectModels && worldSelectModels[selectedWorldIndex]) {
        worldSelectModels[selectedWorldIndex].visible = false;
    }
    
    // If mod mode is enabled, show all worlds. Otherwise only show unlocked ones
    if (modModeEnabled) {
        // Simple navigation when mod mode is on
        selectedWorldIndex = (selectedWorldIndex + 1) % availableWorlds.length;
    } else {
        // Find next unlocked world
        let nextIndex = selectedWorldIndex;
        let startIndex = selectedWorldIndex;
        let attempts = 0;
        
        do {
            nextIndex = (nextIndex + 1) % availableWorlds.length;
            console.log(`Checking index ${nextIndex} (${availableWorlds[nextIndex].id}): unlocked = ${unlockedWorlds[availableWorlds[nextIndex].id]}`);
            attempts++;
            
            if (attempts > availableWorlds.length) {
                nextIndex = startIndex;
                break;
            }
        } while (!unlockedWorlds[availableWorlds[nextIndex].id] && nextIndex !== startIndex);
        
        selectedWorldIndex = nextIndex;
    }
    
    // Show new model
    if (worldSelectModels && worldSelectModels[selectedWorldIndex]) {
        worldSelectModels[selectedWorldIndex].visible = true;
    }
    
    // Update info display
    updateWorldDisplay();
});
    
// Start game from world select
document.getElementById('startGameFromWorldButton').addEventListener('click', function() {
    const selectedWorld = availableWorlds[selectedWorldIndex];
    
    if (unlockedWorlds[selectedWorld.id] || modModeEnabled) {
        // Set the selected world
        currentWorld = selectedWorld.id;
        applyWorldSettings(selectedWorld);
        
        // Hide world selection screen
        document.getElementById('worldSelectScreen').style.display = 'none';
        
        // Update game state and start the game
        gameState = "playing";
        startGame();
    } else {
        // World is locked - ask if they want to unlock
        const cost = selectedWorld.cost;
        if (confirm(`This world costs ${cost} coins. Do you want to unlock it?`)) {
            tryUnlockWorld(selectedWorld.id);
            updateWorldDisplay(); // Refresh display after attempt
        }
    }
});
}

// Update world display information
function updateWorldDisplay() {
    const selectedWorld = availableWorlds[selectedWorldIndex];
    const worldNameElem = document.getElementById('worldName');
    const worldDescElem = document.getElementById('worldDescription');
    const worldStatusElem = document.getElementById('worldUnlockStatus');
    const startButton = document.getElementById('startGameFromWorldButton');
    
    // Update coin display
    const coinDisplay = document.getElementById('world-select-coins');
    if (coinDisplay) {
        coinDisplay.textContent = totalCoins;
    }
    
    // Set name
    worldNameElem.textContent = selectedWorld.name;
    
    // Set description
    worldDescElem.textContent = selectedWorld.description;
    
    // Check unlock status
    if (unlockedWorlds[selectedWorld.id] || modModeEnabled) {
        worldStatusElem.innerHTML = '<span class="status-icon">✅</span><span class="status-text">Unlocked</span>';
        worldStatusElem.className = 'unlock-status unlocked';
        
        // Check if button has the new structure
        const buttonText = startButton.querySelector('.button-text');
        if (buttonText) {
            buttonText.textContent = "START ADVENTURE!";
        } else {
            startButton.textContent = "START ADVENTURE!";
        }
        
        startButton.style.opacity = "1";
        startButton.style.cursor = "pointer";
    } else {
        worldStatusElem.innerHTML = `<span class="status-icon">🔒</span><span class="status-text">Locked - ${selectedWorld.cost} coins</span>`;
        worldStatusElem.className = 'unlock-status locked';
        
        // Check if button has the new structure
        const buttonText = startButton.querySelector('.button-text');
        if (buttonText) {
            buttonText.textContent = `UNLOCK FOR ${selectedWorld.cost} COINS`;
        } else {
            startButton.textContent = `UNLOCK FOR ${selectedWorld.cost} COINS`;
        }
        
        startButton.style.opacity = "0.8";
        startButton.style.cursor = "pointer";
    }
}

// Try to unlock a world
function tryUnlockWorld(worldId) {
    const world = availableWorlds.find(w => w.id === worldId);
    if (!world) return;
    
    if (unlockedWorlds[worldId]) {
        return; // Already unlocked
    }
    
    const cost = world.cost;
    if (totalCoins >= cost) {
        totalCoins -= cost;
        unlockedWorlds[worldId] = true;
        updateTotalCoins();
        saveGameData('world_unlock');  // or 'world_unlock'
        alert(`${world.name} unlocked!`);
    } else {
        alert(`Not enough coins! You need ${cost} coins to unlock this world.`);
    }
}

// Apply world settings to the game
function applyWorldSettings(world) {
    // Apply sky color
    scene.background = new THREE.Color(world.colors.sky);
    
    // Apply lighting changes
    if (skyLight) {
        skyLight.color.setHex(world.lighting.directional.color);
        skyLight.intensity = world.lighting.directional.intensity;
    }
    
    // Store current world data for other systems to use
    window.currentWorldData = world;
    
    // IMPORTANT: Recreate the ground with the new world theme
    recreateGroundForWorld();
    
    console.log(`Applied settings for world: ${world.name}`);
}

// Recreate ground and background with current world theme
function recreateGroundForWorld() {
    // Remove existing ground segments
    groundSegments.forEach(segment => {
        scene.remove(segment);
    });
    groundSegments = [];
    
    // Remove existing side terrain segments
    sideTerrainSegments.forEach(terrain => {
        scene.remove(terrain);
    });
    sideTerrainSegments = [];
    
    // Remove existing background elements (mountains, trees, etc.)
    removeOldBackground();
    
    // Recreate ground and background with current world theme
    createGround();
    createBackground();
    
    console.log(`Ground and background recreated for world: ${currentWorld}`);
}

// Remove old background elements when switching worlds
function removeOldBackground() {
    // Find and remove background elements (mountains, trees, clouds, etc.)
    const elementsToRemove = [];
    
    scene.traverse((object) => {
        // Remove mountains, trees, and other background scenery
        // (but keep player, coins, obstacles, etc.)
        if (object.parent === scene && 
            object !== player && 
            !groundSegments.includes(object) &&
            !sideTerrainSegments.includes(object) &&
            !coins.includes(object) &&
            !obstacles.includes(object) &&
            !powerUps.includes(object) &&
            !waterStreams.includes(object) &&
            !sceneryObjects.includes(object) &&
            object.type !== 'DirectionalLight' &&
            object.type !== 'AmbientLight') {
            
            // Check if it's likely a background element (positioned far away)
            if (Math.abs(object.position.z) > 50 || Math.abs(object.position.x) > 20) {
                elementsToRemove.push(object);
            }
        }
    });
    
    // Remove the background elements
    elementsToRemove.forEach(element => {
        scene.remove(element);
    });
    
    console.log(`Removed ${elementsToRemove.length} old background elements`);
}

        // Update character info display
function updateCharacterInfo() {
    const selectedChar = characterNames[selectedCharacterIndex];
    const charNameElem = document.getElementById('characterName');
    const charDescElem = document.getElementById('characterDescription');
    const charStatusElem = document.getElementById('characterUnlockStatus');
    const startButton = document.getElementById('startGameButton');
    const selectBtn = document.getElementById('selectCharacterButton'); // Define this FIRST
    
    // Update coin display
    const coinDisplay = document.getElementById('character-select-coins');
    if (coinDisplay) {
        coinDisplay.textContent = totalCoins;
    }
    
    // Set name (capitalized)
    charNameElem.textContent = selectedChar.charAt(0).toUpperCase() + selectedChar.slice(1);
    
    // Set description
    switch (selectedChar) {
        case "apple":
            charDescElem.textContent = "Classic runner";
            break;
        case "carrot":
            charDescElem.textContent = "Fast lane changes";
            break;
        case "pumpkin":
            charDescElem.textContent = "Higher jumps";
            break;
        case "happyface":
            charDescElem.textContent = "Bouncy and cheerful";
            break;
        case "monster":
            charDescElem.textContent = "Ominous and fast";
            break;
        case "atom":
            charDescElem.textContent = "Glowing nucleus";
            break;
        case "slime":
            charDescElem.textContent = "Oozing and creepy";
            break;
        case "ufo":
            charDescElem.textContent = "Alien technology";
            break;
        case "robot":
            charDescElem.textContent = "Electromagnetic shield";
            break;
        case "dragon":
            charDescElem.textContent = "Fire breath destroyer";
            break;
        case "ghost":
            charDescElem.textContent = "Phase through obstacles";
            break;
        case "creature":
            charDescElem.textContent = "Otherworldly cosmic entity";
            break;
    }
    
    // Update select button state FIRST (before using it in unlock status)
    if (selectBtn) {
        const isCurrentCharacter = (currentCharacter === selectedChar);
        const selectBtnText = selectBtn.querySelector('.button-text');
        
        if (selectBtnText) {
            if (isCurrentCharacter) {
                selectBtn.classList.add('selected');
                selectBtnText.textContent = "✓ SELECTED";
            } else {
                selectBtn.classList.remove('selected');
                selectBtnText.textContent = "SELECT CHARACTER";
            }
        }
    }
    
    // Check unlock status
    if (unlockedCharacters[selectedChar] || modModeEnabled) {
        charStatusElem.innerHTML = '<span class="status-icon">✅</span><span class="status-text">Unlocked</span>';
        charStatusElem.className = 'unlock-status unlocked';
        
        // Check if button has the new structure
        const buttonText = startButton.querySelector('.button-text');
        if (buttonText) {
            buttonText.textContent = "START RUNNING!";
        } else {
            startButton.textContent = "RUN!";
        }
        
        startButton.style.opacity = "1";
        startButton.style.cursor = "pointer";
    } else {
        const cost = characterCosts[selectedChar];
        charStatusElem.innerHTML = `<span class="status-icon">🔒</span><span class="status-text">Locked - ${cost} coins</span>`;
        charStatusElem.className = 'unlock-status locked';
        
        // Check if button has the new structure
        const buttonText = startButton.querySelector('.button-text');
        if (buttonText) {
            buttonText.textContent = `UNLOCK FOR ${cost} COINS`;
        } else {
            startButton.textContent = `UNLOCK FOR ${cost} COINS`;
        }
        
        startButton.style.opacity = "0.8";
        startButton.style.cursor = "pointer";
    }
}

        // Create and animate background effects
        function createBackgroundEffects(scene) {
            // Add particles, grid lines, etc. here
            // This is just a simple implementation - you can expand it
            
            // Create particles
            const particlesGeometry = new THREE.BufferGeometry();
            const particleCount = 200;
            
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                // Position
                positions[i * 3] = (Math.random() - 0.5) * 20;      // x
                positions[i * 3 + 1] = (Math.random() - 0.5) * 20;  // y
                positions[i * 3 + 2] = (Math.random() - 0.5) * 20;  // z
                
                // Color (blue/cyan)
                colors[i * 3] = 0.1 + Math.random() * 0.3;          // r
                colors[i * 3 + 1] = 0.4 + Math.random() * 0.4;      // g
                colors[i * 3 + 2] = 0.7 + Math.random() * 0.3;      // b
            }
            
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const particlesMaterial = new THREE.PointsMaterial({
                size: 0.1,
                transparent: true,
                opacity: 0.7,
                vertexColors: true
            });
            
            const particles = new THREE.Points(particlesGeometry, particlesMaterial);
            particles.userData = {
                originalPositions: positions.slice() // Store original positions
            };
            
            scene.add(particles);
            scene.userData.particles = particles;
        }

        function animateBackgroundEffects() {
            const scene = characterSelectModels[0].model.parent;
            const particles = scene.userData.particles;
            
            if (particles) {
                // Animate particles
                const positions = particles.geometry.attributes.position.array;
                const originalPositions = particles.userData.originalPositions;
                
                for (let i = 0; i < positions.length; i += 3) {
                    // Move particles in a wave pattern
                    positions[i] = originalPositions[i] + Math.sin(frameCount * 0.01 + i * 0.1) * 0.1;
                    positions[i + 1] = originalPositions[i + 1] + Math.cos(frameCount * 0.01 + i * 0.05) * 0.1;
                    positions[i + 2] = originalPositions[i + 2];
                }
                
                particles.geometry.attributes.position.needsUpdate = true;
            }
        }

        // Helper function to animate specific characters
        function animateCharacterModel(model, type, frame) {
            switch (type) {
                case "happyface":
    // Bouncy animation - but only during gameplay, not on title screen
    if (model.userData && model.userData.bounceOffset !== undefined && gameState === "playing") {
        model.position.y = Math.sin(frame * 0.05 + model.userData.bounceOffset) * 0.1;
    }
    break;
                case "monster":
                    // Smoky particle animation
                    if (model.children) {
                        for (let i = 5; i < model.children.length; i++) {
                            const particle = model.children[i];
                            if (particle.userData && particle.userData.initialPosition) {
                                particle.userData.angle += particle.userData.rotationSpeed;
                                
                                const orbitRadius = particle.userData.initialPosition.length() + 
                                    Math.sin(frame * particle.userData.oscillationSpeed) * 
                                    particle.userData.oscillationDistance;
                                
                                const newX = orbitRadius * Math.sin(particle.userData.angle);
                                const newY = particle.userData.initialPosition.y + 
                                    Math.sin(frame * 0.1 + i) * 0.05;
                                const newZ = orbitRadius * Math.cos(particle.userData.angle);
                                
                                particle.position.set(newX, newY, newZ);
                            }
                        }
                    }
                    break;
                case "atom":
                    // Update electrons in orbit
                    for (let i = 0; i < model.children.length; i++) {
                        const child = model.children[i];
                        
                        // Orbital rings rotation
                        if (i >= 2 && i <= 4) {
                            child.rotation.z += 0.01;
                        }
                        
                        // Electrons
                        if (child.userData && child.userData.orbitalIndex !== undefined) {
                            const electron = child;
                            const orbitalIndex = electron.userData.orbitalIndex;
                            const orbitalRadius = electron.userData.orbitalRadius;
                            const speed = electron.userData.speed;
                            
                            electron.userData.angle += speed;
                            
                            if (orbitalIndex === 0) {
                                electron.position.x = Math.cos(electron.userData.angle) * orbitalRadius;
                                electron.position.z = Math.sin(electron.userData.angle) * orbitalRadius;
                            } else if (orbitalIndex === 1) {
                                electron.position.y = Math.cos(electron.userData.angle) * orbitalRadius;
                                electron.position.z = Math.sin(electron.userData.angle) * orbitalRadius;
                            } else {
                                electron.position.x = Math.cos(electron.userData.angle) * orbitalRadius * 0.7;
                                electron.position.y = Math.cos(electron.userData.angle) * orbitalRadius * 0.7;
                                electron.position.z = Math.sin(electron.userData.angle) * orbitalRadius;
                            }
                        }
                        
                        // Nucleus sparkles
                        if (i === 0 && child.children) {
                            child.children.forEach(sparkle => {
                                if (sparkle.userData) {
                                    const pulseScale = 0.8 + Math.sin(frame * sparkle.userData.pulseSpeed + sparkle.userData.pulsePhase) * 0.3;
                                    sparkle.scale.set(pulseScale, pulseScale, pulseScale);
                                }
                            });
                        }
                        
                        // Glow effect
                        if (i === 1) {
                            const pulseScale = 1.0 + Math.sin(frame * 0.05) * 0.1;
                            child.scale.set(pulseScale, pulseScale, pulseScale);
                            child.material.opacity = 0.3 + Math.sin(frame * 0.08) * 0.15;
                        }
                    }
                    break;
case "ufo":
    // Rotate the outer ring
    if (model.userData && model.userData.ring) {
        model.userData.ring.rotation.y += 0.03;
    }
    
    // Pulse the lights
    if (model.userData && model.userData.lights) {
        model.userData.lights.children.forEach((light, index) => {
            if (light.userData) {
                const pulse = Math.sin(frame * light.userData.pulseSpeed + light.userData.pulsePhase);
                light.material.emissiveIntensity = light.userData.originalIntensity + pulse * 0.5;
            }
        });
    }
    
    // Pulse the dome
    if (model.userData && model.userData.dome) {
        const domePulse = Math.sin(frame * 0.03) * 0.2 + 0.5;
        model.userData.dome.material.emissiveIntensity = domePulse;
    }
    
    // Animate tractor beam
    if (model.userData && model.userData.beam) {
        const beamPulse = Math.sin(frame * 0.05) * 0.1 + 0.2;
        model.userData.beam.material.opacity = beamPulse;
        model.userData.beam.rotation.y += 0.02;
    }
    
    // Float energy particles
    if (model.userData && model.userData.particles) {
        model.userData.particles.forEach(particle => {
            if (particle.userData) {
                // Orbit motion
                particle.userData.orbitAngle += particle.userData.orbitSpeed;
                const x = Math.cos(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                const z = Math.sin(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                
                // Floating motion
                const floatY = Math.sin(frame * particle.userData.floatSpeed + particle.userData.floatOffset) * 0.3;
                
                particle.position.set(x, floatY, z);
                
                // Particle glow pulse
                const glowPulse = Math.sin(frame * 0.08 + particle.userData.floatOffset) * 0.3 + 0.7;
                particle.material.opacity = glowPulse;
            }
        });
    }
    break;

case "slime":
    // Wobble animation for slime
    if (model.userData) {
        const wobble = Math.sin(frame * model.userData.wobbleSpeed) * model.userData.wobbleIntensity;
        model.scale.set(1 + wobble, 1 - wobble * 0.5, 1 + wobble);
        
        // Animate bubbles
        if (model.userData.bubbles) {
            model.userData.bubbles.forEach(bubble => {
                if (bubble.userData) {
                    const pulseScale = bubble.userData.originalScale.x + Math.sin(frame * bubble.userData.pulseSpeed + bubble.userData.pulsePhase) * 0.3;
                    bubble.scale.set(pulseScale, pulseScale, pulseScale);
                }
            });
        }
    }
    break;

case "robot":
    // Animate electromagnetic field
    if (model.userData && model.userData.fieldParticles) {
        model.userData.fieldParticles.forEach(particle => {
            if (particle.userData) {
                // Orbit around robot
                particle.userData.orbitAngle += particle.userData.orbitSpeed;
                particle.position.x = Math.cos(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                particle.position.z = Math.sin(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                particle.position.y = particle.userData.verticalOffset + Math.sin(frame * 0.02 + particle.userData.orbitAngle) * 0.2;
                
                // Pulse brightness based on shield status
                const intensity = robotShieldActive ? 0.8 : 0.3;
                particle.material.opacity = intensity + Math.sin(frame * 0.1 + particle.userData.orbitAngle) * 0.2;
            }
        });
    }
    break;

case "dragon":
    // Animate wings
    if (model.userData && model.userData.wings) {
        const wingFlap = Math.sin(frame * 0.15) * 0.3;
        model.userData.wings[0].rotation.z = Math.PI / 3 + wingFlap; // Left wing
        model.userData.wings[1].rotation.z = -Math.PI / 3 - wingFlap; // Right wing
    }
    
    // Animate fire particles when fire breath is active
    if (model.userData && model.userData.fireParticles && dragonFireActive) {
        model.userData.fireParticles.forEach((particle, index) => {
            if (particle.userData) {
                // Move fire particles forward
                particle.position.z += particle.userData.speed;
                
                // Flicker effect
                const flicker = Math.sin(frame * particle.userData.flickerSpeed + index) * 0.3 + 0.7;
                particle.material.opacity = particle.userData.originalOpacity * flicker;
                particle.scale.setScalar(0.8 + flicker * 0.4);
                
                // Reset position if too far
                if (particle.position.z > 2.0) {
                    particle.position.set(
                        (Math.random() - 0.5) * 0.3,
                        0.1 + Math.random() * 0.2,
                        1.0
                    );
                }
            }
        });
    }
    break;

case "ghost":
    // Animate wispy tail
    if (model.userData && model.userData.wisps) {
        model.userData.wisps.forEach(wisp => {
            if (wisp.userData) {
                const float = Math.sin(frame * wisp.userData.floatSpeed + wisp.userData.floatOffset) * 0.1;
                wisp.position.y = wisp.userData.originalY + float;
                wisp.rotation.y += 0.01;
            }
        });
    }
    
    // Animate floating particles
    if (model.userData && model.userData.particles) {
        model.userData.particles.forEach(particle => {
            if (particle.userData) {
                // Orbit motion
                particle.userData.orbitAngle += particle.userData.orbitSpeed;
                particle.position.x = Math.cos(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                particle.position.z = Math.sin(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                
                // Floating motion
                const floatY = Math.sin(frame * particle.userData.floatSpeed + particle.userData.floatOffset) * 0.2;
                particle.position.y += floatY * 0.01;
                
                // Pulse opacity
                const pulse = Math.sin(frame * 0.05 + particle.userData.floatOffset) * 0.3 + 0.7;
                particle.material.opacity = 0.6 * pulse;
            }
        });
    }
    
    // Phase effect when phasing through obstacles
    if (ghostPhaseActive) {
        const phaseOpacity = 0.3 + Math.sin(frame * 0.2) * 0.2;
        model.children[0].material.opacity = phaseOpacity; // Main body
        
        // Make wisps more transparent too
        if (model.userData && model.userData.wisps) {
            model.userData.wisps.forEach((wisp, index) => {
                wisp.material.opacity = (0.5 - index * 0.05) * phaseOpacity;
            });
        }
    } else {
        // Normal opacity
        model.children[0].material.opacity = model.userData.originalOpacity;
        if (model.userData && model.userData.wisps) {
            model.userData.wisps.forEach((wisp, index) => {
                wisp.material.opacity = 0.5 - index * 0.05;
            });
        }
    }
    break;

    case "creature":
    // Animate the neon core pulsing
    if (model.userData && model.userData.neonCore) {
        model.userData.corePhase += model.userData.bodyPulseSpeed;
        const corePulse = Math.sin(model.userData.corePhase) * 0.3 + 1.0;
        model.userData.neonCore.scale.set(corePulse, corePulse, corePulse);
        model.userData.neonCore.material.emissiveIntensity = 0.8 + Math.sin(model.userData.corePhase * 1.5) * 0.4;
    }
    
    // Animate multiple eyes blinking independently
    if (model.userData && model.userData.eyes) {
        model.userData.eyes.forEach(eye => {
            if (eye.userData) {
                // Independent blinking
                const blink = Math.sin(frame * eye.userData.blinkSpeed + eye.userData.blinkOffset);
                eye.scale.y = Math.max(0.1, Math.abs(blink));
                
                // Color pulsing
                const pulse = Math.sin(frame * eye.userData.pulseSpeed + eye.userData.pulsePhase) * 0.5 + 1.0;
                eye.material.emissiveIntensity = pulse;
            }
        });
    }
    
    // Animate floating tentacles
    if (model.userData && model.userData.tentacles) {
        model.userData.tentacles.forEach(tentacle => {
            if (tentacle.userData) {
                // Sway tentacles
                const sway = Math.sin(frame * tentacle.userData.swaySpeed) * tentacle.userData.swayAmount;
                tentacle.rotation.z = sway * 0.3;
                
                // Animate individual segments
                tentacle.children.forEach(segment => {
                    if (segment.userData) {
                        const wave = Math.sin(frame * segment.userData.waveSpeed + segment.userData.waveOffset);
                        segment.position.x = wave * 0.1 * (segment.userData.segmentIndex + 1);
                    }
                });
            }
        });
    }
    
    // Animate ethereal wisps
    if (model.userData && model.userData.wisps) {
        model.userData.wisps.forEach(wisp => {
            if (wisp.userData) {
                // Orbit motion
                wisp.userData.orbitAngle += wisp.userData.orbitSpeed;
                wisp.position.x = Math.cos(wisp.userData.orbitAngle) * wisp.userData.orbitRadius;
                wisp.position.z = Math.sin(wisp.userData.orbitAngle) * wisp.userData.orbitRadius;
                
                // Vertical floating
                const verticalFloat = Math.sin(frame * wisp.userData.verticalSpeed + wisp.userData.verticalOffset) * 0.2;
                wisp.position.y += verticalFloat * 0.01;
                
                // Pulsing effect
                const pulse = Math.sin(frame * wisp.userData.pulseSpeed + wisp.userData.pulsePhase) * 0.4 + 0.6;
                wisp.material.opacity = pulse;
                wisp.scale.setScalar(pulse);
            }
        });
    }
    
    // Morph the main body slightly
    if (model.userData && model.userData.mainBody) {
        const morph = Math.sin(frame * model.userData.morphSpeed) * 0.05 + 1.0;
        model.userData.mainBody.scale.set(1.1 * morph, 0.9 / morph, 1.1 * morph);
    }
    break;

            }
        }

function createRainSystem() {
            const rainCount = isMobile ? 150 : 500;
            const rainGeometry = new THREE.BoxGeometry(0.03, 0.2, 0.03);
            const rainMaterial = new THREE.MeshBasicMaterial({
                color: 0x9ACEEB, // Light blue
                transparent: true,
                opacity: 0.6
            });
            
            for (let i = 0; i < rainCount; i++) {
                const raindrop = new THREE.Mesh(rainGeometry, rainMaterial);
                
                // Randomize positions in a large area around the player
                raindrop.position.set(
                    Math.random() * 80 - 40,
                    Math.random() * 30 + 10,
                    Math.random() * 80 - 100
                );
                
                // Set raindrop speed and properties
                raindrop.userData.speed = Math.random() * 0.3 + 0.2;
                raindrop.userData.horizontalSpeed = Math.random() * 0.05 - 0.025;
                raindrop.userData.weatherType = "rain";
                
                scene.add(raindrop);
                weatherParticles.push(raindrop);
            }
            
            // Target sky color for rain (not immediate)
            targetSkyColor = new THREE.Color(0x556677); // Darker sky
        }
        
        function createSnowSystem() {
            const snowCount = isMobile ? 120 : 400;
            const snowGeometry = new THREE.SphereGeometry(0.05, 6, 6);
            const snowMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            
            for (let i = 0; i < snowCount; i++) {
                const snowflake = new THREE.Mesh(snowGeometry, snowMaterial);
                
                // Randomize positions in a large area around the player
                snowflake.position.set(
                    Math.random() * 80 - 40,
                    Math.random() * 30 + 10,
                    Math.random() * 80 - 100
                );
                
                // Set snowflake speed and properties
                snowflake.userData.speed = Math.random() * 0.1 + 0.05;
                snowflake.userData.horizontalSpeed = Math.random() * 0.03 - 0.015;
                snowflake.userData.wobbleSpeed = Math.random() * 0.02 + 0.01;
                snowflake.userData.wobbleAmount = Math.random() * 0.1;
                snowflake.userData.wobblePosition = Math.random() * Math.PI * 2;
                snowflake.userData.weatherType = "snow";
                
                scene.add(snowflake);
                weatherParticles.push(snowflake);
            }
            
            // Target sky color for snow (gradual transition)
            targetSkyColor = new THREE.Color(0xc8d8f0); // Light blue-gray sky
        }
        
        function updateWeather() {
            // Progress the transition between weather types
            if (weatherTransitionProgress < 1) {
                weatherTransitionProgress += 0.005; // Slow transition
                
                // Gradually adjust the sky color
                scene.background.lerp(targetSkyColor, 0.005);
                
                // Gradually adjust light intensity based on target weather
                let targetIntensity = 0.8; // Default for clear
                if (targetWeather === "rain") {
                    targetIntensity = 0.5;
                } else if (targetWeather === "snow") {
                    targetIntensity = 0.7;
                }
                
                // Apply time of day modifications to target intensity
                if (time < 0.3 || time > 0.7) {
                    // Lower light during dawn/dusk/night
                    targetIntensity *= (time > 0.85 || time < 0.2) ? 0.4 : 0.75;
                }
                
                skyLight.intensity += (targetIntensity - skyLight.intensity) * 0.01;
                
                // Remove particles of the weather type we're transitioning away from
                if (targetWeather !== currentWeather && weatherTransitionProgress > 0.5) {
                    for (let i = weatherParticles.length - 1; i >= 0; i--) {
                        const particle = weatherParticles[i];
                        if (particle.userData.weatherType === currentWeather) {
                            // Fade out the particle
                            if (particle.material.opacity > 0.05) {
                                particle.material.opacity -= 0.05;
                            } else {
                                scene.remove(particle);
                                weatherParticles.splice(i, 1);
                            }
                        }
                    }
                    
                    // If we've removed all particles of the old type, and we need to create new ones
                    if (weatherParticles.length === 0 && targetWeather !== "clear") {
                        if (targetWeather === "rain") {
                            createRainSystem();
                        } else if (targetWeather === "snow") {
                            createSnowSystem();
                        }
                    }
                }
                
                // If transition is complete, update current weather
                if (weatherTransitionProgress >= 1) {
                    currentWeather = targetWeather;
                }
            }
            
            // Update weather particles
            for (let i = weatherParticles.length - 1; i >= 0; i--) {
                const particle = weatherParticles[i];
                
                if (particle.userData.weatherType === "rain") {
                    // Move raindrop down and slightly sideways
                    particle.position.y -= particle.userData.speed;
                    particle.position.x += particle.userData.horizontalSpeed;
                    particle.position.z += currentSpeed; // Move with scene
                    
                    // Reset if too low or behind camera
                    if (particle.position.y < -2 || particle.position.z > 10) {
                        particle.position.set(
                            Math.random() * 80 - 40,
                            Math.random() * 20 + 20,
                            Math.random() * 40 - 120
                        );
                    }
                } else if (particle.userData.weatherType === "snow") {
                    // Move snowflake down with wobble and slightly sideways
                    particle.position.y -= particle.userData.speed;
                    
                    // Add wobble effect
                    particle.userData.wobblePosition += particle.userData.wobbleSpeed;
                    particle.position.x += Math.sin(particle.userData.wobblePosition) * particle.userData.wobbleAmount + particle.userData.horizontalSpeed;
                    
                    particle.position.z += currentSpeed; // Move with scene
                    particle.rotation.y += 0.01; // Rotate snowflake
                    
                    // Reset if too low or behind camera
                    if (particle.position.y < -2 || particle.position.z > 10) {
                        particle.position.set(
                            Math.random() * 80 - 40,
                            Math.random() * 20 + 20,
                            Math.random() * 40 - 120
                        );
                        particle.userData.wobblePosition = Math.random() * Math.PI * 2;
                    }
                }
            }
            
            // Check if it's time to change weather
            weatherChangeCounter++;
            if (weatherChangeCounter > weatherChangeDuration) {
                const roll = Math.random();
                if (currentWeather === "clear") {
                    // 40% chance of rain, 20% chance of snow when clear
                    if (roll < 0.4) setWeather("rain");
                    else if (roll < 0.6) setWeather("snow");
                    else setWeather("clear");
                } else {
                    // 60% chance of clear when raining or snowing
                    if (roll < 0.6) setWeather("clear");
                    else if (currentWeather === "rain" && roll < 0.8) setWeather("snow");
                    else if (currentWeather === "snow" && roll < 0.8) setWeather("rain");
                    else setWeather(currentWeather);
                }
            }
            
            // Update time of day
            updateTimeOfDay();
        }
        
        function updateTimeOfDay() {
            time += timeCycleSpeed;
            if (time > 1) time = 0;
            
            // Calculate target sky color based on time
            let timeSkyColor;
            if (time < 0.25) { // Morning
                timeSkyColor = new THREE.Color(0x87CEEB).lerp(new THREE.Color(0xFFA07A), time * 4);
            } else if (time < 0.3) { // Sunrise
                timeSkyColor = new THREE.Color(0xFFA07A).lerp(new THREE.Color(0x87CEEB), (time - 0.25) * 20);
            } else if (time < 0.7) { // Day
                timeSkyColor = new THREE.Color(0x87CEEB);
            } else if (time < 0.8) { // Sunset
                timeSkyColor = new THREE.Color(0x87CEEB).lerp(new THREE.Color(0xFF7F50), (time - 0.7) * 10);
            } else if (time < 0.85) { // Dusk
                timeSkyColor = new THREE.Color(0xFF7F50).lerp(new THREE.Color(0x191970), (time - 0.8) * 20);
            } else { // Night
                timeSkyColor = new THREE.Color(0x191970);
            }
            
            // Blend weather sky color with time of day sky color
            if (currentWeather === "clear") {
                targetSkyColor = timeSkyColor;
            } else {
                // For weather conditions, gradually blend with time-of-day
                const weatherInfluence = 0.7; // Weather has 70% influence
                const timeInfluence = 1 - weatherInfluence;
                
                // Create a blended target
                const blendedTarget = targetSkyColor.clone();
                blendedTarget.lerp(timeSkyColor, timeInfluence);
                targetSkyColor = blendedTarget;
            }
            
            // Gradually shift sky color
            scene.background.lerp(targetSkyColor, 0.005);
            
            // Adjust light intensity based on time (smooth transition)
            let targetIntensity;
            if (time < 0.3 || time > 0.7) {
                // Lower light during dawn/dusk/night
                targetIntensity = (time > 0.85 || time < 0.2) ? 0.3 : 0.6;
            } else if (currentWeather === "clear") {
                // Full daylight
                targetIntensity = 0.8;
            } else if (currentWeather === "rain") {
                // Dimmer for rain
                targetIntensity = 0.5;
            } else if (currentWeather === "snow") {
                // Moderate for snow
                targetIntensity = 0.7;
            } else {
                targetIntensity = 0.8;
            }
            
            // Smooth transition for light intensity
            skyLight.intensity += (targetIntensity - skyLight.intensity) * 0.01;
            
            // Adjust light color based on time
            let targetLightColor;
            if (time < 0.3) { // Morning
                targetLightColor = new THREE.Color(0xFFD580);
            } else if (time < 0.7) { // Day
                targetLightColor = new THREE.Color(0xFFFFFF);
            } else if (time < 0.85) { // Evening
                targetLightColor = new THREE.Color(0xFFA07A);
            } else { // Night
                targetLightColor = new THREE.Color(0x4169E1);
            }
            
            // Smooth transition for light color
            skyLight.color.lerp(targetLightColor, 0.01);
        }
        
        function updateButterfliesAndBirds() {
            // Update butterflies
            for (let i = butterflyGroups.length - 1; i >= 0; i--) {
                const butterfly = butterflyGroups[i];
                
                // Move forward
                butterfly.position.add(butterfly.userData.moveDirection.clone().multiplyScalar(butterfly.userData.moveSpeed));
                
                // Animate wings
                butterfly.userData.wingPosition += butterfly.userData.wingSpeed;
                const leftWing = butterfly.children[0];
                const rightWing = butterfly.children[1];
                
                leftWing.rotation.z = Math.sin(butterfly.userData.wingPosition) * 0.5;
                rightWing.rotation.z = -Math.sin(butterfly.userData.wingPosition) * 0.5;
                
                // Change direction occasionally
                butterfly.userData.changeDirectionCounter++;
                if (butterfly.userData.changeDirectionCounter > butterfly.userData.changeDirectionTime) {
                    butterfly.userData.moveDirection = new THREE.Vector3(
                        Math.random() * 2 - 1,
                        Math.random() * 2 - 1,
                        Math.random() * 2 - 1
                    ).normalize();
                    butterfly.userData.changeDirectionCounter = 0;
                    butterfly.userData.changeDirectionTime = Math.floor(Math.random() * 100) + 50;
                }
                
                // Remove if too far
                if (butterfly.position.distanceTo(player.position) > 50) {
                    scene.remove(butterfly);
                    butterflyGroups.splice(i, 1);
                }
            }
            
            // Update birds
            for (let i = birds.length - 1; i >= 0; i--) {
                const bird = birds[i];
                
                // Move forward
                bird.position.z += currentSpeed + bird.userData.flySpeed;
                
                // Animate wings
                bird.userData.wingPosition += bird.userData.wingSpeed;
                const wings = bird.children[1];
                wings.rotation.z = Math.sin(bird.userData.wingPosition) * 0.3;
                
                // Remove if behind camera
                if (bird.position.z > 10) {
                    scene.remove(bird);
                    birds.splice(i, 1);
                }
            }
            
            // Spawn new butterflies/beetles occasionally - world-specific
if (Math.random() < 0.005 && butterflyGroups.length < mobileButterflyLimit && currentWeather === "clear") {
    const x = Math.random() * 40 - 20;
    const y = Math.random() * 3 + 1;
    const z = Math.random() * 20 - 40;
    
    if (currentWorld === 'desert') {
        // Desert beetles instead of butterflies
        butterflyGroups.push(createDesertBeetle(x, y, z));
    } else {
        // Regular butterflies for classic and forest
        butterflyGroups.push(createButterfly(x, y, z));
    }
}
            
            // Spawn new birds occasionally - world-specific types
if (Math.random() < 0.002 && birds.length < mobileBirdsLimit) {
    const x = Math.random() * 60 - 30;
    const y = Math.random() * 10 + 10;
    const z = -100;
    
    // Different birds for different worlds
    if (currentWorld === 'desert') {
        // Vultures and desert birds fly higher
        const desertY = Math.random() * 15 + 15;
        birds.push(createBird(x, desertY, z));
    } else {
        // Regular birds for classic and forest
        birds.push(createBird(x, y, z));
    }
}
}

// Create desert beetle animation
function createDesertBeetle(x, y, z) {
    const beetleGroup = new THREE.Group();
    
    // Beetle colors - desert themed
    const beetleColors = [
        0x8B4513, // Saddle brown
        0xA0522D, // Sienna  
        0x654321, // Dark brown
        0x2F4F4F, // Dark slate gray
        0x556B2F, // Dark olive green
        0x8B7355  // Burlywood
    ];
    
    const color = beetleColors[Math.floor(Math.random() * beetleColors.length)];
    
    // Beetle body - more elongated than butterfly
    const bodyGeometry = new THREE.CapsuleGeometry(0.02, 0.15, 4, 8);
    const bodyMaterial = new THREE.MeshStandardMaterial({
        color: 0x000000, // Black body
        metalness: 0.7,
        roughness: 0.3
    });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.rotation.x = Math.PI / 2;
    beetleGroup.add(body);
    
    // Beetle wing covers (elytra) - hard wing cases using boxes
const wingGeometry = new THREE.BoxGeometry(0.06, 0.02, 0.2);
const wingMaterial = new THREE.MeshStandardMaterial({
    color: color,
    metalness: 0.8,
    roughness: 0.2
});

const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
leftWing.position.set(-0.05, 0, 0);
beetleGroup.add(leftWing);

const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
rightWing.position.set(0.05, 0, 0);
beetleGroup.add(rightWing);

// Add beetle head
const headGeometry = new THREE.SphereGeometry(0.04, 8, 8);
const headMaterial = new THREE.MeshStandardMaterial({
    color: 0x000000,
    metalness: 0.6,
    roughness: 0.4
});
const head = new THREE.Mesh(headGeometry, headMaterial);
head.position.z = 0.1;
beetleGroup.add(head);
    
    // Antennae
    for (let i = 0; i < 2; i++) {
        const antennaGeometry = new THREE.CylinderGeometry(0.005, 0.005, 0.1, 4);
        const antennaMaterial = new THREE.MeshStandardMaterial({
            color: 0x000000
        });
        const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
        antenna.position.set(i === 0 ? -0.02 : 0.02, 0, 0.08);
        antenna.rotation.z = (i === 0 ? -1 : 1) * Math.PI / 6;
        beetleGroup.add(antenna);
    }
    
    // Position beetle
    beetleGroup.position.set(x, y, z);
    
    // Add animation properties (beetles fly differently than butterflies)
    beetleGroup.userData.wingSpeed = Math.random() * 0.15 + 0.2; // Faster wing beat
    beetleGroup.userData.wingPosition = 0;
    beetleGroup.userData.moveSpeed = Math.random() * 0.02 + 0.015; // Slightly faster movement
    beetleGroup.userData.moveDirection = new THREE.Vector3(
        Math.random() * 2 - 1,
        Math.random() * 2 - 1,
        Math.random() * 2 - 1
    ).normalize();
    beetleGroup.userData.changeDirectionCounter = 0;
    beetleGroup.userData.changeDirectionTime = Math.floor(Math.random() * 80) + 40; // More erratic movement
    
    scene.add(beetleGroup);
    return beetleGroup;
}
        
        // Create butterfly animation
        function createButterfly(x, y, z) {
            const butterflyGroup = new THREE.Group();
            
            // Butterfly colors
            const colors = [
                0xFF7F50, // Coral
                0xFFB6C1, // Light Pink
                0x4682B4, // Steel Blue
                0xFFA500, // Orange
                0xBDB76B, // Dark Khaki
                0xADFF2F  // Green Yellow
            ];
            
            const color = colors[Math.floor(Math.random() * colors.length)];
            
            // Wings
            const wingGeometry = new THREE.CircleGeometry(0.3, 16, 0, Math.PI);
            const wingMaterial = new THREE.MeshBasicMaterial({
                color: color,
                side: THREE.DoubleSide
            });
            
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.rotation.x = Math.PI / 2;
            leftWing.rotation.y = Math.PI / 2;
            leftWing.position.x = -0.15;
            butterflyGroup.add(leftWing);
            
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.rotation.x = Math.PI / 2;
            rightWing.rotation.y = -Math.PI / 2;
            rightWing.position.x = 0.15;
            butterflyGroup.add(rightWing);
            
            // Body
            const bodyGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.3, 8);
            const bodyMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000 // Black
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.x = Math.PI / 2;
            butterflyGroup.add(body);
            
            // Position butterfly
            butterflyGroup.position.set(x, y, z);
            
            // Add animation properties
            butterflyGroup.userData.wingSpeed = Math.random() * 0.1 + 0.1;
            butterflyGroup.userData.wingPosition = 0;
            butterflyGroup.userData.moveSpeed = Math.random() * 0.03 + 0.01;
            butterflyGroup.userData.moveDirection = new THREE.Vector3(
                Math.random() * 2 - 1,
                Math.random() * 2 - 1,
                Math.random() * 2 - 1
            ).normalize();
            butterflyGroup.userData.changeDirectionCounter = 0;
            butterflyGroup.userData.changeDirectionTime = Math.floor(Math.random() * 100) + 50;
            
            scene.add(butterflyGroup);
            return butterflyGroup;
        }
        
        // Create birds
        function createBird(x, y, z) {
            const birdGroup = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const bodyMaterial = new THREE.MeshBasicMaterial({
                color: Math.random() > 0.5 ? 0x555555 : 0x777777 // Gray birds
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            birdGroup.add(body);
            
            // Wings
            const wingGeometry = new THREE.BoxGeometry(0.6, 0.02, 0.2);
            const wingMaterial = new THREE.MeshBasicMaterial({
                color: bodyMaterial.color,
                side: THREE.DoubleSide
            });
            
            const wings = new THREE.Mesh(wingGeometry, wingMaterial);
            wings.position.y = 0.08;
            birdGroup.add(wings);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const headMaterial = new THREE.MeshBasicMaterial({
                color: bodyMaterial.color
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.z = 0.15;
            head.position.y = 0.04;
            birdGroup.add(head);
            
            // Beak
            const beakGeometry = new THREE.ConeGeometry(0.03, 0.1, 8);
            const beakMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFD700 // Gold
            });
            const beak = new THREE.Mesh(beakGeometry, beakMaterial);
            beak.rotation.x = -Math.PI / 2;
            beak.position.z = 0.25;
            beak.position.y = 0.04;
            birdGroup.add(beak);
            
            // Position bird
            birdGroup.position.set(x, y, z);
            birdGroup.rotation.y = Math.PI; // Face forward
            
            // Add animation properties
            birdGroup.userData.wingSpeed = Math.random() * 0.1 + 0.2;
            birdGroup.userData.wingPosition = 0;
            birdGroup.userData.flySpeed = Math.random() * 0.1 + 0.15;
            
            scene.add(birdGroup);
            return birdGroup;
        }

// Toggle settings screen visibility
        function toggleSettingsScreen() {
            const settingsScreen = document.getElementById('settingsScreen');
            const modalOverlay = document.getElementById('modalOverlay');
            
            if (settingsScreen.style.display === 'flex') {
                closeSettingsScreen();
            } else {
                // Set the active tab back to the first tab
                document.querySelectorAll('.tab-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.querySelector('.tab-button').classList.add('active');
                document.getElementById('settings-tab').classList.add('active');
                
                // Update character display in settings
                updateCharactersInSettings();
                
                // Update mod mode display
                /*
                if (modModeEnabled) {
                    document.getElementById('mod-mode-option').classList.add('enabled');
                    document.getElementById('modModeButton').textContent = 'Disable';
                } else {
                    document.getElementById('mod-mode-option').classList.remove('enabled');
                    document.getElementById('modModeButton').textContent = 'Enable';
                }
                    */
                
                // Update leaderboard
                updateLeaderboardDisplay();
                
                // Show settings and overlay
                settingsScreen.style.display = 'flex';
                modalOverlay.style.display = 'block';
                
                // Pause the game if it's running
                if (gameState === "playing") {
                    gamePaused = true;
                    gameState = "paused";
                }
            }
        }
        
        // Close settings screen
        function closeSettingsScreen() {
    // Stop any playing preview
    if (window.previewMusic && window.previewMusic.playing) {
        stopPreview();
    }

    // Hide old settings
    document.getElementById('settingsScreen').style.display = 'none';
    document.getElementById('modalOverlay').style.display = 'none';
    
    // Hide new settings
    const settingsDiv = document.getElementById('settings');
    if (settingsDiv) {
        settingsDiv.classList.remove('active');
        setTimeout(() => {
            settingsDiv.style.display = 'none';
        }, 300);
    }
    
    // Check where to return to based on game state
    if (gameState === "settings") {
        backToMainMenu();
    } else if (gameState === "paused") {
        document.getElementById('pauseScreen').style.display = 'flex';
    } else if (gameState === "gameOver") {
        document.getElementById('gameOver').style.display = 'flex';
    }
}
        
        // Toggle mod mode on/off
        function toggleModMode() {
            const password = document.getElementById('modPassword').value;
            
            if (!modModeEnabled) {
    // Trying to enable mod mode
    if (password === MOD_PASSWORD) {
        modModeEnabled = true;
        document.getElementById('mod-mode-option').classList.add('enabled');
        document.getElementById('modModeButton').textContent = 'Disable';
        
        // Show difficulty override option
        document.getElementById('difficulty-override-option').style.display = 'flex';
        
        // Unlock all characters
        unlockedCharacters.apple = true;
        unlockedCharacters.carrot = true;
        unlockedCharacters.pumpkin = true;
        unlockedCharacters.happyface = true;
        unlockedCharacters.monster = true;
        unlockedCharacters.atom = true;
        unlockedCharacters.slime = true;
        unlockedCharacters.ufo = true;

        // Unlock all worlds
availableWorlds.forEach(world => {
    unlockedWorlds[world.id] = true;
});
        
        // Update UI
        updateCharactersInSettings();
        
        alert('Mod Mode enabled! All characters unlocked + Difficulty Override available.');
    } else {
        alert('Incorrect password!');
    }
} else {
    // Disabling mod mode
    modModeEnabled = false;
    document.getElementById('mod-mode-option').classList.remove('enabled');
    document.getElementById('modModeButton').textContent = 'Enable';
    document.getElementById('modPassword').value = '';
    
    // Hide difficulty override option
    document.getElementById('difficulty-override-option').style.display = 'none';
    difficultyOverride = -1; // Reset to normal
    
    // Reload the original unlocked state
    loadGameData(true);
    
    alert('Mod Mode disabled.');
}
            
            saveGameData('settings_change');



        }

// Apply difficulty override for testing
function applyDifficultyOverride() {
    const selectedLevel = parseInt(document.getElementById('difficultyOverride').value);
    difficultyOverride = selectedLevel;
    
    if (selectedLevel === -1) {
        alert('Difficulty override disabled. Using normal time-based progression.');
        // Reset to normal progression
        if (gameStarted && !gameOver) {
            resetDynamicDifficulty();
        }
    } else {
        const levelNames = ['Cruise', 'Accelerating', 'Intense', 'Blazing', 'Maximum Chaos'];
        alert(`Difficulty forced to Level ${selectedLevel + 1}: ${levelNames[selectedLevel]}`);
        
        // Immediately apply the override with full parameters
        currentSpeedLevel = selectedLevel;
        
        // Manually set speed based on level
        currentSpeed = baseSpeed + (currentSpeedLevel * speedIncrement);
        currentSpeed = Math.min(currentSpeed, maxSpeed);
        
        // Update speed multiplier for display
        currentSpeedMultiplier = currentSpeed / baseSpeed;
        
        // Update spawn rates based on level
        const speedProgress = currentSpeedLevel / speedIncreaseIntervals.length;
        if (currentSpeedLevel >= 3) {
            const adjustedProgress = 0.7 + (currentSpeedLevel - 3) * 0.15;
            currentObstacleSpawnRate = Math.floor(Math.max(
                baseObstacleSpawnRate - (adjustedProgress * (baseObstacleSpawnRate - minObstacleSpawnRate)),
                currentSpeedLevel >= 4 ? 25 : minObstacleSpawnRate
            ));
        } else {
            currentObstacleSpawnRate = Math.floor(Math.max(
                baseObstacleSpawnRate - (speedProgress * (baseObstacleSpawnRate - minObstacleSpawnRate)),
                minObstacleSpawnRate
            ));
        }
        
        // Update stream spawn rate
        if (currentSpeedLevel >= 3) {
            currentStreamSpawnRate = Math.floor(baseStreamSpawnRate * 1.2);
        } else {
            currentStreamSpawnRate = Math.floor(Math.max(
                baseStreamSpawnRate - (speedProgress * 0.2 * (baseStreamSpawnRate - minStreamSpawnRate)),
                minStreamSpawnRate
            ));
        }
        
        // Update visual speed indicator
        updateSpeedIndicator();
        
        console.log(`Forced Level: ${currentSpeedLevel}, Speed: ${currentSpeed.toFixed(2)}, Obstacle Rate: ${currentObstacleSpawnRate}`);
    }
}
        
        // Reset game data
        function resetGameData() {
            if (confirm('Are you sure you want to reset all game data? This cannot be undone.')) {
                // Clear localStorage
                localStorage.removeItem('endlessRunnerData');
                
                // Reset game variables
totalCoins = 0;
modModeEnabled = false;
unlockedCharacters = {
    apple: true,
    carrot: false,
    pumpkin: false,
    happyface: false,
    monster: false,
    atom: false,
    slime: false,
    ufo: false
};
unlockedWorlds = {
    classic: true
};
currentCharacter = 'apple';
currentWorld = 'classic';
                
                // Update UI
                document.getElementById('mod-mode-option').classList.remove('enabled');
                document.getElementById('modModeButton').textContent = 'Enable';
                document.getElementById('modPassword').value = '';
                updateTotalCoins();
                updateCharactersInSettings();
                
                // Recreate player with default character
                createPlayer();
                
                alert('Game data has been reset.');
            }
        }
        
        // Load textures
        function loadTextures() {
            const textureLoader = new THREE.TextureLoader();
            
            // Create procedural grass texture for simplicity and guaranteed loading
            const grassCanvas = document.createElement('canvas');
            grassCanvas.width = 512;
            grassCanvas.height = 512;
            const grassCtx = grassCanvas.getContext('2d');
            
            // Base color - grass green
            grassCtx.fillStyle = '#4CAF50';
            grassCtx.fillRect(0, 0, 512, 512);
            
            // Add some texture/variation
            for (let i = 0; i < 2000; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const size = Math.random() * 3 + 1;
                const brightness = Math.random() * 30 - 15;
                
                // Random shade of green
                const r = Math.max(0, Math.min(255, 76 + brightness));
                const g = Math.max(0, Math.min(255, 175 + brightness));
                const b = Math.max(0, Math.min(255, 80 + brightness));
                
                grassCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                grassCtx.fillRect(x, y, size, size);
            }
            
            // Create some grass blades
            for (let i = 0; i < 400; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const height = Math.random() * 10 + 5;
                const width = Math.random() * 2 + 1;
                
                grassCtx.fillStyle = '#2E7D32'; // Darker green for blades
                grassCtx.fillRect(x, y, width, height);
            }
            
            grassTexture = new THREE.CanvasTexture(grassCanvas);
            grassTexture.wrapS = THREE.RepeatWrapping;
            grassTexture.wrapT = THREE.RepeatWrapping;
            grassTexture.repeat.set(3, 20);
            
            // Create procedural water texture
            const waterCanvas = document.createElement('canvas');
            waterCanvas.width = 512;
            waterCanvas.height = 512;
            const waterCtx = waterCanvas.getContext('2d');
            
            // Base color - water blue
            waterCtx.fillStyle = '#1E88E5';
            waterCtx.fillRect(0, 0, 512, 512);
            
            // Add some wave effect
            for (let y = 0; y < 512; y += 8) {
                for (let x = 0; x < 512; x += 1) {
                    const brightness = Math.sin(y * 0.05 + x * 0.03) * 20;
                    const r = Math.max(0, Math.min(255, 30 + brightness));
                    const g = Math.max(0, Math.min(255, 136 + brightness));
                    const b = Math.max(0, Math.min(255, 229 + brightness));
                    
                    waterCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    waterCtx.fillRect(x, y, 1, 4);
                }
            }
            
            // Add some highlights
            for (let i = 0; i < 300; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const size = Math.random() * 2 + 1;
                
                waterCtx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                waterCtx.fillRect(x, y, size, size);
            }
            
            waterTexture = new THREE.CanvasTexture(waterCanvas);
            waterTexture.wrapS = THREE.RepeatWrapping;
            waterTexture.wrapT = THREE.RepeatWrapping;
            waterTexture.repeat.set(5, 1);
        }
        
        // Create ground with grass texture
function createGround() {
    // Create ground geometry
    const groundGeometry = new THREE.BoxGeometry(10, 0.5, 100);

    // Create material based on current world
    let groundMaterial;
    if (currentWorld === 'forest') {
        groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x2F4F2F, // Dark forest floor
            roughness: 0.9
        });
    } else if (currentWorld === 'desert') {
        groundMaterial = new THREE.MeshStandardMaterial({
            color: 0xF4A460, // Sandy brown
            roughness: 0.8
        });
    } else {
        // Classic world - use grass texture
        groundMaterial = new THREE.MeshStandardMaterial({
            map: grassTexture,
            roughness: 0.8,
            color: 0xffffff
        });
    }
    
    // Create multiple ground segments to ensure continuous ground coverage
    const numSegments = 8;
    
    for (let i = 0; i < numSegments; i++) {
        const segment = new THREE.Mesh(groundGeometry, groundMaterial);
        segment.position.y = -0.25;
        segment.position.z = -45 - (i * 50);
        scene.add(segment);
        groundSegments.push(segment);
        
        // Add dirt sides to each ground segment
        const dirtGeometry = new THREE.BoxGeometry(12, 1, 50.1);
        // Create dirt material based on world
        let dirtMaterial;
        if (currentWorld === 'forest') {
            dirtMaterial = new THREE.MeshStandardMaterial({
                color: 0x654321, // Dark brown forest soil
                roughness: 1
            });
        } else if (currentWorld === 'desert') {
            dirtMaterial = new THREE.MeshStandardMaterial({
                color: 0xCD853F, // Sandy rock color
                roughness: 0.9
            });
        } else {
            dirtMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513, // Classic brown dirt
                roughness: 1
            });
        }

        const dirtSide = new THREE.Mesh(dirtGeometry, dirtMaterial);
        dirtSide.position.y = -0.75;
        dirtSide.position.z = segment.position.z;
        scene.add(dirtSide);

        // Create side terrain material based on world
        let sideTerrainMaterial;
        if (currentWorld === 'forest') {
            sideTerrainMaterial = new THREE.MeshStandardMaterial({
                color: 0x1F4F2F, // Very dark forest green
                roughness: 1.0
            });
        } else if (currentWorld === 'desert') {
            sideTerrainMaterial = new THREE.MeshStandardMaterial({
                color: 0xDEB887, // Desert sand color
                roughness: 0.9
            });
        } else {
            // Classic world - use grass texture
            const wildGrassTexture = grassTexture.clone();
            wildGrassTexture.repeat.set(5, 30);
            sideTerrainMaterial = new THREE.MeshStandardMaterial({
                map: wildGrassTexture,
                roughness: 0.9,
                color: 0x88AA88
            });
        }

        // Left side terrain
        const leftTerrainGeometry = new THREE.BoxGeometry(50, 0.3, 100);
        const leftTerrain = new THREE.Mesh(leftTerrainGeometry, sideTerrainMaterial);
        leftTerrain.position.y = -0.15;
        leftTerrain.position.x = -30;
        leftTerrain.position.z = segment.position.z;
        scene.add(leftTerrain);
        sideTerrainSegments.push(leftTerrain);

        // Right side terrain
        const rightTerrainGeometry = new THREE.BoxGeometry(50, 0.3, 100);
        const rightTerrain = new THREE.Mesh(rightTerrainGeometry, sideTerrainMaterial);
        rightTerrain.position.y = -0.15;
        rightTerrain.position.x = 30;
        rightTerrain.position.z = segment.position.z;
        scene.add(rightTerrain);
        sideTerrainSegments.push(rightTerrain);

        // Left dirt underneath
        const leftDirtGeometry = new THREE.BoxGeometry(50, 1, 100);
        const leftDirt = new THREE.Mesh(leftDirtGeometry, dirtMaterial);
        leftDirt.position.y = -0.6;
        leftDirt.position.x = -30;
        leftDirt.position.z = segment.position.z;
        scene.add(leftDirt);
        sideTerrainSegments.push(leftDirt);

        // Right dirt underneath
        const rightDirtGeometry = new THREE.BoxGeometry(50, 1, 100);
        const rightDirt = new THREE.Mesh(rightDirtGeometry, dirtMaterial);
        rightDirt.position.y = -0.6;
        rightDirt.position.x = 30;
        rightDirt.position.z = segment.position.z;
        scene.add(rightDirt);
        sideTerrainSegments.push(rightDirt);
    }
}
        
        // Create a simple water stream with minimal visual effects
        function createWaterStream() {
            const streamGroup = new THREE.Group();
            
            // Water surface - spans way beyond visible area to look infinite
const waterGeometry = new THREE.BoxGeometry(150, 0.25, 3); // Much wider - extends off screen
const waterMaterial = new THREE.MeshStandardMaterial({
    color: 0x1E88E5, // Deep blue water
    roughness: 0.1,
    metalness: 0.3,
    // No transparency - this prevents flickering
});

const water = new THREE.Mesh(waterGeometry, waterMaterial);
water.position.y = -0.05; // Align with ground level
streamGroup.add(water);

// Add water surface highlights for realism
const highlightGeometry = new THREE.BoxGeometry(150, 0.01, 3); // Match full width
const highlightMaterial = new THREE.MeshStandardMaterial({
    color: 0x87CEEB, // Light blue highlight
    roughness: 0.05,
    metalness: 0.8,
    emissive: 0x003366,
    emissiveIntensity: 0.2
});

const highlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
highlight.position.y = 0.08; // On top of water
streamGroup.add(highlight);

// Clean river banks with better positioning
const bankGeometry = new THREE.BoxGeometry(150, 0.4, 0.6); // Full width banks
const bankMaterial = new THREE.MeshStandardMaterial({
    color: 0x8B4513, // Brown
    roughness: 0.9
});

// Front bank - positioned to create clean edge
const frontBank = new THREE.Mesh(bankGeometry, bankMaterial);
frontBank.position.z = -1.8;
frontBank.position.y = 0.05;
streamGroup.add(frontBank);

// Back bank - positioned to create clean edge
const backBank = new THREE.Mesh(bankGeometry, bankMaterial);
backBank.position.z = 1.8;
backBank.position.y = 0.05;
streamGroup.add(backBank);

// Add some sandy/muddy edges for realism
const edgeGeometry = new THREE.BoxGeometry(150, 0.1, 0.2); // Full width edges
const edgeMaterial = new THREE.MeshStandardMaterial({
    color: 0xD2B48C, // Sandy color
    roughness: 0.8
});

// Front edge
const frontEdge = new THREE.Mesh(edgeGeometry, edgeMaterial);
frontEdge.position.z = -1.4;
frontEdge.position.y = 0.02;
streamGroup.add(frontEdge);

// Back edge
const backEdge = new THREE.Mesh(edgeGeometry, edgeMaterial);
backEdge.position.z = 1.4;
backEdge.position.y = 0.02;
streamGroup.add(backEdge);
            
            // Add rocks and logs for visual interest only
            const numObjects = Math.floor(Math.random() * 3) + 2; // 2-4 objects
            
            for (let i = 0; i < numObjects; i++) {
                // 50% chance for rock, 50% chance for log
                const isRock = Math.random() > 0.5;
                
                if (isRock) {
                    const rockGeometry = new THREE.DodecahedronGeometry(0.2, 1);
                    const rockMaterial = new THREE.MeshStandardMaterial({
                        color: 0x808080,
                        roughness: 0.8
                    });
                    
                    const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                    rock.position.set(
                        Math.random() * 8 - 4,
                        0.1,
                        Math.random() * 2 - 1
                    );
                    rock.rotation.set(
                        Math.random() * Math.PI,
                        Math.random() * Math.PI,
                        Math.random() * Math.PI
                    );
                    streamGroup.add(rock);
                } else {
                    // Small log sticking out of water
                    const logGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
                    const logMaterial = new THREE.MeshStandardMaterial({
                        color: 0x8B4513,
                        roughness: 0.9
                    });
                    
                    const log = new THREE.Mesh(logGeometry, logMaterial);
                    log.position.set(
                        Math.random() * 8 - 4,
                        0.2,
                        Math.random() * 2 - 1
                    );
                    // Tilt the log
                    log.rotation.x = Math.random() * 0.3;
                    log.rotation.z = Math.random() * Math.PI;
                    streamGroup.add(log);
                }
            }
            
            // Position stream on the track
            streamGroup.position.z = -50; // Spawn far away
            streamGroup.position.y = 0;   // Align with ground
            
            scene.add(streamGroup);
            waterStreams.push(streamGroup);
            streamCreated = true;
            
            return streamGroup;
        }
        
        // Simplest possible water streams update - only moves them forward with no animations
        function updateWaterStreams() {
            for (let i = waterStreams.length - 1; i >= 0; i--) {
                const stream = waterStreams[i];
                
                // Just move stream forward
                stream.position.z += currentSpeed;
                
                // Check for collision
                if (checkCollision(stream)) {
                    if (!jumping) {
                        // Hit water stream without jumping - game over
                        endGame();
                    }
                }
                
                // Remove streams that have passed the player
                if (stream.position.z > 10) {
                    scene.remove(stream);
                    waterStreams.splice(i, 1);
                }
            }
        }
        
        // Create background scenery
        function createBackground() {
            // Create world-specific background
if (currentWorld === 'desert') {
    // Create desert mountains/mesas
    for (let i = 0; i < 15; i++) {
        const mesaHeight = Math.random() * 10 + 5;
        const mesaWidth = Math.random() * 12 + 8;
        
        // Flat-topped mesa
        const mesaGeometry = new THREE.CylinderGeometry(mesaWidth, mesaWidth * 1.2, mesaHeight, 8);
        const mesaMaterial = new THREE.MeshStandardMaterial({
            color: 0xCD853F, // Sandy rock color
            flatShading: true,
            roughness: 0.8
        });
        
        const mesa = new THREE.Mesh(mesaGeometry, mesaMaterial);
        
        // Position mesas in the background
        const distance = Math.random() * 400 + 150;
        const posX = Math.random() * 300 - 150;
        mesa.position.set(posX, mesaHeight / 2 - 3, -distance);
        
        scene.add(mesa);
    }
    
    // Add distant sand dunes
    for (let i = 0; i < 25; i++) {
        const duneGeometry = new THREE.SphereGeometry(Math.random() * 20 + 10, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
        const duneMaterial = new THREE.MeshStandardMaterial({
            color: 0xF4A460,
            roughness: 0.9
        });
        const dune = new THREE.Mesh(duneGeometry, duneMaterial);
        
        const distance = Math.random() * 200 + 80;
        const posX = Math.random() * 400 - 200;
        dune.position.set(posX, -2, -distance);
        dune.scale.set(1, 0.3, 1);
        
        scene.add(dune);
    }
} else if (currentWorld === 'forest') {
    // Create forest mountains
    for (let i = 0; i < 20; i++) {
        const mountainHeight = Math.random() * 15 + 8;
        const mountainWidth = Math.random() * 8 + 5;
        
        const mountainGeometry = new THREE.ConeGeometry(mountainWidth, mountainHeight, 16);
        const mountainMaterial = new THREE.MeshStandardMaterial({
            color: 0x2F4F2F, // Dark forest green
            flatShading: true,
            roughness: 0.9
        });
        
        const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
        
        // Position mountains in the background
        const distance = Math.random() * 300 + 100;
        const posX = Math.random() * 200 - 100;
        mountain.position.set(posX, mountainHeight / 2 - 5, -distance);
        
        scene.add(mountain);
    }
} else {
    // Classic world mountains with snow caps
    for (let i = 0; i < 20; i++) {
        const mountainHeight = Math.random() * 15 + 8;
        const mountainWidth = Math.random() * 8 + 5;
        
        const mountainGeometry = new THREE.ConeGeometry(mountainWidth, mountainHeight, 16);
        const mountainMaterial = new THREE.MeshStandardMaterial({
            color: 0x808080, // Gray for mountains
            flatShading: true,
            roughness: 0.9
        });
        
        const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
        
        // Add snow cap to mountain
        const snowCapGeometry = new THREE.ConeGeometry(mountainWidth * 0.7, mountainHeight * 0.2, 16);
        const snowMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff, // White for snow
            roughness: 0.5
        });
        const snowCap = new THREE.Mesh(snowCapGeometry, snowMaterial);
        snowCap.position.y = mountainHeight * 0.4;
        mountain.add(snowCap);
        
        // Position mountains in the background
        const distance = Math.random() * 300 + 100;
        const posX = Math.random() * 200 - 100;
        mountain.position.set(posX, mountainHeight / 2 - 5, -distance);
        
        scene.add(mountain);
    }
}
            
            // Create a sun in the sky
            const sunGeometry = new THREE.SphereGeometry(10, 32, 32);
            const sunMaterial = new THREE.MeshStandardMaterial({
                color: 0xffff00, // Yellow
                emissive: 0xffff00,
                emissiveIntensity: 1
            });
            const sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.position.set(70, 50, -300);
            scene.add(sun);
            
            // Create a moon
            const moonGeometry = new THREE.SphereGeometry(7, 32, 32);
            const moonMaterial = new THREE.MeshStandardMaterial({
                color: 0xDDDDDD, // Off-white
                emissive: 0xDDDDDD,
                emissiveIntensity: 0.5
            });
            const moon = new THREE.Mesh(moonGeometry, moonMaterial);
            moon.position.set(-70, 50, -300);
            scene.add(moon);
            
            // Add more detailed clouds
        for (let i = 0; i < (isMobile ? 15 : 30); i++) {
                const cloudGroup = new THREE.Group();
                
                // Create several spheres for a cloud with more variety
                const numSpheres = Math.floor(Math.random() * 5) + 5;
                for (let j = 0; j < numSpheres; j++) {
                    const size = Math.random() * 4 + 3;
                    const sphereGeometry = new THREE.SphereGeometry(size, 8, 8);
                    const cloudMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        roughness: 0.2,
                        metalness: 0
                    });
                    
                    const sphere = new THREE.Mesh(sphereGeometry, cloudMaterial);
                    sphere.position.set(
                        (Math.random() - 0.5) * 15,
                        (Math.random() - 0.5) * 3,
                        (Math.random() - 0.5) * 15
                    );
                    cloudGroup.add(sphere);
                }
                
                // Position cloud in sky with wider spread
                const distance = Math.random() * 400 + 100;
                const posX = Math.random() * 300 - 150;
                const posY = Math.random() * 40 + 20;
                cloudGroup.position.set(posX, posY, -distance);
                
                scene.add(cloudGroup);
            }
            
            // Add world-specific distant vegetation
if (currentWorld === 'desert') {
    // Add scattered desert plants
    for (let i = 0; i < (isMobile ? 20 : 80); i++) {
        const desertPlantGroup = new THREE.Group();
        
        // Random desert plant type
        const plantType = Math.random();
        
        if (plantType < 0.6) {
            // Small cactus
            const cactusGeometry = new THREE.CylinderGeometry(0.3, 0.4, 3, 8);
            const cactusMaterial = new THREE.MeshStandardMaterial({
                color: 0x228B22,
                roughness: 0.8
            });
            const cactus = new THREE.Mesh(cactusGeometry, cactusMaterial);
            cactus.position.y = 1.5;
            desertPlantGroup.add(cactus);
        } else {
            // Palm tree
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 4, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.8
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2;
            desertPlantGroup.add(trunk);
            
            // Palm fronds
            for (let j = 0; j < 6; j++) {
                const frondGeometry = new THREE.PlaneGeometry(0.5, 3);
                const frondMaterial = new THREE.MeshStandardMaterial({
                    color: 0x228B22,
                    side: THREE.DoubleSide
                });
                const frond = new THREE.Mesh(frondGeometry, frondMaterial);
                frond.position.y = 4.5;
                frond.rotation.y = (j / 6) * Math.PI * 2;
                frond.rotation.x = -Math.PI / 6;
                desertPlantGroup.add(frond);
            }
        }
        
        // Position at horizon
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 100 + 150;
        desertPlantGroup.position.set(
            Math.cos(angle) * radius,
            -5,
            -Math.sin(angle) * radius
        );
        
        scene.add(desertPlantGroup);
    }
} else if (currentWorld === 'forest') {
    // Dense dark forest
    for (let i = 0; i < (isMobile ? 80 : 300); i++) {
        const treeGroup = new THREE.Group();
        
        // Dark forest tree
        const trunkGeometry = new THREE.CylinderGeometry(1, 1.2, 8, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({
            color: 0x654321,
            roughness: 0.8
        });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.y = 4;
        treeGroup.add(trunk);
        
        // Dark pine-like canopy
        const leavesGeometry = new THREE.ConeGeometry(4, 12, 8);
        const leavesMaterial = new THREE.MeshStandardMaterial({
            color: 0x1F4F2F, // Very dark green
            roughness: 0.8
        });
        
        const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
        leaves.position.y = 10;
        treeGroup.add(leaves);
        
        // Position trees at horizon
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 100 + 150;
        treeGroup.position.set(
            Math.cos(angle) * radius,
            -5,
            -Math.sin(angle) * radius
        );
        
        scene.add(treeGroup);
    }
} else {
    // Classic world forest
    for (let i = 0; i < (isMobile ? 50 : 200); i++) {
        const treeGroup = new THREE.Group();
        
        // Tree trunk
        const trunkGeometry = new THREE.CylinderGeometry(1, 1.2, 5, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B4513,
            roughness: 0.7
        });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.y = 2.5;
        treeGroup.add(trunk);
        
        // Tree leaves - layered cones for more natural look
        const leavesGeometry = new THREE.ConeGeometry(3, 8, 8);
        const leavesMaterial = new THREE.MeshStandardMaterial({
            color: 0x228B22,
            roughness: 0.6
        });
        
        const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
        leaves.position.y = 7;
        treeGroup.add(leaves);
        
        // Position trees at horizon
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 100 + 150;
        treeGroup.position.set(
            Math.cos(angle) * radius,
            -5,
            -Math.sin(angle) * radius
        );
        
        // Add to scene
        scene.add(treeGroup);
    }
}
            
            // Add some hills in mid-distance
            for (let i = 0; i < 15; i++) {
                const hillGeometry = new THREE.SphereGeometry(20, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
                const hillMaterial = new THREE.MeshStandardMaterial({
                    color: 0x4CAF50, // Green
                    roughness: 0.8
                });
                
                const hill = new THREE.Mesh(hillGeometry, hillMaterial);
                
                // Position hill
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 60 + 80;
                hill.position.set(
                    Math.cos(angle) * radius,
                    -20,
                    -Math.sin(angle) * radius
                );
                
                scene.add(hill);
            }
            
            // Add some butterflies
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * 40 - 20;
                const y = Math.random() * 3 + 1;
                const z = Math.random() * 20 - 40;
                butterflyGroups.push(createButterfly(x, y, z));
            }
            
            // Add some birds
            for (let i = 0; i < 3; i++) {
                const x = Math.random() * 60 - 30;
                const y = Math.random() * 10 + 10;
                const z = Math.random() * 40 - 80;
                birds.push(createBird(x, y, z));
            }
        }
        
        
        
        // Create player based on selected character
        function createPlayer() {
            // Remove existing player if it exists
            if (player) {
                scene.remove(player);
            }

            // Create character based on selection
            switch (currentCharacter) {
    // CREATE PLAYER SWITCH INJECTION POINT - Package manager will add cases here
    case "apple": player = createAppleCharacter(); break;
    case "carrot": player = createCarrotCharacter(); break;
    case "pumpkin": player = createPumpkinCharacter(); break;
    case "happyface": player = createHappyFaceCharacter(); break;
    case "monster": player = createMonsterCharacter(); break;
    case "atom": player = createAtomCharacter(); break;
    case "slime": player = createSlimeCharacter(); break;
    case "ufo": player = createUFOCharacter(); break;
    case "robot": player = createRobotCharacter(); break;
    case "dragon": player = createDragonCharacter(); break;
    case "ghost": player = createGhostCharacter(); break;
    case "creature": player = createCreatureCharacter(); break;
    // END CREATE PLAYER SWITCH INJECTION POINT
    default:
        console.warn(`Character ${currentCharacter} not yet extracted - using Happy Face`);
        currentCharacter = "happyface";
        player = createHappyFaceCharacter();
        break;
}

// After the switch statement, add this:
if (!player) {
    console.error('Failed to create player character! Falling back to Happy Face');
    player = createHappyFaceCharacter();
}

// Add null check before accessing player properties
if (player && player.position) {
    // Your existing code that uses player.position
} else {
    console.error('Player object is invalid:', player);
}
            
            // Set player position
player.position.y = playerY;
player.position.z = 0;
player.rotation.x = 0; // Reset rotation

// Make robot, dragon, and ghost face forward down the track
if (currentCharacter === 'robot' || currentCharacter === 'dragon' || currentCharacter === 'ghost') {
    player.rotation.y = Math.PI; // Face forward down the track
} else {
    player.rotation.y = 0; // Default orientation for other characters
}

scene.add(player);

// Initialize ability status bar for new character
if (typeof initializeAbilityStatusBar === 'function') {
    initializeAbilityStatusBar();
}
        }
        
        // Try to unlock a character
        function tryUnlockCharacter(character) {
            if (unlockedCharacters[character]) {
                // Already unlocked, select it
                selectCharacter(character);
                return;
            }
            
            const cost = characterCosts[character];
            if (totalCoins >= cost) {
                totalCoins -= cost;
                unlockedCharacters[character] = true;
                selectCharacter(character);
                updateTotalCoins();
                saveGameData('character_unlock');  // or 'world_unlock'
            } else {
                alert(`Not enough coins! You need ${cost} coins to unlock this character.`);
            }
        }
        
        // Select a character
        function selectCharacter(character) {
            if (!unlockedCharacters[character] && !modModeEnabled) return;
            
            currentCharacter = character;
            updateCharactersInSettings();
            createPlayer(); // Update the player model
            saveGameData();
        }
        


// ==================== GAME SAVE SYSTEM ====================
// This system ensures compatibility across all versions and devices
// =================================================================
// =================================================================

// ===== GOOGLE SIGN-IN SYSTEM =====
let isGoogleUser = false;

// Enable Google Sign-In in Firebase Console first!
// Enable Google Sign-In in Firebase Console first!
function signInWithGoogle() {
    if (!firebase.auth) {
        alert('❌ Authentication not available!');
        return;
    }
    
    const provider = new firebase.auth.GoogleAuthProvider();
    provider.addScope('profile');
    provider.addScope('email');
    
    firebase.auth().signInWithPopup(provider)
        .then((result) => {
            console.log('✅ Google sign-in successful!');
            const user = result.user;
            
            // Update player info
            playerId = user.uid;
            isGoogleUser = true;
            cloudSaveEnabled = true;
            
            console.log('👤 Signed in as:', user.displayName);
            console.log('📧 Email:', user.email);
            
            // Merge anonymous data with Google account
            mergeAnonymousDataToGoogleAccount();
            
            // Hide the Google sign-in button on title screen
            const signInBtn = document.getElementById('googleSignInBtn');
            const authSection = document.getElementById('titleScreenAuth');
            if (signInBtn && authSection) {
                authSection.innerHTML = `
                    <p style="color: #34C759; font-size: 14px; margin: 10px 0;">
                        ✅ Signed in as ${user.displayName}
                    </p>
                    <p style="color: #666; font-size: 12px; font-style: italic;">
                        Your progress syncs across all devices!
                    </p>
                `;
            }
            
            alert(`✅ Signed in as ${user.displayName}!\nYour progress now syncs across all devices!`);
            
        })
        .catch((error) => {
            console.error('❌ Google sign-in failed:', error);
            alert('❌ Sign-in failed: ' + error.message);
        });
}

// Merge current anonymous progress to Google account
function mergeAnonymousDataToGoogleAccount() {
    if (!currentProfile || !playerId) return;
    
    console.log('🔄 Merging anonymous data to Google account...');
    
    // Check if Google account already has data
    firebase.database().ref('profiles/' + playerId + '/Default').once('value')
        .then((snapshot) => {
            const googleData = snapshot.val();
            
            if (googleData) {
                // Google account has existing data - ask player what to do
                const googleCoins = googleData.totalCoins || 0;
                const localCoins = currentProfile.totalCoins || 0;
                
                if (confirm(`You have progress on both devices!\n\nThis device: ${localCoins} coins\nGoogle account: ${googleCoins} coins\n\nKeep the higher amount?`)) {
                    if (localCoins > googleCoins) {
                        // Keep local data
                        saveProfile();
                    } else {
                        // Use Google data
                        currentProfile = validateAndMigrateProfile(googleData);
                        syncProfileToGameState();
                    }
                }
            } else {
                // No Google data - upload current progress
                console.log('📤 Uploading current progress to Google account...');
                saveProfile();
            }
            
            showSaveIndicator('☁️ Google Synced');
        })
        .catch((error) => {
            console.log('⚠️ Merge failed, saving current data:', error);
            saveProfile();
        });
}

// Sign out of Google
function signOutGoogle() {
    firebase.auth().signOut()
        .then(() => {
            console.log('👋 Signed out of Google');
            
            // Revert to anonymous auth
            initializeCloudSave();
            
            alert('👋 Signed out! Your progress is now device-specific again.');
        })
        .catch((error) => {
            console.error('❌ Sign-out failed:', error);
        });
}

// ===== SAVE CODE SYSTEM =====
// Generate a transferable save code
function generateSaveCode() {
    if (!currentProfile || !playerId) {
        alert('❌ No save data available to export!');
        return null;
    }
    
    try {
        const exportData = {
            version: SAVE_VERSION,
            playerId: playerId,
            profileName: currentProfileName,
            profile: currentProfile,
            timestamp: Date.now(),
            deviceInfo: navigator.userAgent.substring(0, 50) // For reference
        };
        
        // Compress and encode the data
        const compressed = JSON.stringify(exportData);
        const encoded = btoa(compressed);
        
        // Create readable save code (format: BLITZ-XXXX-XXXX-XXXX)
        const codeBase = encoded.substring(0, 12).toUpperCase();
        const saveCode = `BLITZ-${codeBase.substring(0, 4)}-${codeBase.substring(4, 8)}-${codeBase.substring(8, 12)}`;
        
        console.log('💾 Save code generated:', saveCode);
        return { code: saveCode, fullData: encoded };
        
    } catch (error) {
        console.error('❌ Failed to generate save code:', error);
        alert('❌ Failed to generate save code!');
        return null;
    }
}

// Use a save code to restore progress
function useSaveCode(saveCode, fullData = null) {
    try {
        let decodedData;
        
        if (fullData) {
            // Use full data if provided
            decodedData = JSON.parse(atob(fullData));
        } else {
            // For now, save codes need the full data
            // In a real implementation, you'd store codes in Firebase
            alert('❌ Save codes need the full export data for now!');
            return false;
        }
        
        if (decodedData.version !== SAVE_VERSION) {
            console.log('⚠️ Save code is from different version, attempting migration...');
        }
        
        // Validate the data
        if (!decodedData.profile || !decodedData.playerId) {
            throw new Error('Invalid save code data');
        }
        
        console.log('📥 Restoring save from code...');
        console.log(`💰 Restoring ${decodedData.profile.totalCoins} coins`);
        console.log(`👤 Restoring character: ${decodedData.profile.currentCharacter}`);
        
        // Apply the restored profile
        currentProfile = validateAndMigrateProfile(decodedData.profile);
        currentProfileName = decodedData.profileName || "Restored";
        
        // Sync to game state
        syncProfileToGameState();
        
        // Save the restored profile locally and to cloud
        saveProfile();
        
        alert(`✅ Progress restored!\n💰 ${currentProfile.totalCoins} coins\n👤 Character: ${currentProfile.currentCharacter}`);
        
        return true;
        
    } catch (error) {
        console.error('❌ Failed to use save code:', error);
        alert('❌ Invalid save code!');
        return false;
    }
}

// Show save code to player
function showSaveCode() {
    const result = generateSaveCode();
    if (!result) return;
    
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center;
        z-index: 10000; font-family: Arial, sans-serif;
    `;
    
    modal.innerHTML = `
        <div style="background: white; padding: 30px; border-radius: 15px; max-width: 500px; text-align: center;">
            <h2 style="color: #333; margin-bottom: 20px;">📱 Transfer Your Progress</h2>
            <p style="color: #666; margin-bottom: 20px;">Use this code to restore your progress on any device:</p>
            
            <div style="background: #f0f0f0; padding: 15px; border-radius: 8px; margin: 20px 0;">
                <h3 style="color: #333; margin: 0 0 10px 0;">Save Code:</h3>
                <div style="font-size: 24px; font-weight: bold; color: #007AFF; letter-spacing: 2px;">${result.code}</div>
            </div>
            
            <textarea readonly style="width: 100%; height: 60px; font-size: 10px; margin: 10px 0; padding: 10px;" 
                onclick="this.select()">${result.fullData}</textarea>
            <p style="font-size: 12px; color: #999;">Copy both the code AND the text above</p>
            
            <div style="margin-top: 20px;">
                <button onclick="this.parentElement.parentElement.parentElement.remove()" 
                    style="background: #007AFF; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 16px;">
                    Done
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// Show restore from code dialog
function showRestoreCode() {
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8); display: flex; justify-content: center; align-items: center;
        z-index: 10000; font-family: Arial, sans-serif;
    `;
    
    modal.innerHTML = `
        <div style="background: white; padding: 30px; border-radius: 15px; max-width: 500px; text-align: center;">
            <h2 style="color: #333; margin-bottom: 20px;">📥 Restore Your Progress</h2>
            <p style="color: #666; margin-bottom: 20px;">Enter your save code and data:</p>
            
            <input type="text" id="saveCodeInput" placeholder="BLITZ-XXXX-XXXX-XXXX" 
                style="width: 100%; padding: 12px; margin: 10px 0; border: 2px solid #ddd; border-radius: 8px; text-align: center; font-size: 16px; letter-spacing: 1px;">
            
            <textarea id="saveDataInput" placeholder="Paste the full save data here..." 
                style="width: 100%; height: 80px; padding: 12px; margin: 10px 0; border: 2px solid #ddd; border-radius: 8px; font-size: 12px;"></textarea>
            
            <div style="margin-top: 20px;">
                <button onclick="restoreFromInputs()" 
                    style="background: #34C759; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 16px; margin-right: 10px;">
                    Restore Progress
                </button>
                <button onclick="this.parentElement.parentElement.parentElement.remove()" 
                    style="background: #666; color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 16px;">
                    Cancel
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
}

// Restore from save code
function restoreFromInputs() {
    const code = document.getElementById('saveCodeInput').value.trim();
    const data = document.getElementById('saveDataInput').value.trim();
    
    if (!code || !data) {
        alert('❌ Please enter both the save code and data!');
        return;
    }
    
    try {
        const decodedData = JSON.parse(atob(data));
        
        console.log('📥 Restoring save from code...');
        console.log(`💰 Restoring ${decodedData.profile.totalCoins} coins`);
        
        currentProfile = validateAndMigrateProfile(decodedData.profile);
        currentProfileName = decodedData.profileName || "Restored";
        
        syncProfileToGameState();
        saveGameData('manual_save');
        
        alert(`✅ Progress restored!\n💰 ${currentProfile.totalCoins} coins\n👤 Character: ${currentProfile.currentCharacter}`);
        
        document.querySelector('[style*="z-index: 10000"]').remove();
        
    } catch (error) {
        console.error('❌ Failed to restore save:', error);
        alert('❌ Invalid save code or data!');
    }
}


// Current save system version - increment when making breaking changes
const SAVE_VERSION = "1.0";
const GAME_ID = "runningBlitzEndlessRunner";

// Default save profile template
const DEFAULT_PROFILE = {
    version: SAVE_VERSION,
    gameId: GAME_ID,
    created: null,
    lastPlayed: null,
    
    // Player progress
    totalCoins: 0,
    highScore: 0,
    totalGamesPlayed: 0,
    totalTimePlayed: 0, // in seconds
    
    // Character data
currentCharacter: 'apple',
unlockedCharacters: {
    apple: true,
    carrot: false,
    pumpkin: false,
    happyface: false,
    monster: false,
    atom: false,
    slime: false,
    ufo: false,
    robot: false,
    dragon: false,
    ghost: false
},

// World data
currentWorld: 'classic',
unlockedWorlds: {
    classic: true
},
    
    // Settings
    soundEffectsEnabled: true,
    backgroundMusicEnabled: true,
    currentTrack: 'ambient',
    modModeEnabled: false,
    
    // Leaderboard (moved into profile)
    personalBests: [],
    
    // Achievement system (ready for future)
    achievements: {},
    unlockedAchievements: [],
    
    // Statistics (ready for future)
    stats: {
        coinsCollected: 0,
        obstaclesAvoided: 0,
        streamsJumped: 0,
        powerUpsCollected: 0,
        meteorsAvoided: 0,
        characterUsageTime: {}
    },
    
    // Future expansion data
    customData: {}
};

// Current active profile
let currentProfile = null;
let currentProfileName = "Default";

// ADD THESE CLOUD SAVE VARIABLES
let playerId = null;
let cloudSaveEnabled = false;

// Initialize Firebase Auth (anonymous)
function initializeCloudSave() {
    firebase.auth().signInAnonymously()
        .then((userCredential) => {
            playerId = userCredential.user.uid;
            cloudSaveEnabled = true;
            console.log('🔥 Cloud save enabled! Player ID:', playerId.substring(0, 8) + '...');
            
            // Try to sync existing profile with cloud
            syncProfileWithCloud();
        })
        .catch((error) => {
            console.log('⚠️ Cloud save unavailable, using local storage:', error);
            cloudSaveEnabled = false;
        });
}

// Visual save indicator
function showSaveIndicator(message) {
    let indicator = document.getElementById('saveIndicator');
    if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'saveIndicator';
        indicator.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        `;
        document.body.appendChild(indicator);
    }
    
    indicator.textContent = message;
    indicator.style.opacity = '1';
    
    setTimeout(() => {
        indicator.style.opacity = '0';
    }, 2000);
}

// Sync profile with cloud when Firebase connects
function syncProfileWithCloud() {
    if (!cloudSaveEnabled || !playerId || !currentProfileName) return;
    
    console.log('☁️ Checking cloud sync...');
    console.log('Local profile before cloud sync:', currentProfile.unlockedWorlds);
    
    // Save the current local profile state BEFORE cloud check
    const localProfileBackup = JSON.parse(JSON.stringify(currentProfile));
    
    // Check if cloud has newer data
    firebase.database().ref('profiles/' + playerId + '/' + currentProfileName).once('value')
        .then((snapshot) => {
            const cloudProfile = snapshot.val();
            
            if (cloudProfile) {
                const cloudTime = new Date(cloudProfile.lastPlayed || 0).getTime();
                const localTime = new Date(localProfileBackup.lastPlayed || 0).getTime();
                
                console.log('Cloud time:', new Date(cloudTime).toISOString());
                console.log('Local time:', new Date(localTime).toISOString());
                console.log('Cloud unlocked worlds:', cloudProfile.unlockedWorlds);
                console.log('Local unlocked worlds:', localProfileBackup.unlockedWorlds);
                
                // SMART MERGE: Combine unlocked content from both sources
                const mergedProfile = JSON.parse(JSON.stringify(localProfileBackup));
                
                // Merge unlocked worlds (keep any world that's unlocked in either source)
                if (cloudProfile.unlockedWorlds) {
                    Object.keys(cloudProfile.unlockedWorlds).forEach(worldId => {
                        if (cloudProfile.unlockedWorlds[worldId]) {
                            mergedProfile.unlockedWorlds[worldId] = true;
                        }
                    });
                }
                
                // Merge unlocked characters (keep any character that's unlocked in either source)
                if (cloudProfile.unlockedCharacters) {
                    Object.keys(cloudProfile.unlockedCharacters).forEach(charId => {
                        if (cloudProfile.unlockedCharacters[charId]) {
                            mergedProfile.unlockedCharacters[charId] = true;
                        }
                    });
                }
                
                // Use the higher coin count (never lose coins)
                mergedProfile.totalCoins = Math.max(
                    cloudProfile.totalCoins || 0,
                    localProfileBackup.totalCoins || 0
                );
                
                // Use the most recent timestamp
                mergedProfile.lastPlayed = cloudTime > localTime ? 
                    cloudProfile.lastPlayed : localProfileBackup.lastPlayed;
                
                console.log('🔀 Merged profile unlocked worlds:', mergedProfile.unlockedWorlds);
                console.log('🔀 Merged profile coins:', mergedProfile.totalCoins);
                
                // Apply the merged profile
                currentProfile = mergedProfile;
                syncProfileToGameState();
                
                // Save the merged profile back to cloud
                saveProfile();
                showSaveIndicator('☁️ Synced & Merged');
                
            } else {
                console.log('☁️ No cloud profile found, uploading local...');
                // Restore local profile and upload
                currentProfile = localProfileBackup;
                saveProfile();
            }
        })
        .catch((error) => {
            console.log('⚠️ Cloud sync failed:', error);
            // Restore local profile on error
            currentProfile = localProfileBackup;
        });
}



// Initialize save system
function initializeSaveSystem() {
    console.log('🗄️ Initializing future-proof save system...');
    
    // Check for legacy save data and migrate
    migrateLegacySaveData();
    
    // Load or create default profile
    loadProfile("Default");
    
    // Initialize cloud save after profile is loaded
    setTimeout(() => {
        initializeCloudSave();
    }, 1000);
    
    // Load global leaderboard after cloud save is ready
    setTimeout(() => {
        if (cloudSaveEnabled) {
            loadGlobalLeaderboard(); // Load global scores on startup
        }
    }, 3000);
    
    console.log('✅ Save system initialized successfully!');
}

// Migrate old save data to new profile system
function migrateLegacySaveData() {
    try {
        // Check if migration has already been completed
        const migrationComplete = localStorage.getItem('runningBlitzEndlessRunner_migrationComplete');
        if (migrationComplete) {
            console.log('ℹ️ Legacy migration already completed - skipping');
            return;
        }
        
        // Check for old save format
        const legacySaveData = localStorage.getItem('endlessRunnerData');
        const legacyLeaderboard = localStorage.getItem('endlessRunnerLeaderboard');
        
        if (legacySaveData) {
            console.log('📦 Found legacy save data - migrating...');
            
            const oldData = JSON.parse(legacySaveData);
            
            // Create new profile with legacy data
            const migratedProfile = JSON.parse(JSON.stringify(DEFAULT_PROFILE));
            
            // Migrate all the old data
            migratedProfile.totalCoins = oldData.totalCoins || 0;
            migratedProfile.currentCharacter = oldData.currentCharacter || 'apple';
            migratedProfile.currentWorld = oldData.currentWorld || 'classic';
            migratedProfile.unlockedWorlds = oldData.unlockedWorlds || {classic: true};
            migratedProfile.soundEffectsEnabled = oldData.soundEffectsEnabled !== undefined ? oldData.soundEffectsEnabled : true;
            migratedProfile.backgroundMusicEnabled = oldData.backgroundMusicEnabled !== undefined ? oldData.backgroundMusicEnabled : true;
            migratedProfile.modModeEnabled = oldData.modModeEnabled || false;
            
            // Migrate character unlocks
            if (oldData.unlockedCharacters) {
                Object.keys(oldData.unlockedCharacters).forEach(char => {
                    if (migratedProfile.unlockedCharacters.hasOwnProperty(char)) {
                        migratedProfile.unlockedCharacters[char] = oldData.unlockedCharacters[char];
                    }
                });
            }
            
            // Set timestamps
            migratedProfile.created = new Date().toISOString();
            migratedProfile.lastPlayed = new Date().toISOString();
            migratedProfile.profileId = generateProfileId();
            migratedProfile.profileName = "Default";
            
            // Migrate leaderboard if it exists
            if (legacyLeaderboard) {
                try {
                    const oldLeaderboard = JSON.parse(legacyLeaderboard);
                    migratedProfile.personalBests = oldLeaderboard;
                } catch (e) {
                    console.log('⚠️ Could not migrate leaderboard data');
                }
            }
            
            // Save the migrated profile
            const saveKey = `${GAME_ID}_profile_Default`;
            localStorage.setItem(saveKey, JSON.stringify(migratedProfile));
            updateProfileList("Default");
            
            console.log('✅ Legacy data migrated successfully!');
            console.log(`💰 Restored ${migratedProfile.totalCoins} coins`);
            console.log(`👤 Restored character: ${migratedProfile.currentCharacter}`);
            
            // Keep the old data for a while as backup, but mark it as migrated
            localStorage.setItem('endlessRunnerData_migrated', legacySaveData);
            
            // Mark migration as complete
            localStorage.setItem('runningBlitzEndlessRunner_migrationComplete', 'true');
            
        } else {
            console.log('ℹ️ No legacy save data found - starting fresh');
            // Still mark migration as complete so we don't check again
            localStorage.setItem('runningBlitzEndlessRunner_migrationComplete', 'true');
        }
        
    } catch (error) {
        console.error('❌ Error during legacy migration:', error);
        console.log('🔄 Creating fresh profile instead');
        // Mark migration as complete even if it failed
        localStorage.setItem('runningBlitzEndlessRunner_migrationComplete', 'true');
    }
}

// Create a new profile
function createProfile(profileName, baseProfile = null) {
    const profile = baseProfile ? JSON.parse(JSON.stringify(baseProfile)) : JSON.parse(JSON.stringify(DEFAULT_PROFILE));
    
    profile.created = new Date().toISOString();
    profile.lastPlayed = new Date().toISOString();
    
    // Generate unique ID for cross-device sync
    profile.profileId = generateProfileId();
    profile.profileName = profileName;
    
    return profile;
}

// Generate unique profile ID
function generateProfileId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
}

// Save current profile (Cloud Enhanced) - with save reasons
function saveProfile(profileName = currentProfileName, saveReason = 'general') {
    if (!currentProfile) {
        console.error('❌ No active profile to save!');
        return false;
    }
    
    // Define which reasons should show the save indicator
    const importantSaveReasons = [
        'game_end',
        'character_unlock',
        'world_unlock', 
        'high_score',
        'major_purchase',
        'settings_change',
        'manual_save'
    ];
    
    const showIndicator = importantSaveReasons.includes(saveReason);
    
    try {
        // Update timestamps and current data
        currentProfile.lastPlayed = new Date().toISOString();
        currentProfile.version = SAVE_VERSION;
        
        // Sync current game state to profile
        syncGameStateToProfile();
        
        // Save to localStorage with versioned key (local backup)
        const saveKey = `${GAME_ID}_profile_${profileName}`;
        localStorage.setItem(saveKey, JSON.stringify(currentProfile));
        
        // Update profile list
        updateProfileList(profileName);
        
        // Save to cloud if available
        if (cloudSaveEnabled && playerId) {
            firebase.database().ref('profiles/' + playerId + '/' + profileName).set(currentProfile)
                .then(() => {
                    console.log(`☁️ Profile "${profileName}" saved to cloud! (${saveReason})`);
                    if (showIndicator) {
                        showSaveIndicator('☁️ Progress Saved');
                    }
                })
                .catch((error) => {
                    console.log('⚠️ Cloud save failed, local backup saved:', error);
                    if (showIndicator) {
                        showSaveIndicator('💾 Local Saved');
                    }
                });
        } else {
            if (showIndicator) {
                showSaveIndicator('💾 Progress Saved');
            }
        }
        
        console.log(`💾 Profile "${profileName}" saved successfully! (${saveReason})`);
        return true;
        
    } catch (error) {
        console.error('❌ Failed to save profile:', error);
        return false;
    }
}

// Load profile
function loadProfile(profileName) {
    try {
        const saveKey = `${GAME_ID}_profile_${profileName}`;
        const savedData = localStorage.getItem(saveKey);
        
        if (savedData) {
            console.log(`📂 Loading profile "${profileName}"...`);
            
            const profile = JSON.parse(savedData);
            
            // Validate and migrate if necessary
            currentProfile = validateAndMigrateProfile(profile);
            currentProfileName = profileName;
            
            // Apply profile data to game state
            syncProfileToGameState();
            
            console.log(`✅ Profile "${profileName}" loaded successfully!`);
console.log(`💰 Current balance: ${currentProfile.totalCoins} coins`);
console.log(`👤 Current character: ${currentProfile.currentCharacter}`);
            
        } else {
            // Create new profile
            console.log(`🆕 Creating new profile "${profileName}"...`);
            
            currentProfile = createProfile(profileName);
            currentProfileName = profileName;
            
            // Set default game state
            syncProfileToGameState();
            
            // Save the new profile
            saveProfile(profileName);
        }
        
        return true;
        
    } catch (error) {
        console.error('❌ Failed to load profile:', error);
        
        // Fallback to default profile
        currentProfile = createProfile(profileName);
        currentProfileName = profileName;
        syncProfileToGameState();
        
        return false;
    }
}

// Validate and migrate profile data
function validateAndMigrateProfile(profile) {
    console.log(`🔄 Validating profile (version: ${profile.version || 'unknown'})...`);
    
    // Create a clean profile with current structure
    const migratedProfile = JSON.parse(JSON.stringify(DEFAULT_PROFILE));
    
    // Copy over valid data from old profile
    if (profile.version) {
        migratedProfile.version = profile.version;
    }
    
    // Migrate basic data (always compatible)
    migratedProfile.totalCoins = profile.totalCoins || 0;
    migratedProfile.currentCharacter = profile.currentCharacter || 'apple';
    migratedProfile.currentWorld = profile.currentWorld || 'classic';
    migratedProfile.soundEffectsEnabled = profile.soundEffectsEnabled !== undefined ? profile.soundEffectsEnabled : true;
    migratedProfile.backgroundMusicEnabled = profile.backgroundMusicEnabled !== undefined ? profile.backgroundMusicEnabled : true;
    migratedProfile.modModeEnabled = profile.modModeEnabled || false;
    
    // Migrate character unlocks (merge with new characters)
    if (profile.unlockedCharacters) {
        Object.keys(profile.unlockedCharacters).forEach(char => {
            if (migratedProfile.unlockedCharacters.hasOwnProperty(char)) {
                migratedProfile.unlockedCharacters[char] = profile.unlockedCharacters[char];
            }
        });
    }

    // Migrate world unlocks (merge with new worlds)
if (profile.unlockedWorlds) {
    Object.keys(profile.unlockedWorlds).forEach(world => {
        if (migratedProfile.unlockedWorlds.hasOwnProperty(world)) {
            migratedProfile.unlockedWorlds[world] = profile.unlockedWorlds[world];
        }
    });
}
    
    // Migrate leaderboard data
    if (profile.personalBests) {
        migratedProfile.personalBests = profile.personalBests;
    }
    
    // Migrate timestamps
    migratedProfile.created = profile.created || new Date().toISOString();
    migratedProfile.lastPlayed = new Date().toISOString();
    
    // Migrate profile ID
    migratedProfile.profileId = profile.profileId || generateProfileId();
    migratedProfile.profileName = profile.profileName || currentProfileName;
    
    // Migrate stats (if they exist)
    if (profile.stats) {
        Object.keys(profile.stats).forEach(stat => {
            if (migratedProfile.stats.hasOwnProperty(stat)) {
                migratedProfile.stats[stat] = profile.stats[stat];
            }
        });
    }
    
    // Migrate custom data for future compatibility
    if (profile.customData) {
        migratedProfile.customData = profile.customData;
    }
    
    // Update version
    migratedProfile.version = SAVE_VERSION;
    
    console.log('✅ Profile validation and migration completed!');
    return migratedProfile;
}

// Sync current game state to profile
function syncGameStateToProfile() {
    if (!currentProfile) return;

    console.log('🔄 Syncing game state to profile...');
    console.log('Current totalCoins in game:', totalCoins);
    console.log('Current totalCoins in profile before sync:', currentProfile.totalCoins);
    
    currentProfile.totalCoins = totalCoins;
    currentProfile.currentCharacter = currentCharacter;
    currentProfile.unlockedCharacters = {...unlockedCharacters};
    currentProfile.currentWorld = currentWorld;
    currentProfile.unlockedWorlds = {...unlockedWorlds};
    currentProfile.soundEffectsEnabled = soundEffectsEnabled;
    currentProfile.backgroundMusicEnabled = backgroundMusicEnabled;
    currentProfile.modModeEnabled = modModeEnabled;
    currentProfile.currentTrack = currentTrack;

    console.log('Current totalCoins in profile after sync:', currentProfile.totalCoins);

    
    // Update high score
    if (score > (currentProfile.highScore || 0)) {
        currentProfile.highScore = score;
    }
    
    // Sync leaderboard
    currentProfile.personalBests = [...leaderboard];
}

// Sync profile data to game state
function syncProfileToGameState() {
    if (!currentProfile) return;

    console.log('📂 Syncing profile to game state...');
    console.log('Profile totalCoins:', currentProfile.totalCoins);
        console.log('Profile unlockedWorlds:', currentProfile.unlockedWorlds); // ADD THIS
    console.log('Game totalCoins before sync:', totalCoins);
        console.log('Game unlockedWorlds before sync:', unlockedWorlds); // ADD THIS
    
    totalCoins = currentProfile.totalCoins || 0;
    currentCharacter = currentProfile.currentCharacter || 'apple';
    unlockedCharacters = {...currentProfile.unlockedCharacters};
    currentWorld = currentProfile.currentWorld || 'classic';
    unlockedWorlds = {...(currentProfile.unlockedWorlds || {classic: true})};
    soundEffectsEnabled = currentProfile.soundEffectsEnabled !== undefined ? currentProfile.soundEffectsEnabled : true;
    backgroundMusicEnabled = currentProfile.backgroundMusicEnabled !== undefined ? currentProfile.backgroundMusicEnabled : true;
    modModeEnabled = currentProfile.modModeEnabled || false;
    currentTrack = currentProfile.currentTrack || 'ambient';
    selectedTrack = currentTrack;

    console.log('Game totalCoins after sync:', totalCoins);

    
    // Sync leaderboard
    if (currentProfile.personalBests) {
        leaderboard = [...currentProfile.personalBests];
        if (leaderboard.length > 0) {
            currentHighScore = leaderboard[0].score;
        }
    }
    
    // Update UI elements
    updateTotalCoins();
    updateLeaderboardDisplay();
    
    // Update checkboxes
    setTimeout(() => {
        const soundCheckbox = document.getElementById('soundEffectsCheckbox');
        const musicCheckbox = document.getElementById('backgroundMusicCheckbox');
        
        if (soundCheckbox) soundCheckbox.checked = soundEffectsEnabled;
        if (musicCheckbox) musicCheckbox.checked = backgroundMusicEnabled;
    }, 100);
}

// Update global leaderboard display in pause menu tab
function updateGlobalLeaderboardDisplay() {
    const tbody = document.getElementById('globalLeaderboardBody');
    const rankDisplay = document.getElementById('globalPlayerRank');
    
    if (!tbody) return;
    
    // Load fresh data
    loadGlobalLeaderboard();
    
    setTimeout(() => {
        // Clear existing content
        tbody.innerHTML = '';
        
        if (globalLeaderboard.length === 0) {
            tbody.innerHTML = `
                <tr>
                    <td colspan="4" style="text-align: center; padding: 40px; color: white;">
                        🏆 Be the first on the global leaderboard!<br>
                        <small style="color: #ccc;">Complete a game to see your score here!</small>
                    </td>
                </tr>
            `;
            return;
        }
        
        // Add top 15 scores (more than local leaderboard)
        globalLeaderboard.slice(0, 15).forEach((entry, index) => {
            const rank = index + 1;
            const isCurrentPlayer = entry.playerId === playerId;
            
            let rankDisplay = `#${rank}`;
            if (rank === 1) rankDisplay = '🥇';
            else if (rank === 2) rankDisplay = '🥈';
            else if (rank === 3) rankDisplay = '🥉';
            
            const rowStyle = isCurrentPlayer ? 'background: rgba(0, 255, 0, 0.1); color: #00FF00;' : '';
            
            tbody.innerHTML += `
                <tr style="${rowStyle}">
                    <td>${rankDisplay}</td>
                    <td>${entry.playerName || 'Anonymous'}</td>
                    <td>${entry.score.toLocaleString()}</td>
                    <td>${entry.character}</td>
                </tr>
            `;
        });
        
        // Update player rank display
        if (playerGlobalRank && rankDisplay) {
            rankDisplay.textContent = `🏆 Your Global Rank: #${playerGlobalRank} out of ${globalLeaderboard.length} players`;
            rankDisplay.style.color = '#FFD700';
        } else if (rankDisplay) {
            rankDisplay.textContent = `🌍 ${globalLeaderboard.length} players competing worldwide`;
            rankDisplay.style.color = '#ccc';
        }
        
    }, 1000); // Wait for data to load
}

// Update profile list in localStorage
function updateProfileList(profileName) {
    try {
        const profileListKey = `${GAME_ID}_profiles`;
        let profileList = [];
        
        const savedList = localStorage.getItem(profileListKey);
        if (savedList) {
            profileList = JSON.parse(savedList);
        }
        
        // Add profile to list if not already there
        if (!profileList.includes(profileName)) {
            profileList.push(profileName);
            localStorage.setItem(profileListKey, JSON.stringify(profileList));
        }
        
    } catch (error) {
        console.error('❌ Failed to update profile list:', error);
    }
}

// Get list of all profiles
function getProfileList() {
    try {
        const profileListKey = `${GAME_ID}_profiles`;
        const savedList = localStorage.getItem(profileListKey);
        
        if (savedList) {
            return JSON.parse(savedList);
        }
        
        return ["Default"];
        
    } catch (error) {
        console.error('❌ Failed to get profile list:', error);
        return ["Default"];
    }
}

// Export profile data (for sharing between devices)
function exportProfile(profileName = currentProfileName) {
    try {
        const saveKey = `${GAME_ID}_profile_${profileName}`;
        const profileData = localStorage.getItem(saveKey);
        
        if (profileData) {
            const exportData = {
                exportDate: new Date().toISOString(),
                gameVersion: SAVE_VERSION,
                profileName: profileName,
                profileData: JSON.parse(profileData)
            };
            
            return JSON.stringify(exportData, null, 2);
        }
        
        return null;
        
    } catch (error) {
        console.error('❌ Failed to export profile:', error);
        return null;
    }
}

// Import profile data (for sharing between devices)
function importProfile(exportedData, newProfileName = null) {
    try {
        const importData = JSON.parse(exportedData);
        
        // Validate import data
        if (!importData.profileData || !importData.gameVersion) {
            throw new Error('Invalid export data format');
        }
        
        const profileName = newProfileName || importData.profileName || "Imported";
        const profile = validateAndMigrateProfile(importData.profileData);
        
        profile.profileName = profileName;
        
        // Save imported profile
        const saveKey = `${GAME_ID}_profile_${profileName}`;
        localStorage.setItem(saveKey, JSON.stringify(profile));
        
        updateProfileList(profileName);
        
        console.log(`📥 Profile "${profileName}" imported successfully!`);
        return true;
        
    } catch (error) {
        console.error('❌ Failed to import profile:', error);
        return false;
    }
}

// Wrapper functions for compatibility
function saveGameData(reason = 'general') {
    saveProfile(currentProfileName, reason);
}

function loadGameData(ignoreModMode = false) {
    // The new system handles mod mode automatically
    syncProfileToGameState();
}
        
        // Update total coins display
function updateTotalCoins() {
    document.getElementById('totalCoins').textContent = `Coins: ${totalCoins}`;
    
    // Also update shop coin display if shop screen exists
    const shopCoinDisplay = document.getElementById('shop-coin-count');
    if (shopCoinDisplay) {
        shopCoinDisplay.textContent = totalCoins;
    }
    
    // Update main menu coin display
    const coinCountDisplay = document.getElementById('coin-count');
    if (coinCountDisplay) {
        coinCountDisplay.textContent = totalCoins;
    }
}

// Force cleanup particles before starting game
function forceCleanupParticles() {
    console.log('🧹 Force cleaning up particles...');
    
    // Hide canvas
    const canvas = document.getElementById('particle-canvas');
    if (canvas) {
        canvas.style.display = 'none';
        canvas.style.visibility = 'hidden';
        canvas.style.opacity = '0';
    }
    
    // Destroy particle system
    if (titleParticleSystem) {
        titleParticleSystem.destroy();
        titleParticleSystem = null;
    }
    
    // Remove any stray particle canvases
    const allCanvases = document.querySelectorAll('#particle-canvas');
    allCanvases.forEach((canvas, index) => {
        if (index > 0) { // Keep first one, remove duplicates
            canvas.remove();
        }
    });
}

        
        function startGame() {

                // ADD THIS LINE AT THE START
    saveGameData(); // Save current state when starting

    // Show the game renderer
if (renderer && renderer.domElement) {
    renderer.domElement.style.display = 'block';
}
    
    // NUCLEAR PARTICLE CLEANUP BEFORE GAME START
nuclearParticleCleanup();

// Reset power-up states at game start
shieldActive = false;
coinMultiplierActive = false;
magnetActive = false;
powerUpTimers = {};

// Initialize status bars
initializePowerUpStatusBar();
initializeAbilityStatusBar();
    
    document.getElementById('startScreen').style.display = 'none';

            // Hide any remaining screens
            document.getElementById('titleScreen').style.display = 'none';
            document.getElementById('characterSelectScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('pauseScreen').style.display = 'none';
            document.getElementById('settingsScreen').style.display = 'none';
            document.getElementById('modalOverlay').style.display = 'none';
            
            // HIDE PARTICLES DURING GAMEPLAY
            const canvas = document.getElementById('particle-canvas');
            if (canvas) {
                canvas.style.display = 'none';
            }
            
            // NUCLEAR PARTICLE CLEANUP FOR RESTART
nuclearParticleCleanup();

            
            
            // Show game UI elements
const scoreEl = document.getElementById('score');
const coinsEl = document.getElementById('totalCoins');
const pauseEl = document.getElementById('pauseBtn');
const speedEl = document.getElementById('speedIndicator');
const powerUpEl = document.getElementById('powerUpStatusBar');
const swipeEl = document.getElementById('swipeInstructions');

if (scoreEl) scoreEl.style.display = 'block';
if (coinsEl) coinsEl.style.display = 'block';
if (pauseEl) pauseEl.style.display = 'flex'; // Use flex for centering
if (speedEl) speedEl.style.display = 'block';
if (powerUpEl) powerUpEl.style.display = 'flex'; // Use flex for layout
if (isMobile && swipeEl) swipeEl.style.display = 'block';
            
            // Update game state
            gameState = "playing";

// Apply current world settings
const selectedWorld = availableWorlds.find(w => w.id === currentWorld);
if (selectedWorld) {
    applyWorldSettings(selectedWorld);
}

            gameStarted = true;
            gameOver = false;
            gamePaused = false;

            
            
            // Reset game variables
            score = 0;
            distanceTraveled = 0;
            streamSpawnCounter = 0;
            streamCreated = false;
            
            // Reset dynamic difficulty
            resetDynamicDifficulty();
            
            updateScore();



if (!backgroundMusic) {
    createBackgroundMusic();
}
startBackgroundMusic();

// Fallback: try again after a short delay if music didn't start
setTimeout(() => {
    if (!musicPlaying && backgroundMusicEnabled && audioInitialized) {
        console.log('🎵 Fallback: Retrying music start...');
        if (!backgroundMusic) {
            createBackgroundMusic();
        }
        startBackgroundMusic();
    }
}, 1000);

        }
        
        function restartGame() {
            // HIDE PARTICLES DURING GAMEPLAY RESTART
            const canvas = document.getElementById('particle-canvas');
            if (canvas) {
                canvas.style.display = 'none';
            }
            
            // Destroy particle system during gameplay
            if (titleParticleSystem) {
                titleParticleSystem.destroy();
                titleParticleSystem = null;
            }
            
            // Clear obstacles, coins and streams
            obstacles.forEach(obstacle => scene.remove(obstacle));
            obstacles = [];
            
            coins.forEach(coin => scene.remove(coin));
            coins = [];

            rareCoins.forEach(rareCoin => scene.remove(rareCoin));
            rareCoins = [];

            powerUps.forEach(powerUp => scene.remove(powerUp));
powerUps = [];

// Reset power-up states completely
shieldActive = false;
coinMultiplierActive = false;
magnetActive = false;
powerUpTimers = {};

// Remove shield effect if active
if (player && player.userData && player.userData.shieldEffect) {
    player.remove(player.userData.shieldEffect);
    player.userData.shieldEffect = null;
}

// Force log to confirm reset
console.log('Power-ups reset - Shield:', shieldActive, 'Multiplier:', coinMultiplierActive, 'Magnet:', magnetActive);
            
            waterStreams.forEach(stream => scene.remove(stream));
            waterStreams = [];
            
            // Clear scenery objects
            sceneryObjects.forEach(object => scene.remove(object));
            sceneryObjects = [];

            // Clear meteors
            meteors.forEach(meteor => scene.remove(meteor));
            meteors = [];
            meteorSpawnCounter = 0;
            
            // Clear explosion particles
            explosionParticles.forEach(particle => scene.remove(particle));
            explosionParticles = [];
            
            // Clear sparkle particles
            sparkleParticles.forEach(particle => scene.remove(particle));
            sparkleParticles = [];
            
            // Reset player position and make visible again
player.position.x = 0;
player.position.y = playerY;
player.rotation.x = 0; // Reset rotation
player.visible = true;
currentLane = 1;
jumping = false;
jumpRotation = 0;
streamSpawnCounter = 0;
streamCreated = false;

// Reset dragon fire particles if dragon character
if (currentCharacter === 'dragon' && player.userData && player.userData.fireParticles) {
    player.userData.fireParticles.forEach(particle => {
        particle.visible = false;
        particle.position.set(
            (Math.random() - 0.5) * 0.3,
            0.1 + Math.random() * 0.2,
            1.0
        );
        particle.material.opacity = particle.userData.originalOpacity;
        particle.scale.setScalar(1.0);
    });
}
dragonFireActive = false;
dragonFireCooldown = 0;
            
            // Reset game state
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('pauseScreen').style.display = 'none';
            document.getElementById('settingsScreen').style.display = 'none';
            document.getElementById('modalOverlay').style.display = 'none';
            document.getElementById('pauseBtn').style.display = 'block';
            document.getElementById('speedIndicator').style.display = 'block';
            document.getElementById('newHighScoreMessage').style.display = 'none';
            if (isMobile) {
                document.getElementById('swipeInstructions').style.display = 'block';
            }
            gameOver = false;
            gamePaused = false;
            gameState = "playing";
            score = 0;
            distanceTraveled = 0;
            
            // Reset dynamic difficulty
            resetDynamicDifficulty();
            
            updateScore();

// Restart background music
            if (musicPlaying) {
                stopBackgroundMusic();
            }
            if (!backgroundMusic) {
                createBackgroundMusic();
            }
            startBackgroundMusic();
        }
        
        function updateScore() {
            document.getElementById('score').textContent = `Score: ${score}`;
        }
        
        function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    // Update title particle renderer if it exists
    if (window.titleParticleRenderer && window.titleParticleCamera) {
        window.titleParticleCamera.aspect = window.innerWidth / window.innerHeight;
        window.titleParticleCamera.updateProjectionMatrix();
        window.titleParticleRenderer.setSize(window.innerWidth, window.innerHeight);
    }
}

        // ==================== DESKTOP CONTROLS ====================
// Keyboard input, key handling, and desktop controls
// Dependencies: Game Loop, Player Controls  
// Functions: onKeyDown(), onKeyUp(), handleKeyboard(), etc.
        
        function onKeyDown(event) {
            if (gameOver) return;
            
            if (event.key === 'p' || event.key === 'P') {
                togglePause();
                return;
            }
            
            if (event.key === 's' || event.key === 'S') {
                toggleSettingsScreen();
                return;
            }
            
            if (!gameStarted || gamePaused) return;
        

            switch (event.key) {
                case 'ArrowLeft':
                    moveLeft();
                    break;
                case 'ArrowRight':
                    moveRight();
                    break;
                case 'ArrowUp':
                case ' ': // Space bar
                    jump();
                    break;
                case 'ArrowDown':
                    quickDrop();
                    break;
            }
        }
        
function togglePause() {
    // Don't do anything if not in playing or paused state
    if (!gameStarted || gameOver || (gameState !== "playing" && gameState !== "paused")) return;
    
    // Toggle pause state
    gamePaused = !gamePaused;
    
    if (gamePaused) {
        // Pause the game
        gameState = "paused";
        document.getElementById('pauseScreen').style.display = 'flex';
        document.getElementById('swipeInstructions').style.display = 'none';
        
        // FORCE HIDE PARTICLES DURING PAUSE
        const canvas = document.getElementById('particle-canvas');
        if (canvas) {
            canvas.style.display = 'none';
        }
        
        // Destroy particle system completely
        if (titleParticleSystem) {
            titleParticleSystem.destroy();
            titleParticleSystem = null;
        }
        
        // INSTANT audio cutoff - no hanging sound!
        if (musicPlaying) {
            try {
                // Stop all music layers instantly
                musicLayers.forEach(layer => {
                    if (layer.pattern) {
                        layer.pattern.stop(0); // Stop immediately
                    }
                    if (layer.synth) {
                        layer.synth.volume.rampTo(-60, 0.01); // Instant volume cut
                    }
                });
                
                // Stop transport and cancel scheduled events
                Tone.Transport.stop();
                Tone.Transport.cancel();
                
                musicPlaying = false;
            } catch (error) {
                console.log('Audio pause error (non-critical):', error);
            }
        }
        
        // Also stop any preview music
        if (window.previewMusic && window.previewMusic.playing) {
            try {
                stopPreview();
            } catch (error) {
                console.log('Preview stop error (non-critical):', error);
            }
        }
        
    } else {
        // Resume the game
        gameState = "playing";
        document.getElementById('pauseScreen').style.display = 'none';
        if (isMobile) {
            document.getElementById('swipeInstructions').style.display = 'block';
        }
        
        // ENSURE PARTICLES STAY HIDDEN WHEN RESUMING
        const canvas = document.getElementById('particle-canvas');
        if (canvas) {
            canvas.style.display = 'none';
        }
        
        // Restart music cleanly if enabled
        if (backgroundMusicEnabled) {
            try {
                // Recreate music layers for clean restart
                createBackgroundMusic();
                startBackgroundMusic();
            } catch (error) {
                console.log('Audio resume error (non-critical):', error);
            }
        }
    }
}

        // Show character select screen from game over menu
function showCharacterSelectScreen() {
    // Hide game over screen
    document.getElementById('gameOver').style.display = 'none';
    
    // Show character select screen
    document.getElementById('characterSelectScreen').style.display = 'flex';
    
    // Reset game state
    gameState = "characterSelect";
    
    // Reset the selected character index to current character
    selectedCharacterIndex = characterNames.indexOf(currentCharacter);
    if (selectedCharacterIndex === -1) selectedCharacterIndex = 0;
    
    // Reinitialize character select screen completely
    initCharacterSelectScreen();
}

// Show world select screen from character select (NEW FUNCTION)
function showWorldSelectFromCharacter() {
    // Hide character select screen
    document.getElementById('characterSelectScreen').style.display = 'none';
    
    // Show world select screen
    document.getElementById('worldSelectScreen').style.display = 'flex';
    
    // Reset game state
    gameState = "worldSelect";
    
    // Reset the selected world index to current world
    selectedWorldIndex = availableWorlds.findIndex(w => w.id === currentWorld);
    if (selectedWorldIndex === -1) selectedWorldIndex = 0;
    
    // Initialize world select screen
    initWorldSelectScreen();
}


        // Restart from pause menu
        function restartFromPause() {
            // First close the pause menu
            document.getElementById('pauseScreen').style.display = 'none';
            
            // Then restart the game
            restartGame();
        }

        // Show settings screen from pause menu
        function toggleSettingsFromPause() {
            // Hide pause screen
            document.getElementById('pauseScreen').style.display = 'none';
            
            // Show settings screen and overlay
            document.getElementById('settingsScreen').style.display = 'flex';
            document.getElementById('modalOverlay').style.display = 'block';
            
            // Game is already paused from pause menu, so we don't need to change gamePaused
            // But we should update the game state
            gameState = "paused"; // Keep it in paused state while in settings
        }

// Return to main menu from pause screen
function returnToMainMenuFromPause() {
    // Hide pause screen first
    document.getElementById('pauseScreen').style.display = 'none';
    
    // Reset pause state
    gamePaused = false;
    
    // Call the existing backToMainMenu function
    if (typeof backToMainMenu === 'function') {
        backToMainMenu();
    } else {
        // Fallback if backToMainMenu doesn't exist
        // Reset game state
        gameStarted = false;
        gameOver = false;
        gameState = "menu";
        
        // Stop music
        if (musicPlaying) {
            stopBackgroundMusic();
        }
        
        // Show main menu
        document.getElementById('main-menu').style.display = 'flex';
        document.getElementById('game').style.display = 'none';
    }
}

        // Show settings screen from game over menu
        function toggleSettingsFromGameOver() {
            // Hide game over screen
            document.getElementById('gameOver').style.display = 'none';
            
            // Show settings screen and overlay
            document.getElementById('settingsScreen').style.display = 'flex';
            document.getElementById('modalOverlay').style.display = 'block';
            
            // Keep game state as "gameOver" so we know where to return
            gameState = "gameOver";
        }

        // Show settings screen during gameplay
        function toggleSettingsFromGame() {
            // Pause the game
            gamePaused = true;
            
            // Show settings screen and overlay
            document.getElementById('settingsScreen').style.display = 'flex';
            document.getElementById('modalOverlay').style.display = 'block';
            
            // Set game state
            gameState = "playing"; // Remember we're coming from playing state
        }
        
        function moveLeft() {
            if (currentLane > 0) {
                currentLane--;
                laneChangeCount++; // Add this line
            }
        }
        
        function moveRight() {
            if (currentLane < 2) {
                currentLane++;
                laneChangeCount++; // Add this line
            }
        }
        
        function jump() {
    if (!jumping) {
        playJumpSound(); // Add this line
        jumping = true;
        jumpDirection = 1;
        jumpRotation = 0; // Reset flip rotation
        jumpCount++;
        
        // Adjust jump height for pumpkin character (higher jumps)
        if (currentCharacter === 'pumpkin') {
            jumpHeight = 2.0;    // Reduced height but still higher than others
            jumpSpeed = 0.08;    // Reduced speed to maintain same duration
        } else {
            jumpHeight = 1.6;    // Reduced height for all other characters
            jumpSpeed = 0.065;   // Reduced speed to maintain same duration
        }
                
                
            }
        }
        
        function quickDrop() {
            // Only work if the character is currently jumping and moving upward
            if (jumping) {
                // If going up, immediately reverse direction
                if (jumpDirection === 1) {
                    jumpDirection = -1;
                    // Increase fall speed for a quicker drop
                    jumpSpeed *= 1.5;
                }
                // If already falling, increase fall speed
                else if (jumpDirection === -1) {
                    // Increase fall speed for a quicker drop
                    jumpSpeed *= 1.2;
                }
            }
        }

      
        
// ==================== SCENERY SYSTEM ====================
// Background scenery, environmental decorations, and world atmosphere
// Dependencies: World System, forest.js, desert.js
// Functions: spawnScenery(), createTallPine(), createMushroomPatch(), etc.

        // Create roadside scenery objects
        function spawnScenery() {
            // Spawn scenery to the sides of the lanes
const side = Math.random() > 0.5 ? 1 : -1; // Left or right side
const distance = Math.random() * 3 + 5; // Distance from center

let sceneryObject;

if (currentWorld === 'forest') {
    // Forest-specific scenery
    const forestScenery = Math.floor(Math.random() * 5);
    switch (forestScenery) {
        case 0: // Tall pine trees
            sceneryObject = createTallPine();
            break;
        case 1: // Mushroom patches
            sceneryObject = createMushroomPatch();
            break;
        case 2: // Fern clusters
            sceneryObject = createFernCluster();
            break;
        case 3: // Firefly swarms
            sceneryObject = createFireflySwarm();
            break;
        case 4: // Ancient oak
            sceneryObject = createAncientOak();
            break;
    }
} else if (currentWorld === 'desert') {
    // Desert-specific scenery
    const desertScenery = Math.floor(Math.random() * 4);
    switch (desertScenery) {
        case 0: // Palm oasis
            sceneryObject = createPalmOasis();
            break;
        case 1: // Shimmering mirage
            sceneryObject = createMirage();
            break;
        case 2: // Rolling tumbleweed
            sceneryObject = createTumbleweed();
            break;
        case 3: // Distant pyramid
            sceneryObject = createPyramidDistance();
            break;
    }
} else {
    // Classic world scenery
    const sceneryType = Math.floor(Math.random() * 4);
    switch (sceneryType) {
        case 0: // Tree
            sceneryObject = createTree();
            break;
        case 1: // Rock formation
            sceneryObject = createRockFormation();
            break;
        case 2: // Flowers
            sceneryObject = createFlowers();
            break;
        case 3: // Bush cluster
            sceneryObject = createBushCluster();
            break;
    }
}
            
            sceneryObject.position.x = side * distance;
            sceneryObject.position.z = -50; // Spawn far away
            scene.add(sceneryObject);
            sceneryObjects.push(sceneryObject);
        }
        
        function createTree() {
            const treeGroup = new THREE.Group();
            
            // Tree trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.7
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 1;
            treeGroup.add(trunk);
            
            // Add bark texture
            const barkGeometry = new THREE.CylinderGeometry(0.31, 0.41, 2.01, 8, 4, true);
            const barkMaterial = new THREE.MeshStandardMaterial({
                color: 0x6B4513,
                roughness: 0.9,
                wireframe: true,
                transparent: true,
                opacity: 0.4
            });
            const bark = new THREE.Mesh(barkGeometry, barkMaterial);
            bark.position.y = 1;
            treeGroup.add(bark);
            
            // Tree leaves - layered cones for more natural look
            const leavesGeometries = [
                new THREE.ConeGeometry(1.5, 2, 8),
                new THREE.ConeGeometry(1.2, 1.8, 8),
                new THREE.ConeGeometry(0.9, 1.6, 8)
            ];
            
            const leavesMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x228B22,
                roughness: 0.6
            });
            
            const leaves1 = new THREE.Mesh(leavesGeometries[0], leavesMaterial);
            leaves1.position.y = 2.5;
            treeGroup.add(leaves1);
            
            const leaves2 = new THREE.Mesh(leavesGeometries[1], leavesMaterial);
            leaves2.position.y = 3.2;
            treeGroup.add(leaves2);
            
            const leaves3 = new THREE.Mesh(leavesGeometries[2], leavesMaterial);
            leaves3.position.y = 3.8;
            treeGroup.add(leaves3);
            
            return treeGroup;
        }
        
        function createRockFormation() {
            const rockFormationGroup = new THREE.Group();
            
            // Create several rocks of different sizes and shapes
            for (let i = 0; i < 7; i++) {
                const size = Math.random() * 0.8 + 0.4;
                // Mix different geometries for more natural look
                let rockGeometry;
                const geoType = Math.floor(Math.random() * 3);
                switch (geoType) {
                    case 0:
                        rockGeometry = new THREE.DodecahedronGeometry(size, 1);
                        break;
                    case 1:
                        rockGeometry = new THREE.IcosahedronGeometry(size, 0);
                        break;
                    case 2:
                        rockGeometry = new THREE.OctahedronGeometry(size, 1);
                        break;
                }
                
                // Mix different shades of gray
                const shade = Math.random() * 40 + 90; // 90-130 range for gray
                const rockMaterial = new THREE.MeshStandardMaterial({ 
                    color: new THREE.Color().setRGB(shade/255, shade/255, shade/255),
                    roughness: 0.8,
                    flatShading: true
                });
                
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.set(
                    Math.random() * 2 - 1,
                    size / 2,
                    Math.random() * 2 - 1
                );
                rock.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                rock.scale.set(
                    1 + Math.random() * 0.4 - 0.2,
                    1 + Math.random() * 0.4 - 0.2,
                    1 + Math.random() * 0.4 - 0.2
                );
                rockFormationGroup.add(rock);
            }
            
            // Add some moss on top of some rocks
            const mossGeometry = new THREE.SphereGeometry(0.2, 8, 4);
            const mossMaterial = new THREE.MeshStandardMaterial({
                color: 0x3A5F0B,
                roughness: 1
            });
            
            for (let i = 0; i < 4; i++) {
                const moss = new THREE.Mesh(mossGeometry, mossMaterial);
                moss.position.set(
                    Math.random() * 1.5 - 0.75,
                    Math.random() * 0.5 + 0.8,
                    Math.random() * 1.5 - 0.75
                );
                moss.scale.set(0.6, 0.3, 0.6);
                rockFormationGroup.add(moss);
            }
            
            return rockFormationGroup;
        }
        
        function createFlowers() {
    const flowerGroup = new THREE.Group();
    
    // Skip grass base - flowers will sit directly on the dark side terrain
            
            // Add flowers of different colors
            const flowerColors = [
                0xFF0000, // Red
                0xFFFF00, // Yellow
                0xFF00FF, // Pink
                0xFFFFFF, // White
                0x0000FF, // Blue
                0xFF9900  // Orange
            ];
            
            for (let i = 0; i < 15; i++) {
                // Stem
                const stemGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.5, 8);
                const stemMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
                const stem = new THREE.Mesh(stemGeometry, stemMaterial);
                
                // Position within flower patch area
const angle = Math.random() * Math.PI * 2;
const radius = Math.random() * 1.2; // Slightly larger spread since no grass circle
stem.position.set(
    Math.cos(angle) * radius,
    0.25,
    Math.sin(angle) * radius
);
                
                // Slight random tilt to stems
                stem.rotation.set(
                    Math.random() * 0.3 - 0.15,
                    0,
                    Math.random() * 0.3 - 0.15
                );
                
                // Flower head - choose different shapes for variety
                const flowerType = Math.floor(Math.random() * 3);
                let flower;
                
                if (flowerType === 0) {
                    // Simple sphere flower
                    const flowerGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                    const flowerMaterial = new THREE.MeshStandardMaterial({ 
                        color: flowerColors[Math.floor(Math.random() * flowerColors.length)],
                        emissive: 0x333333,
                        emissiveIntensity: 0.2
                    });
                    flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
                    flower.position.y = 0.5;
                } 
                else if (flowerType === 1) {
                    // Daisy-like flower with petals
                    flower = new THREE.Group();
                    
                    // Center of flower
                    const centerGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                    const centerMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFF00 });
                    const center = new THREE.Mesh(centerGeometry, centerMaterial);
                    flower.add(center);
                    
                    // Add petals
                    const petalColor = flowerColors[Math.floor(Math.random() * flowerColors.length)];
                    const petalMaterial = new THREE.MeshStandardMaterial({ 
                        color: petalColor,
                        emissive: petalColor,
                        emissiveIntensity: 0.1
                    });
                    
                    for (let j = 0; j < 8; j++) {
                        const petalGeometry = new THREE.SphereGeometry(0.04, 8, 8);
                        const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                        const petalAngle = (j / 8) * Math.PI * 2;
                        petal.position.set(
                            Math.cos(petalAngle) * 0.08,
                            0,
                            Math.sin(petalAngle) * 0.08
                        );
                        petal.scale.set(1.5, 0.5, 1.5);
                        flower.add(petal);
                    }
                    
                    flower.position.y = 0.5;
                }
                else {
                    // Tulip-like flower
                    const flowerGeometry = new THREE.ConeGeometry(0.08, 0.15, 8);
                    const flowerMaterial = new THREE.MeshStandardMaterial({ 
                        color: flowerColors[Math.floor(Math.random() * flowerColors.length)],
                        emissive: 0x333333,
                        emissiveIntensity: 0.2
                    });
                    flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
                    flower.position.y = 0.5;
                    flower.rotation.x = Math.PI; // Invert cone to look like a tulip
                }
                
                stem.add(flower);
                flowerGroup.add(stem);
            }
            
            return flowerGroup;
        }
        
        function createBushCluster() {
            const bushClusterGroup = new THREE.Group();
            
            // Create several bushes of different sizes
            for (let i = 0; i < 5; i++) {
                const bushSize = Math.random() * 0.6 + 0.6;
                
                // Base bush
                const bushGeometry = new THREE.SphereGeometry(bushSize, 8, 8);
                const bushMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x228B22, 
                    roughness: 0.7
                });
                const bush = new THREE.Mesh(bushGeometry, bushMaterial);
                
                // Position bushes in a small cluster
                const angle = Math.random() * Math.PI * 2;
                const clusterRadius = Math.random() * 1.2;
                bush.position.set(
                    Math.cos(angle) * clusterRadius,
                    bushSize / 2,
                    Math.sin(angle) * clusterRadius
                );
                
                // Add some variation to the bush color
                const colorVariation = Math.random() * 0.2 - 0.1; // -0.1 to 0.1
                bushMaterial.color.g += colorVariation;
                
                bushClusterGroup.add(bush);
                
                // Add details to each bush
                const detailGeometry = new THREE.SphereGeometry(bushSize * 1.05, 8, 8);
                const detailMaterial = new THREE.MeshStandardMaterial({
                    color: 0x196F3D,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.3
                });
                const detail = new THREE.Mesh(detailGeometry, detailMaterial);
                detail.position.copy(bush.position);
                bushClusterGroup.add(detail);
            }
            
            return bushClusterGroup;
        }
        
        // Create a coin with improved shiny gold appearance
        function spawnCoin() {
            const laneIndex = Math.floor(Math.random() * 3); // Random lane
            const coinGroup = new THREE.Group();
            
            // Create coin with brilliant shiny gold material
// Reuse shared geometry for all coins
if (!window.sharedCoinGeometry) {
    window.sharedCoinGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.05, 16); // Reduced segments
}
const coinGeometry = window.sharedCoinGeometry;
const coinMaterial = new THREE.MeshStandardMaterial({ 
    color: 0xFFD700, // Bright gold
    metalness: 1.0,  // Fully metallic
    roughness: 0.05, // Very shiny
    emissive: 0xFFD700, // Golden glow
    emissiveIntensity: 0.4
});
const coin = new THREE.Mesh(coinGeometry, coinMaterial);
coin.rotation.x = Math.PI / 2;
coinGroup.add(coin);

// Add edge detail to coin with enhanced shine (properly aligned)
const edgeGeometry = new THREE.TorusGeometry(0.3, 0.03, 8, 32);
const edgeMaterial = new THREE.MeshStandardMaterial({ 
    color: 0xFFD700, // Same bright gold
    metalness: 1.0, 
    roughness: 0.03, // Extra shiny
    emissive: 0xFFD700,
    emissiveIntensity: 0.3
});
const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
// No rotation needed - both coin and edge are now in the same orientation
coinGroup.add(edge);

// Add sparkle particles around the coin
for (let i = 0; i < 8; i++) {
    const sparkleGeometry = new THREE.SphereGeometry(0.02, 8, 8);
    const sparkleMaterial = new THREE.MeshBasicMaterial({
        color: 0xFFFFFF,
        transparent: true,
        opacity: 0.8
    });
    
    const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
    
    // Position sparkles around the coin
    const angle = (i / 8) * Math.PI * 2;
    const radius = 0.4 + Math.random() * 0.1;
    sparkle.position.set(
        Math.cos(angle) * radius,
        0,
        Math.sin(angle) * radius
    );
    
    // Animation properties for sparkles
    sparkle.userData = {
        orbitSpeed: 0.02 + Math.random() * 0.02,
        orbitRadius: radius,
        orbitAngle: angle,
        pulseSpeed: 0.05 + Math.random() * 0.05,
        pulsePhase: Math.random() * Math.PI * 2
    };
    
    coinGroup.add(sparkle);
}

// Store sparkles for animation
coinGroup.userData.sparkles = coinGroup.children.filter(child => 
    child.userData && child.userData.orbitSpeed !== undefined
);
            
            // Add dollar sign to the coin (simple geometry representation)
            const dollarSignGroup = new THREE.Group();
            
            // Vertical bar
            const barGeometry = new THREE.BoxGeometry(0.05, 0.3, 0.02);
            const dollarMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFCC00,
                metalness: 1.0, 
                roughness: 0.2,
                emissive: 0xFFAA00,
                emissiveIntensity: 0.3
            });
            const bar = new THREE.Mesh(barGeometry, dollarMaterial);
            dollarSignGroup.add(bar);
            
            // Top and bottom curves
            const topCurveGeometry = new THREE.TorusGeometry(0.08, 0.02, 8, 8, Math.PI);
            const topCurve = new THREE.Mesh(topCurveGeometry, dollarMaterial);
            topCurve.position.set(0.04, 0.08, 0);
            topCurve.rotation.z = Math.PI / 2;
            dollarSignGroup.add(topCurve);
            
            const bottomCurveGeometry = new THREE.TorusGeometry(0.08, 0.02, 8, 8, Math.PI);
            const bottomCurve = new THREE.Mesh(bottomCurveGeometry, dollarMaterial);
            bottomCurve.position.set(-0.04, -0.08, 0);
            bottomCurve.rotation.z = -Math.PI / 2;
            dollarSignGroup.add(bottomCurve);
            
            // Front side dollar sign
dollarSignGroup.position.set(0, 0, 0.03); // Position it just on the surface of the coin
// No rotation - keep dollar sign standing upright
coinGroup.add(dollarSignGroup);

// Back side dollar sign (duplicate)
const dollarSignGroupBack = dollarSignGroup.clone();
dollarSignGroupBack.position.set(0, 0, -0.03); // Position on the back surface
dollarSignGroupBack.rotation.y = Math.PI; // Flip it so it reads correctly from the back
coinGroup.add(dollarSignGroupBack);
            
            // Remove the highlight plane - it was causing visual issues
// Instead, the coin already has sparkle particles for visual appeal
            
            // Position coin in lane, and slightly higher than obstacles for jumping
            coinGroup.position.x = lanes[laneIndex];
            coinGroup.position.y = 1.2; // Higher than obstacles for jumping
            coinGroup.position.z = -50; // Spawn far away
            
            scene.add(coinGroup);
            coins.push(coinGroup);
        }

// Create rare gradient coin - spawns very rarely, worth 100 coins
function spawnRareCoin() {
    const laneIndex = Math.floor(Math.random() * 3); // Random lane
    const rareCoinGroup = new THREE.Group();
    
    // Create coin with brilliant gradient material
    const coinGeometry = new THREE.CylinderGeometry(0.35, 0.35, 0.06, 32); // Slightly bigger
    
    // Create gradient canvas texture
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    const context = canvas.getContext('2d');
    
    // Create radial gradient (purple to blue to teal to green)
    const gradient = context.createRadialGradient(128, 128, 0, 128, 128, 128);
    gradient.addColorStop(0, '#8A2BE2');    // Purple center
    gradient.addColorStop(0.3, '#4169E1');  // Blue
    gradient.addColorStop(0.6, '#20B2AA');  // Teal
    gradient.addColorStop(1, '#32CD32');     // Green edge
    
    context.fillStyle = gradient;
    context.fillRect(0, 0, 256, 256);
    
    const gradientTexture = new THREE.CanvasTexture(canvas);
    
    const rareCoinMaterial = new THREE.MeshStandardMaterial({ 
        map: gradientTexture,
        color: 0xFFFFFF, // White to not affect texture
        metalness: 1.0,  // Fully metallic
        roughness: 0.05, // Very shiny
        emissive: 0x4169E1, // Blue glow
        emissiveIntensity: 0.3
    });
    const rareCoin = new THREE.Mesh(coinGeometry, rareCoinMaterial);
    rareCoin.rotation.x = Math.PI / 2;
    rareCoinGroup.add(rareCoin);
    
    // Add edge detail with vibrant blue-green gradient
const edgeGeometry = new THREE.TorusGeometry(0.35, 0.04, 8, 32);
const edgeMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x00CCFF, // Bright cyan edge
    metalness: 1.0, 
    roughness: 0.01, // Super shiny
    emissive: 0x0088FF,
    emissiveIntensity: 0.7 // Bright glow
});
    const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
    rareCoinGroup.add(edge);
    
    // Create the Solana-style logo using simple geometry
const chevronGroup = new THREE.Group();

// Brighter, more vibrant Solana colors
const solanaColors = [0xBB66FF, 0x00FF88, 0x00FFDD]; // Brighter Purple, Bright Green, Bright Cyan

// Create three Solana-style parallelograms using BoxGeometry (reliable)
for (let i = 0; i < 3; i++) {
    // Create parallelogram using skewed boxes
    const parallelogramGroup = new THREE.Group();
    
    // Main parallelogram body
    const mainGeometry = new THREE.BoxGeometry(0.3, 0.08, 0.02);
    const chevronMaterial = new THREE.MeshStandardMaterial({ 
        color: solanaColors[i],
        metalness: 1.0, 
        roughness: 0.02, // Extra shiny
        emissive: solanaColors[i],
        emissiveIntensity: 0.6 // Much brighter glow
    });
    
    const mainBody = new THREE.Mesh(mainGeometry, chevronMaterial);
    mainBody.rotation.z = 0.3; // Skew angle for Solana look
    parallelogramGroup.add(mainBody);
    
    // Add angled ends to create parallelogram shape
    const endGeometry = new THREE.BoxGeometry(0.06, 0.06, 0.02);
    
    const leftEnd = new THREE.Mesh(endGeometry, chevronMaterial);
    leftEnd.position.set(-0.12, -0.05, 0);
    leftEnd.rotation.z = 0.8;
    parallelogramGroup.add(leftEnd);
    
    const rightEnd = new THREE.Mesh(endGeometry, chevronMaterial);
    rightEnd.position.set(0.12, 0.05, 0);
    rightEnd.rotation.z = 0.8;
    parallelogramGroup.add(rightEnd);
    
    // Position the three parallelograms
    if (i === 0) {
        parallelogramGroup.position.set(0, 0.1, 0);
    } else if (i === 1) {
        parallelogramGroup.position.set(0, 0, 0);
    } else {
        parallelogramGroup.position.set(0, -0.1, 0);
    }
    
    chevronGroup.add(parallelogramGroup);
}
    
    // Front side chevron
    chevronGroup.position.set(0, 0, 0.035);
    rareCoinGroup.add(chevronGroup);
    
    // Back side chevron (duplicate)
    const chevronGroupBack = chevronGroup.clone();
    chevronGroupBack.position.set(0, 0, -0.035);
    chevronGroupBack.rotation.y = Math.PI;
    rareCoinGroup.add(chevronGroupBack);
    
    // Add enhanced sparkle particles with gradient colors
    for (let i = 0; i < 12; i++) {
        const sparkleGeometry = new THREE.SphereGeometry(0.03, 8, 8);
        const sparkleColors = [0x8A2BE2, 0x4169E1, 0x20B2AA, 0x32CD32]; // Gradient colors
        const sparkleColor = sparkleColors[i % sparkleColors.length];
        
        const sparkleMaterial = new THREE.MeshBasicMaterial({
            color: sparkleColor,
            transparent: true,
            opacity: 0.8
        });
        
        const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
        
        const angle = (i / 12) * Math.PI * 2;
        const radius = 0.5 + Math.random() * 0.1;
        sparkle.position.set(
            Math.cos(angle) * radius,
            0,
            Math.sin(angle) * radius
        );
        
        sparkle.userData = {
            orbitSpeed: 0.03 + Math.random() * 0.02,
            orbitRadius: radius,
            orbitAngle: angle,
            pulseSpeed: 0.08 + Math.random() * 0.05,
            pulsePhase: Math.random() * Math.PI * 2
        };
        
        rareCoinGroup.add(sparkle);
    }
    
    // Store sparkles for animation
    rareCoinGroup.userData.sparkles = rareCoinGroup.children.filter(child => 
        child.userData && child.userData.orbitSpeed !== undefined
    );
    rareCoinGroup.userData.rotationSpeed = Math.random() * 0.02 + 0.02; // Faster rotation
    
    // Position coin in lane, higher than regular coins
    rareCoinGroup.position.x = lanes[laneIndex];
    rareCoinGroup.position.y = 1.4; // Slightly higher than regular coins
    rareCoinGroup.position.z = -50; // Spawn far away
    
    scene.add(rareCoinGroup);
    rareCoins.push(rareCoinGroup);
}

        
// ==================== COLLISION SYSTEM ====================
// Collision detection, hit testing, and collision response
// Dependencies: Player Controls, Obstacle System, Power-up System
// Functions: checkCollision(), checkSimpleCollision(), collision handling logic

        // Smart collision - early exit for distant objects
function fastCollisionCheck(object1, object2, threshold = 3.0) {
    const dx = object1.position.x - object2.position.x;
    const dy = object1.position.y - object2.position.y;
    const dz = object1.position.z - object2.position.z;
    const distanceSquared = dx * dx + dy * dy + dz * dz;
    
    // Early exit if objects are too far apart
    if (distanceSquared > threshold * threshold) {
        return false;
    }
    
    // Only do expensive collision check if objects are close
    return checkCollision(object2);
}

        // Optimized collision detection with caching
function checkCollision(object) {
    // For coins and power-ups, use simple distance-based collision (faster)
    const isCoin = coins.includes(object) || rareCoins.includes(object);
    const isPowerUp = powerUps.includes(object);
    
    if (isCoin || isPowerUp) {
        return checkSimpleCollision(object, player, 1.5);
    }

    // For ancient ruins (desert pillars), only check collision with the main pillar - HANDLE FIRST
const isAncientRuin = obstacles.includes(object) && object.children.some(child => child.userData && child.userData.isMainPillar);

if (isAncientRuin) {
    // Find the main pillar specifically
    const mainPillar = object.children.find(child => child.userData && child.userData.isMainPillar);
    if (mainPillar) {
        // Get world positions to check distance first
        const playerPos = new THREE.Vector3();
        const pillarPos = new THREE.Vector3();
        player.getWorldPosition(playerPos);
        mainPillar.getWorldPosition(pillarPos);
        
        const distance = playerPos.distanceTo(pillarPos);
        console.log('🏛️ Ancient pillar distance check:', distance, 'Player at:', playerPos.x, 'Pillar at:', pillarPos.x);
        
        // Only check collision if player is very close to the pillar
        if (distance < 2.0) {
            // Create a smaller collision box for just the pillar core
            const pillarBox = new THREE.Box3().setFromObject(mainPillar);
            
            // Shrink the collision box to make it more forgiving
            const shrinkAmount = 0.3; // Make collision 30% smaller
            pillarBox.min.x += shrinkAmount;
            pillarBox.max.x -= shrinkAmount;
            pillarBox.min.z += shrinkAmount;
            pillarBox.max.z -= shrinkAmount;
            
            const playerBox = new THREE.Box3().setFromObject(player);
            
            // Can jump over pillars if high enough
            if (jumping && player.position.y > 1.2) {
                console.log('🦘 Jumped over ancient pillar!');
                return false;
            }
            
            const collision = playerBox.intersectsBox(pillarBox);
            if (collision) {
                console.log('🏛️ Hit ancient pillar!');
            }
            return collision;
        }
        return false; // No collision if too far from pillar
    }
}

// For quicksand, only check collision with the main pit area
const isQuicksand = obstacles.includes(object) && object.children.some(child => 
    child.geometry && child.geometry.type === 'CircleGeometry' && child.position.y < 0
);

if (isQuicksand) {
    // Find the main quicksand pit (the CircleGeometry at y = -0.1)
    const mainPit = object.children.find(child => 
        child.geometry && child.geometry.type === 'CircleGeometry' && child.position.y < 0
    );
    
    if (mainPit) {
        // Get world positions to check distance first
        const playerPos = new THREE.Vector3();
        const pitPos = new THREE.Vector3();
        player.getWorldPosition(playerPos);
        mainPit.getWorldPosition(pitPos);
        
        const distance = playerPos.distanceTo(pitPos);
        console.log('🏜️ Quicksand distance check:', distance, 'Player at:', playerPos.x, 'Pit at:', pitPos.x);
        
        // Only check collision if player is close to the pit center
        if (distance < 1.0) {
            // Can jump over quicksand if high enough
            if (jumping && player.position.y > 0.8) {
                console.log('🦘 Jumped over quicksand!');
                return false;
            }
            console.log('💥 Hit quicksand pit!');
            return true;
        }
        return false; // No collision if too far from pit center
    }
}
    
    // For Monster character, use precise collision with main body only
if (currentCharacter === 'monster') {
    // Find the main body (central sphere) of the Monster
    let monsterBody = null;
    for (let i = 0; i < player.children.length; i++) {
        const child = player.children[i];
        if (child.userData && child.userData.isMainBody) {
            monsterBody = child;
            break;
        }
    }
    
    if (monsterBody) {
        // Use cached collision boundaries
        const bodyBox = getCachedCollisionBox(monsterBody);
        const objectBox = getCachedCollisionBox(object);
        
        // Check intersection between cached boxes
        return bodyBox.intersectsBox(objectBox);
    }
}

// For Dragon character, use cached collision with body only (ignore wings)
if (currentCharacter === 'dragon') {
    // Use simple distance check for performance, but verify with wings
    if (checkSimpleCollision(object, player, 2.0)) {
        // Double-check with cached bounding box if close
        const objectBox = getCachedCollisionBox(object);
        const playerBox = getCachedCollisionBox(player);
        return playerBox.intersectsBox(objectBox);
    }
    return false;
}
    
    // For UFO character, handle collision differently for coins vs obstacles
if (currentCharacter === 'ufo') {
    // Check if this is a coin (coins are in the coins array)
    const isCoin = coins.includes(object);
    
    if (isCoin) {
        // For coins, use expanded collision area
        const playerBox = new THREE.Box3().setFromObject(player);
        const objectBox = new THREE.Box3().setFromObject(object);
        
        // Expand the UFO's collision box vertically to catch coins above and below
        playerBox.min.y -= 0.3; // Extend downward
        playerBox.max.y += 0.5; // Extend upward more to catch coins
        
        return playerBox.intersectsBox(objectBox);
    } else {
        // For obstacles, create a custom bounding box excluding the tractor beam
        const customBox = new THREE.Box3();
        
        // Only include specific UFO parts (exclude the beam which is usually the last child)
        for (let i = 0; i < player.children.length; i++) {
            const child = player.children[i];
            // Skip the tractor beam (it's positioned at y = -0.6)
            if (child.position.y > -0.4) {
                const childBox = new THREE.Box3().setFromObject(child);
                if (customBox.isEmpty()) {
                    customBox.copy(childBox);
                } else {
                    customBox.union(childBox);
                }
            }
        }
        
        const objectBox = new THREE.Box3().setFromObject(object);
        return customBox.intersectsBox(objectBox);
    }
}

// For meteors, use precise lane-based collision detection
if (meteors.includes(object)) {
    // Check if meteor and player are in the same lane
    const meteorLane = object.userData ? object.userData.targetLane : -1;
    const playerLane = currentLane;
    
    // Only collide if they're in the same lane AND close enough vertically
    if (meteorLane === playerLane) {
        const playerBox = new THREE.Box3().setFromObject(player);
        const meteorBox = new THREE.Box3().setFromObject(object);
        
        // Make collision more precise - only check if meteor is at ground level
        if (object.position.y <= 1.0) { // Meteor is close to ground
            return playerBox.intersectsBox(meteorBox);
        }
    }
    
    return false; // No collision if not in same lane or meteor is too high
}

// Check if this is a fallen tree - only collide with the trunk
const isFallenTree = obstacles.includes(object) && object.children.some(child => child.userData && child.userData.isMainTrunk);

if (isFallenTree) {
    // Find the trunk specifically
    const trunk = object.children.find(child => child.userData && child.userData.isMainTrunk);
    if (trunk) {
        // Get world positions
        const playerPos = new THREE.Vector3();
        const trunkPos = new THREE.Vector3();
        player.getWorldPosition(playerPos);
        trunk.getWorldPosition(trunkPos);
        
        // Only check collision if player is close to the trunk's actual position
        const distance = playerPos.distanceTo(trunkPos);
        
        // Much stricter collision - only collide if very close to trunk center
        if (distance < 1.0) {
            // Can jump over fallen trees
            if (jumping && player.position.y > 1.0) {
                console.log('🦘 Jumped over fallen tree!');
                return false;
            }
            console.log('💥 Hit fallen tree trunk!');
            return true;
        }
        return false; // No collision if too far from trunk
    }
}



// For Robot character, use collision detection ONLY for main body parts (exclude particles)
if (currentCharacter === 'robot') {
    // Create collision box only from robot's main body parts (exclude electromagnetic particles)
    const robotMainBox = new THREE.Box3();
    
    // Only include the first 7 children (body, head, eyes, arms, legs, antenna)
    // Skip the electromagnetic field particles (children 8+)
    for (let i = 0; i < Math.min(7, player.children.length); i++) {
        const child = player.children[i];
        const childBox = new THREE.Box3().setFromObject(child);
        if (robotMainBox.isEmpty()) {
            robotMainBox.copy(childBox);
        } else {
            robotMainBox.union(childBox);
        }
    }
    
    const objectBox = new THREE.Box3().setFromObject(object);
    
    // Check if this is an obstacle and player is jumping
    const isObstacle = obstacles.includes(object);
    if (isObstacle && jumping && player.position.y > 1.2) {
        console.log('🦘 Robot jumped over obstacle at height:', player.position.y);
        return false; // No collision with obstacles when jumping high enough
    }
    
    // Robot shield - blocks obstacles (but not coins/power-ups)  
    if (robotShieldActive) {
        const isObstacle = obstacles.includes(object);
        const isStream = waterStreams.includes(object);
        const isMeteor = meteors.includes(object);
        
        if (isObstacle || isStream || isMeteor) {
            // Create shield spark effect when blocking
            createShieldSparkEffect(object.position);
            console.log('🤖 Robot shield blocked obstacle!');
            return false; // No collision when shield is active
        }
    }
    
    return robotMainBox.intersectsBox(objectBox);
}

// For Creature character, use collision detection ONLY for main body (exclude wisps and orbs)
if (currentCharacter === 'creature') {
    // Create collision box only from creature's main body parts (exclude wisps, tentacles, etc.)
    const creatureMainBox = new THREE.Box3();
    
    // Only include the first 2 children (main body and neon core)
    // Skip the eyes, tentacles, wisps, and dark aura (children 2+)
    for (let i = 0; i < Math.min(2, player.children.length); i++) {
        const child = player.children[i];
        const childBox = new THREE.Box3().setFromObject(child);
        if (creatureMainBox.isEmpty()) {
            creatureMainBox.copy(childBox);
        } else {
            creatureMainBox.union(childBox);
        }
    }
    
    const objectBox = new THREE.Box3().setFromObject(object);
    
    // Check if this is an obstacle and player is jumping
    const isObstacle = obstacles.includes(object);
    if (isObstacle && jumping && player.position.y > 1.2) {
        console.log('🦘 Creature jumped over obstacle at height:', player.position.y);
        return false; // No collision with obstacles when jumping high enough
    }
    
    return creatureMainBox.intersectsBox(objectBox);
}

// For other characters, use cached collision boundaries
const playerBox = getCachedCollisionBox(player);
const objectBox = getCachedCollisionBox(object);

// Check if this is an obstacle (not a coin or power-up) and player is jumping
const isObstacle = obstacles.includes(object);
if (isObstacle && jumping && player.position.y > 1.2) {
    return false; // No collision with obstacles when jumping high enough
}

// Ghost phase ability - can phase through obstacles (but not coins/power-ups)
if (currentCharacter === 'ghost' && ghostPhaseActive) {
    const isObstacle = obstacles.includes(object);
    const isStream = waterStreams.includes(object);
    
    if (isObstacle || isStream) {
        return false; // No collision when phasing
    }
}

// Robot shield - blocks obstacles (but not coins/power-ups)  
if (currentCharacter === 'robot' && robotShieldActive) {
    const isObstacle = obstacles.includes(object);
    const isStream = waterStreams.includes(object);
    const isMeteor = meteors.includes(object);
    
    if (isObstacle || isStream || isMeteor) {
        // Create shield spark effect when blocking
        createShieldSparkEffect(object.position);
        return false; // No collision when shield is active
    }
}

// Use cached collision boundaries for final check
return playerBox.intersectsBox(objectBox);
}
        
        // Create explosion effect when game over
        function createExplosion() {
            // Create explosion particles at player's position
            const numParticles = mobileExplosionCount;
            
            // Explosion colors based on the current character
            let colors = [0xff0000, 0xff7700, 0xffff00]; // Default apple colors
            
            if (currentCharacter === 'carrot') {
                colors = [0xFF8C00, 0xFFA500, 0xFF4500]; // Orange shades
            } else if (currentCharacter === 'pumpkin') {
                colors = [0xFF6600, 0xFF8800, 0xDD5500]; // Pumpkin shades
            } else if (currentCharacter === 'happyface') {
                colors = [0xFFFF00, 0xFFDD00, 0xFFCC00]; // Yellow shades
            } else if (currentCharacter === 'monster') {
                colors = [0x000000, 0x330000, 0x660000]; // Dark red/black shades
            } else if (currentCharacter === 'atom') {
                colors = [0x0088FF, 0x00FFFF, 0x0044AA]; // Blue/cyan shades
            }
            
            for (let i = 0; i < numParticles; i++) {
                // Random size for each particle
                const radius = Math.random() * 0.2 + 0.05;
                const geometry = new THREE.SphereGeometry(radius, 8, 8);
                const material = new THREE.MeshStandardMaterial({ 
                    color: colors[Math.floor(Math.random() * colors.length)],
                    emissive: colors[Math.floor(Math.random() * colors.length)],
                    emissiveIntensity: 0.5
                });
                
                const particle = new THREE.Mesh(geometry, material);
                
                // Set particle at player position
                particle.position.x = player.position.x;
                particle.position.y = player.position.y;
                particle.position.z = player.position.z;
                
                // Give random velocity in all directions
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.3,
                    Math.random() * 0.2 + 0.1,
                    (Math.random() - 0.5) * 0.3
                );
                
                // Add to scene and array
                scene.add(particle);
                explosionParticles.push(particle);
            }
            
            // Hide the player
            player.visible = false;
        }
        
        // Update explosion particles
        function updateExplosion() {
            // Update explosion particles positions based on velocity
            for (let i = explosionParticles.length - 1; i >= 0; i--) {
                const particle = explosionParticles[i];
                
                // Apply gravity and update position
                particle.userData.velocity.y -= 0.01;
                particle.position.x += particle.userData.velocity.x;
                particle.position.y += particle.userData.velocity.y;
                particle.position.z += particle.userData.velocity.z;
                
                // Make particles spin for more dynamic effect
                particle.rotation.x += 0.05;
                particle.rotation.y += 0.05;
                
                // Remove particles that fall below ground
                if (particle.position.y < -1) {
                    scene.remove(particle);
                    explosionParticles.splice(i, 1);
                }
            }
        }
        
        // Game over
function endGame() {
    playCrashSound(); // Add this line at the start
    gameState = "gameOver";
    gameOver = true;
    
    // BRING BACK PARTICLES FOR GAME OVER SCREEN
    if (!titleParticleSystem) {
        createTitleParticles();
    }
    
    // Show particle canvas
    const canvas = document.getElementById('particle-canvas');
    if (canvas) {
        canvas.style.display = 'block';
        ensureParticlesVisible();
    }
    
    // Hide UI elements
    document.getElementById('pauseBtn').style.display = 'none';
    document.getElementById('speedIndicator').style.display = 'none';
    document.getElementById('modalOverlay').style.display = 'none';
    if (isMobile) {
        document.getElementById('swipeInstructions').style.display = 'none';
    }
    
    // INSTANT audio cutoff - stop everything immediately
    try {
        if (musicPlaying) {
            // Stop all music layers instantly
            musicLayers.forEach(layer => {
                if (layer.pattern) {
                    layer.pattern.stop(0); // Stop immediately (no fade)
                }
                if (layer.synth) {
                    layer.synth.volume.rampTo(-60, 0.01); // Instant volume cut
                }
            });
            
            // Stop transport immediately
            Tone.Transport.stop();
            Tone.Transport.cancel(); // Cancel any scheduled events
            
            musicPlaying = false;
        }
        
        // Also stop any preview music if playing
        if (window.previewMusic && window.previewMusic.playing) {
            stopPreview();
        }
        
    } catch (error) {
        console.log('Audio stop error (non-critical):', error);
    }

    // Create explosion effect
    createExplosion();
    
    // Show game over screen after a short delay to see the explosion
setTimeout(() => {
    document.getElementById('finalScore').textContent = `Score: ${score}`;
    
    // Show total coins collected this session (no bonus since coins were added in real-time)
    document.getElementById('coinsCollected').textContent = `Final Balance: ${totalCoins} coins`;
    
    // Update daily challenges progress
if (dailyChallenges) {
    console.log('📊 Updating daily challenges with game stats:');
    
    // Calculate survival time in seconds
    survivalTime = Math.floor((Date.now() - gameStartTime) / 1000);
    
    // Update all challenge types
    if (typeof score !== 'undefined') {
        console.log(`  - Distance: ${score} meters`);
        dailyChallenges.updateProgress('distance', score);
    }
    
    if (typeof coinsCollectedThisRun !== 'undefined') {
        console.log(`  - Coins collected: ${coinsCollectedThisRun}`);
        dailyChallenges.updateProgress('coins', coinsCollectedThisRun);
    }
    
    if (typeof jumpCount !== 'undefined') {
        console.log(`  - Jumps: ${jumpCount}`);
        dailyChallenges.updateProgress('jumps', jumpCount);
    }
    
    if (typeof powerupsCollectedThisRun !== 'undefined') {
        console.log(`  - Powerups: ${powerupsCollectedThisRun}`);
        dailyChallenges.updateProgress('powerups', powerupsCollectedThisRun);
    }
    
    if (typeof maxSpeedReached !== 'undefined') {
        console.log(`  - Max speed level: ${maxSpeedReached}`);
        dailyChallenges.updateProgress('speed', maxSpeedReached);
    }
    
    if (typeof laneChangeCount !== 'undefined') {
        console.log(`  - Lane changes: ${laneChangeCount}`);
        dailyChallenges.updateProgress('laneChanges', laneChangeCount);
    }
    
    if (typeof survivalTime !== 'undefined') {
        console.log(`  - Survival time: ${survivalTime} seconds`);
        dailyChallenges.updateProgress('survivalTime', survivalTime);
    }
    
    if (typeof nearMissCount !== 'undefined') {
        console.log(`  - Near misses: ${nearMissCount}`);
        dailyChallenges.updateProgress('nearMisses', nearMissCount);
    }
}
        
        // Check if it's a high score and show input form if needed
        console.log('🏆 Checking if score is high score:', score);
        const isHighScore = checkHighScore(score);
        console.log('🏆 Is high score result:', isHighScore);

        if (isHighScore) {
            console.log('🏆 Showing name entry form');
            document.getElementById('newHighScoreMessage').style.display = 'block';
        } else {
            console.log('🏆 Not a high score - hiding name entry');
            document.getElementById('newHighScoreMessage').style.display = 'none';
        }
        
        document.getElementById('gameOver').style.display = 'flex';
        
        saveGameData('game_end');
    }, 1500);

// Update daily challenges progress
if (dailyChallenges) {
    console.log('📊 FINAL GAME STATS:');
    console.log(`  - Current Speed Level: ${currentSpeedLevel}`);
    console.log(`  - Max Speed Reached: ${maxSpeedReached}`);
    console.log(`  - Power-ups Collected: ${powerupsCollectedThisRun}`);
    
    // Log active challenges
    console.log('📋 Active Challenges:');
    dailyChallenges.challenges.forEach(challenge => {
        if (!challenge.completed) {
            console.log(`  - ${challenge.type}: ${challenge.progress}/${challenge.target}`);
        }
    });
    
    // Continue with challenge updates...
}

}

// Return to main menu from game over screen
function returnToMainMenuFromGameOver() {
    // Hide game over screen
    document.getElementById('gameOver').style.display = 'none';
    
    // Hide the game renderer
    if (renderer && renderer.domElement) {
        renderer.domElement.style.display = 'none';
    }
    
    // Reset game state
    gameStarted = false;
    gameOver = false;
    gameState = "menu";
    
    // Call the existing backToMainMenu function
    if (typeof backToMainMenu === 'function') {
        backToMainMenu();
    }
}

        // Add this function anywhere with your other game functions
function checkHighScore(currentScore) {
    let leaderboard = JSON.parse(localStorage.getItem('runningBlitzLeaderboard') || '[]');
    
    // It's a high score if leaderboard has less than 10 entries OR current score beats the lowest score
    const isHighScore = leaderboard.length < 10 || currentScore > (leaderboard[leaderboard.length - 1]?.score || 0);
    
    console.log(`Checking high score: ${currentScore}, is high score: ${isHighScore}`);
    console.log(`Need to beat: ${leaderboard[leaderboard.length - 1]?.score || 0}`);
    return isHighScore;
}

        // ==================== CHARACTER ABILITIES ====================
// Special character powers, abilities, and unique mechanics
// Dependencies: Character System, Audio System, Game Loop
// Functions: activateGhostPhase(), destroyObstaclesWithFire(), etc.

// Handle character-specific abilities
function handleCharacterAbilities() {
    // Update cooldowns
    if (robotShieldCooldown > 0) robotShieldCooldown--;
    if (dragonFireCooldown > 0) dragonFireCooldown--;
    if (ghostPhaseCooldown > 0) ghostPhaseCooldown--;
    
    // Robot Electromagnetic Shield (Performance Optimized)
if (currentCharacter === 'robot') {
    // Animate wireframe shield rotation
    if (player.userData && player.userData.shieldDome && robotShieldActive) {
        const shield = player.userData.shieldDome;
        shield.rotation.y += shield.userData.rotationSpeed || 0.01;
        shield.rotation.x += (shield.userData.rotationSpeed || 0.01) * 0.5;
        
        // Pulse the electromagnetic glow
        shield.material.emissiveIntensity = 0.5 + Math.sin(frameCount * 0.1) * 0.2;
    }
    
    // Auto-activate shield when obstacles are near (if not on cooldown)
    if (!robotShieldActive && robotShieldCooldown <= 0) {
        for (const obstacle of obstacles) {
            const distance = obstacle.position.distanceTo(player.position);
            if (distance < 8 && obstacle.position.z < player.position.z) {
                activateRobotShield();
                break;
            }
        }
    }
    
    // Deactivate shield after duration
    if (robotShieldActive) {
        // Shield lasts 3 seconds (180 frames)
        if (frameCount % 180 === 0) {
            deactivateRobotShield();
        }
    }
}
    
    // Dragon Fire Breath - SIMPLIFIED VERSION
if (currentCharacter === 'dragon') {
    // Auto-destroy obstacles when they get close (no visual fire effect)
    if (dragonFireCooldown <= 0) {
        for (const obstacle of obstacles) {
            // Only check obstacles that are in front of the dragon
            if (obstacle.position.z < player.position.z - 1) {
                // Check if obstacle is in the same lane as the dragon
                const obstacleX = obstacle.position.x;
                const dragonX = lanes[currentLane]; // Dragon's current lane position
                
                // Only destroy obstacles that are:
                // 1. In the exact same lane (within 0.5 units of lane center)
                // 2. Within 6 units in front of the dragon
                if (Math.abs(obstacleX - dragonX) <= 0.5 && 
                    Math.abs(obstacle.position.z - player.position.z) <= 6) {
                    
                    // Create destruction effect without fire particles
                    createObstacleDestruction(obstacle.position);
                    
                    // Remove obstacle
                    scene.remove(obstacle);
                    obstacles.splice(obstacles.indexOf(obstacle), 1);
                    
                    console.log('🔥 Obstacle destroyed by dragon breath in lane', currentLane);
                    dragonFireCooldown = 240; // 4 second cooldown
                    break;
                }
            }
        }
    }
}
    
    // Ghost Phase Ability
if (currentCharacter === 'ghost') {
    // Initialize charges if starting fresh
    if (ghostPhaseCharges === 0 && ghostPhaseCooldown <= 0) {
        ghostPhaseCharges = 3;
        console.log('👻 Ghost starting with 3 phase charges!');
    }
    
    // Restore charges over time (one charge every 5 seconds)
    if (ghostPhaseCharges < 3 && ghostPhaseCooldown <= 0) {
        ghostPhaseCooldown = 300; // 5 seconds to restore next charge
        console.log('👻 Ghost charge restoration started...');
    }
    
    // Auto-activate phase when about to hit obstacle (if charges available)
    if (!ghostPhaseActive && ghostPhaseCharges > 0) {
        for (const obstacle of obstacles) {
            const distance = obstacle.position.distanceTo(player.position);
            if (distance < 3 && obstacle.position.z < player.position.z + 1) {
                activateGhostPhase();
                break;
            }
        }
        
        // Also check for water streams
        for (const stream of waterStreams) {
            const distance = stream.position.distanceTo(player.position);
            if (distance < 4 && stream.position.z < player.position.z + 2) {
                activateGhostPhase();
                break;
            }
        }
    }
    
    // Deactivate phase after duration
    if (ghostPhaseActive) {
        // Phase lasts 1 second (60 frames)
        if (frameCount % 60 === 0) {
            deactivateGhostPhase();
        }
    }
}
}

// Robot Shield Functions
function activateRobotShield() {
    robotShieldActive = true;
    robotShieldCooldown = 600; // 10 second cooldown
    
    console.log('🤖 Robot electromagnetic shield activated!');
    
    // Visual effect - create bright shield dome and brighten particles
    createRobotShieldDome();
    
    if (player.userData && player.userData.fieldParticles) {
        player.userData.fieldParticles.forEach(particle => {
            particle.material.opacity = 1.0; // Much brighter
            particle.material.color.setHex(0x00FFFF);
            particle.material.emissive.setHex(0x0088FF);
            particle.material.emissiveIntensity = 0.8;
        });
    }
}

function deactivateRobotShield() {
    robotShieldActive = false;
    console.log('🤖 Robot shield deactivated - cooldown: 10 seconds');
    
    // Remove shield dome
    if (player.userData.shieldDome) {
        player.remove(player.userData.shieldDome);
        player.userData.shieldDome = null;
    }
    
    // Visual effect - dim the field particles
    if (player.userData && player.userData.fieldParticles) {
        player.userData.fieldParticles.forEach(particle => {
            particle.material.opacity = 0.3;
            particle.material.color.setHex(0x00DDFF);
            particle.material.emissive.setHex(0x004466);
            particle.material.emissiveIntensity = 0.2;
        });
    }
}

// Create electromagnetic wireframe shield for robot
function createRobotShieldDome() {
    // Remove existing dome if any
    if (player.userData.shieldDome) {
        player.remove(player.userData.shieldDome);
    }
    
    // Create electromagnetic wireframe shield
    const shieldGeometry = new THREE.SphereGeometry(1.0, 12, 12); // Slightly higher detail for better wireframe
    const shieldMaterial = new THREE.MeshBasicMaterial({
        color: 0x00FFFF,        // Bright cyan
        emissive: 0x0088FF,     // Glowing blue
        emissiveIntensity: 0.5, // Electromagnetic glow
        transparent: true,
        opacity: 0.7,           // Semi-transparent
        wireframe: true,        // WIREFRAME MODE - looks electromagnetic!
        side: THREE.DoubleSide  // Visible from inside and outside
    });
    
    const shieldDome = new THREE.Mesh(shieldGeometry, shieldMaterial);
    player.add(shieldDome);
    player.userData.shieldDome = shieldDome;
    
    // Add subtle rotation for electromagnetic field effect
    shieldDome.userData.rotationSpeed = 0.01;
}

// Create simple shield flash effect (performance optimized)
function createShieldSparkEffect(position) {
    // Simple shield flash - just brighten the shield dome briefly
    if (player.userData.shieldDome) {
        // Flash effect by temporarily increasing opacity
        const dome = player.userData.shieldDome;
        dome.material.opacity = 0.8; // Bright flash
        
        // Return to normal opacity after a brief moment
        setTimeout(() => {
            if (dome.material) {
                dome.material.opacity = 0.3; // Back to normal
            }
        }, 100);
    }
    
    // Optional: Play a sound effect instead of visual particles
    // This gives feedback without performance cost
}

// Dragon Fire Functions
function activateDragonFire() {
    dragonFireActive = true;
    dragonFireCooldown = 480; // 8 second cooldown
    
    console.log('🐉 Dragon fire breath activated!');
    
    // Make fire particles visible and reset them properly
    if (player.userData && player.userData.fireParticles) {
        player.userData.fireParticles.forEach(particle => {
            particle.visible = true;
            particle.position.set(
                (Math.random() - 0.5) * 0.3,
                0.1 + Math.random() * 0.2,
                1.0
            );
            // Ensure proper opacity and scale
            if (particle.userData) {
                particle.material.opacity = particle.userData.originalOpacity;
            }
            particle.scale.setScalar(1.0);
        });
    }
}

function deactivateDragonFire() {
    dragonFireActive = false;
    console.log('🐉 Dragon fire breath deactivated - cooldown: 8 seconds');
    
    // Hide and reset fire particles aggressively
    if (player.userData && player.userData.fireParticles) {
        player.userData.fireParticles.forEach(particle => {
            particle.visible = false;
            // Reset particle position back to dragon's mouth area
            particle.position.set(
                (Math.random() - 0.5) * 0.3,
                0.1 + Math.random() * 0.2,
                particle.userData.baseZ || 0.8
            );
            // Reset opacity and scale
            particle.material.opacity = particle.userData.originalOpacity || 0.7;
            particle.scale.setScalar(1.0);
        });
    }
    
    // Additional cleanup - find any stray fire particles in the scene
    const fireParticlesToRemove = [];
    scene.traverse((object) => {
        if (object.material && 
            object.material.color && 
            (object.material.color.getHex() === 0xFF4500 || 
             object.material.color.getHex() === 0xFF6600 || 
             object.material.color.getHex() === 0xFF8800 || 
             object.material.color.getHex() === 0xFFAA00) &&
            object.geometry && 
            object.geometry.parameters && 
            object.geometry.parameters.radius === 0.04) {
            // This looks like a fire particle
            if (object.parent !== player) {
                fireParticlesToRemove.push(object);
            }
        }
    });
    
    // Remove any stray fire particles
    fireParticlesToRemove.forEach(particle => {
        if (particle.parent) {
            particle.parent.remove(particle);
        } else {
            scene.remove(particle);
        }
        console.log('🔥 Removed stray fire particle');
    });
}

function destroyObstaclesWithFire() {
    // Destroy obstacles in front of the dragon
    for (let i = obstacles.length - 1; i >= 0; i--) {
        const obstacle = obstacles[i];
        const distance = obstacle.position.distanceTo(player.position);
        
        // Check if obstacle is in fire range (in front of dragon)
        if (distance < 4 && obstacle.position.z > player.position.z - 1 && obstacle.position.z < player.position.z + 3) {
            // Create destruction effect
            createObstacleDestruction(obstacle.position);
            
            // Remove obstacle
            scene.remove(obstacle);
            obstacles.splice(i, 1);
            
            console.log('🔥 Obstacle destroyed by dragon fire!');
        }
    }
}

// Ghost Phase Functions
function activateGhostPhase() {
    ghostPhaseActive = true;
    ghostPhaseCharges--;
    
    // Start cooldown only if we're out of charges
    if (ghostPhaseCharges <= 0) {
        ghostPhaseCooldown = 300; // 5 seconds to restore first charge
    }
    
    console.log(`👻 Ghost phase activated! Charges remaining: ${ghostPhaseCharges}/3`);
}

function deactivateGhostPhase() {
    ghostPhaseActive = false;
    console.log('👻 Ghost phase deactivated');
    
    // Start charge restoration immediately if we have no charges left
    if (ghostPhaseCharges <= 0 && ghostPhaseCooldown <= 0) {
        ghostPhaseCooldown = 300; // 5 seconds to restore next charge
        console.log('👻 Starting charge restoration...');
    }
}
// Create destruction effect for dragon fire - using existing explosion system
function createObstacleDestruction(position) {
    // Use the existing createSparkle function which works properly
    createSparkle(position);
    
    // Optional: Add a simple flash effect instead of particles
    console.log('💥 Obstacle destroyed with sparkle effect!');
}

// Performance helper - only animate objects near player
function shouldAnimateObject(object, maxDistance = 15) {
    return object.position.distanceTo(player.position) < maxDistance;
}
        
        // ==================== GAME LOOP & UPDATES ====================
// Main game loop, animation, and real-time updates
// Dependencies: All game systems
// Functions: updateGame(), animate(), gameLoop(), update(), etc.

        // Game animation loop
        function animate() {
    requestAnimationFrame(animate);

    // For title and main menu, let particles run but skip game rendering
    if (gameState === "title" || gameState === "mainMenu") {
        // Particles are handled by their own animation loop
        // Just skip the game rendering
        return;
    }
    
    // For other menu states, skip everything
    if (gameState === "characterSelect" || gameState === "worldSelect" || 
        gameState === "shop" || gameState === "settings") {
        return;
    }

    // Enhanced frustum culling - only update visible objects
const frustum = new THREE.Frustum();
const cameraMatrix = new THREE.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
frustum.setFromProjectionMatrix(cameraMatrix);

// Helper function to check if object is in view
function isInCameraView(object) {
    return frustum.intersectsObject(object);
}
    
    // Update the frame counter for all animations
    frameCount++;

    // Ensure particles are running on main menu
if (gameState === "mainMenu" && !titleParticleSystem?.animationId) {
    const canvas = document.getElementById('particle-canvas');
    if (canvas) {
        canvas.style.display = 'block';
        canvas.style.visibility = 'visible';
        canvas.style.opacity = '1';
    }
    
    if (!titleParticleSystem) {
        createTitleParticles();
    } else {
        titleParticleSystem.animate();
    }
}

    // Staggered updates for performance - different systems update on different frames
    const updateSchedule = {
        weather: frameCount % 3 === 0,      // Update weather every 3rd frame
        butterflies: frameCount % 4 === 0,   // Update butterflies every 4th frame  
        scenery: frameCount % 2 === 0,       // Update scenery every 2nd frame
        particles: frameCount % 2 === 1      // Update particles on alternating frames
    };
    
    // Handle world select screen state
if (gameState === "worldSelect") {
    // Keep particles visible during world select
    const canvas = document.getElementById('particle-canvas');
    if (canvas) {
        canvas.style.display = 'block';
        canvas.style.visibility = 'visible';
        canvas.style.zIndex = '1'; // Behind world preview but visible
    }
    
    // Ensure particles keep animating
    if (!titleParticleSystem?.animationId) {
        if (!titleParticleSystem) {
            createTitleParticles();
        } else {
            titleParticleSystem.animate();
        }
    }
    
    // Don't render the main game scene
    return;
}

    // Handle character select screen state
if (gameState === "characterSelect") {
    // ENSURE PARTICLES ARE HIDDEN DURING CHARACTER SELECT
    const canvas = document.getElementById('particle-canvas');
    if (canvas) {
        canvas.style.display = 'none';
        canvas.style.visibility = 'hidden';
    }
    
    // Don't render the main game scene
    return;
}

// Handle world select screen state
if (gameState === "worldSelect") {
    // Keep particles visible during world select
    const canvas = document.getElementById('particle-canvas');
    if (canvas) {
        canvas.style.display = 'block';
        canvas.style.visibility = 'visible';
        canvas.style.zIndex = '1'; // Behind world preview but visible
    }
    
    // Ensure particles keep animating
    if (!titleParticleSystem?.animationId) {
        if (!titleParticleSystem) {
            createTitleParticles();
        } else {
            titleParticleSystem.animate();
        }
    }
    
    // Don't render the main game scene
    return;
}

// Handle main menu state - keep particles running
if (gameState === "mainMenu") {
    // Ensure particles stay visible
    ensureParticlesVisible();
    // The particles have their own animation loop, so we're good
    return;
}

    
    if (gameState === "playing" && !gameOver && !gamePaused) {
                // Update dynamic difficulty based on time
                updateDynamicDifficulty();
                
                // Update monster character's special animations if selected
if (currentCharacter === 'monster' && player.userData) {
    // Make the dark orb rotate (but don't override jump position)
    player.rotation.y += player.userData.rotateSpeed;
    
    // Only apply bobbing animation when NOT jumping
    if (!jumping) {
        player.position.y = playerY + Math.sin(frameCount * player.userData.bobSpeed) * 0.1;
    }
    
    // Animate the smoky particles
    if (player.children) {
        // Start from index 5 to skip the main body, eyes, mouth and teeth
        for (let i = 5; i < player.children.length; i++) {
            const particle = player.children[i];
            if (particle.userData && particle.userData.initialPosition) {
                // Update angle for orbital motion
                particle.userData.angle += particle.userData.rotationSpeed;
                
                // Orbit around the monster with some oscillation
                const orbitRadius = particle.userData.initialPosition.length() + 
                    Math.sin(frameCount * particle.userData.oscillationSpeed) * 
                    particle.userData.oscillationDistance;
                
                // Calculate new position based on original angle but varying distance
                const newX = orbitRadius * Math.sin(particle.userData.angle);
                const newY = particle.userData.initialPosition.y + 
                    Math.sin(frameCount * 0.1 + i) * 0.05;
                const newZ = orbitRadius * Math.cos(particle.userData.angle);
                
                particle.position.set(newX, newY, newZ);
            }
        }
    }
} 

else if (currentCharacter === 'atom') {
    // Batch atom animations - update every other frame for performance
    if (frameCount % 2 === 0) {
        // Update Atom character animations
        // Rotate all orbitals
        for (let i = 0; i < player.children.length; i++) {
            const child = player.children[i];
            
            // Orbit rotation for the atom's orbital rings
            if (i >= 2 && i <= 4) { // These are the orbital rings
                child.rotation.z += 0.02; // Slightly faster since updating every other frame
            }
            
            // Update electrons
            if (child.userData && child.userData.orbitalIndex !== undefined) {
                const electron = child;
                const orbitalIndex = electron.userData.orbitalIndex;
                const orbitalRadius = electron.userData.orbitalRadius;
                const speed = electron.userData.speed * 2; // Double speed since updating every other frame
                
                // Update electron angle
                electron.userData.angle += speed;
                
                // Position based on orbital orientation
                if (orbitalIndex === 0) {
                    electron.position.x = Math.cos(electron.userData.angle) * orbitalRadius;
                    electron.position.z = Math.sin(electron.userData.angle) * orbitalRadius;
                } else if (orbitalIndex === 1) {
                    electron.position.y = Math.cos(electron.userData.angle) * orbitalRadius;
                    electron.position.z = Math.sin(electron.userData.angle) * orbitalRadius;
                } else {
                    electron.position.x = Math.cos(electron.userData.angle) * orbitalRadius * 0.7;
                    electron.position.y = Math.cos(electron.userData.angle) * orbitalRadius * 0.7;
                    electron.position.z = Math.sin(electron.userData.angle) * orbitalRadius;
                }
            }
            
            // Pulse nucleus sparkles
            if (i === 0) { // Nucleus
                // Update sparkles inside the nucleus
                if (child.children) {
                    child.children.forEach(sparkle => {
                        if (sparkle.userData) {
                            // Pulse size of sparkle
                            const pulseScale = 0.8 + Math.sin(frameCount * sparkle.userData.pulseSpeed + sparkle.userData.pulsePhase) * 0.3;
                            sparkle.scale.set(pulseScale, pulseScale, pulseScale);
                        }
                    });
                }
            }
            
            // Pulse the glow
            if (i === 1) { // Glow sphere
                // Pulse size and opacity
                const pulseScale = 1.0 + Math.sin(frameCount * 0.05) * 0.1;
                child.scale.set(pulseScale, pulseScale, pulseScale);
                child.material.opacity = 0.3 + Math.sin(frameCount * 0.08) * 0.15;
            }
        }
        
        // Add gentle rotation if not jumping
        if (!jumping) {
            player.rotation.y += 0.04; // Double speed since updating every other frame
        }
    }
} else if (currentCharacter === 'ufo' && player.userData) {
    // Rotate the outer ring
    if (player.userData.ring) {
        player.userData.ring.rotation.y += 0.03;
    }
    
    // Pulse the lights
    if (player.userData.lights) {
        player.userData.lights.children.forEach((light, index) => {
            if (light.userData) {
                const pulse = Math.sin(frameCount * light.userData.pulseSpeed + light.userData.pulsePhase);
                light.material.emissiveIntensity = light.userData.originalIntensity + pulse * 0.5;
                
                // Occasional color flash
                if (Math.random() < 0.01) {
                    light.material.color.setHex(0xFFFFFF);
                    light.material.emissive.setHex(0xFFFFFF);
                    setTimeout(() => {
                        light.material.color.setHex(light.userData.originalColor);
                        light.material.emissive.setHex(light.userData.originalColor);
                    }, 100);
                }
            }
        });
    }
    
    // Pulse the dome
    if (player.userData.dome) {
        const domePulse = Math.sin(frameCount * 0.03) * 0.2 + 0.5;
        player.userData.dome.material.emissiveIntensity = domePulse;
    }
    
    // Animate tractor beam
    if (player.userData.beam) {
        const beamPulse = Math.sin(frameCount * 0.05) * 0.1 + 0.2;
        player.userData.beam.material.opacity = beamPulse;
        player.userData.beam.rotation.y += 0.02;
    }
    
    // Float energy particles
    if (player.userData.particles) {
        player.userData.particles.forEach(particle => {
            if (particle.userData) {
                // Orbit motion
                particle.userData.orbitAngle += particle.userData.orbitSpeed;
                const x = Math.cos(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                const z = Math.sin(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                
                // Floating motion
                const floatY = Math.sin(frameCount * particle.userData.floatSpeed + particle.userData.floatOffset) * 0.3;
                
                particle.position.set(x, floatY, z);
                
                // Particle glow pulse
                const glowPulse = Math.sin(frameCount * 0.08 + particle.userData.floatOffset) * 0.3 + 0.7;
                particle.material.opacity = glowPulse;
            }
        });
    }
    
    // Gentle hovering motion when not jumping
    if (!jumping) {
        player.position.y = playerY + Math.sin(frameCount * 0.04) * 0.08;
    }
} else if (currentCharacter === 'dragon' && player.userData) {
    // Animate dragon wings during gameplay
    if (player.userData.wings) {
        const wingFlap = Math.sin(frameCount * 0.15) * 0.3;
        player.userData.wings[0].rotation.z = Math.PI / 3 + wingFlap; // Left wing
        player.userData.wings[1].rotation.z = -Math.PI / 3 - wingFlap; // Right wing
    }
    
    // Animate fire particles when fire breath is active
    if (player.userData.fireParticles) {
        player.userData.fireParticles.forEach((particle, index) => {
            if (dragonFireActive) {
                // Show particle and animate it
                particle.visible = true;
                
                // Keep particles close to dragon mouth with flickering
                const flicker = Math.sin(frameCount * 0.2 + index) * 0.3 + 0.7;
                particle.material.opacity = particle.userData.originalOpacity * flicker;
                particle.scale.setScalar(0.8 + flicker * 0.4);
            } else {
                // Fire is not active - hide particle
                particle.visible = false;
            }
        });
    }
} else if (currentCharacter === 'robot') {
    // Robot running animation - only during gameplay
    if (gameStarted && !gameOver && !gamePaused) {
        // Running body bob - up and down motion
        if (!jumping) {
            const runBob = Math.sin(frameCount * 0.3) * 0.08; // Faster, smaller bob
            player.position.y = playerY + runBob;
        }
        
        // Animate robot arms for running motion
        if (player.children.length >= 6) { // Make sure arms exist
            const leftArm = player.children[4];  // Left arm
            const rightArm = player.children[5]; // Right arm
            
            if (leftArm && rightArm) {
                // Alternating arm swing - opposite arms move opposite directions
                const armSwing = Math.sin(frameCount * 0.3) * 0.4; // Running pace
                
                leftArm.rotation.x = armSwing;        // Left arm forward/back
                rightArm.rotation.x = -armSwing;      // Right arm opposite direction
                
                // Add slight side-to-side motion for more natural running
                leftArm.rotation.z = Math.sin(frameCount * 0.15) * 0.1;
                rightArm.rotation.z = -Math.sin(frameCount * 0.15) * 0.1;
            }
        }
        
        // Slight forward lean while running
        if (!jumping) {
            player.rotation.x = Math.sin(frameCount * 0.3) * 0.05; // Subtle forward/back lean
        }
        
        // Add slight head bob for realism
        if (player.children.length >= 2) {
            const head = player.children[1]; // Head
            if (head) {
                head.rotation.x = Math.sin(frameCount * 0.3 + Math.PI/4) * 0.08; // Slight head bob
            }
        }

// Animate robot legs for running motion
        if (player.children.length >= 8) { // Make sure legs exist
            const leftLeg = player.children[6];  // Left leg
            const rightLeg = player.children[7]; // Right leg
            
            if (leftLeg && rightLeg) {
                // Create the same armSwing calculation for legs
                const armSwing = Math.sin(frameCount * 0.3) * 0.4; // Same as arms
                
                // Forward/back leg swing (opposite to arms for natural running)
                leftLeg.rotation.x = -armSwing * 0.8;   // Left leg opposite to left arm
                rightLeg.rotation.x = armSwing * 0.8;   // Right leg opposite to right arm
                
                // Slight up/down leg movement for realistic stride
                const legLift = Math.abs(Math.sin(frameCount * 0.3)) * 0.05;
                leftLeg.position.y = -0.5 + (armSwing > 0 ? legLift : 0);  // Lift when swinging forward
                rightLeg.position.y = -0.5 + (-armSwing > 0 ? legLift : 0); // Lift when swinging forward
                
                // Add slight side-to-side leg motion for natural gait
                leftLeg.rotation.z = Math.sin(frameCount * 0.15) * 0.05;
                rightLeg.rotation.z = -Math.sin(frameCount * 0.15) * 0.05;
            }
        }

    }
} else if (!jumping && currentCharacter !== 'dragon' && currentCharacter !== 'ghost') {
    // Standard rotation for other characters when not jumping (except robot, dragon, and ghost)
    player.rotation.y += 0.02;
}

// Handle character-specific abilities
handleCharacterAbilities();
                
                // Move player to target lane
                const targetX = lanes[currentLane];
                
                // Adjust movement speed for carrot character (faster lane changes)
                const moveSpeed = currentCharacter === 'carrot' ? 0.15 : 0.1;
                player.position.x += (targetX - player.position.x) * moveSpeed;
                
                // Handle jumping with front flip animation
                if (jumping) {
                    // Apply jump speed with a moderate peak slowdown effect
                    let jumpFactor = 1.0;
                    
                    // Apply a mild slowdown effect near the peak of the jump
                    if (jumpDirection === -1) {
                        // Only slow down during the fall, and only near the top
                        const heightProgress = (player.position.y - playerY) / jumpHeight;
                        if (heightProgress > 0.7) {
                            // Apply more slowdown near the very top (max 40% slowdown)
                            jumpFactor = 0.6 + (0.4 * (1.0 - heightProgress));
                        }
                    }
                    
                    // Apply the adjusted jump speed
                    player.position.y += jumpSpeed * jumpDirection * jumpFactor;
                    
                    // Add front flip animation (but not for UFO or Dragon)
if (currentCharacter !== 'ufo' && currentCharacter !== 'dragon') {
    if (jumpDirection === 1) {
        // Going up - first half of the jump
        jumpRotation += 0.09; // Slightly slower rotation
        // Complete a full rotation (2*PI) over the jump duration
        player.rotation.x = jumpRotation;
    } else {
        // Going down - second half of the jump
        jumpRotation += 0.09; // Slightly slower rotation
        player.rotation.x = jumpRotation;
    }
}
                    
                    // Change direction at peak
                    if (player.position.y >= playerY + jumpHeight) {
                        jumpDirection = -1;
                    }
                    
                    // End jump when back on ground
if (jumpDirection === -1 && player.position.y <= playerY) {
    player.position.y = playerY;
    if (currentCharacter !== 'ufo' && currentCharacter !== 'dragon') {
        player.rotation.x = 0; // Reset rotation (but not for UFO or Dragon)
    }
    jumping = false;
                        
                        // Reset jump speed to normal in case it was modified by quickDrop
if (currentCharacter === 'pumpkin') {
    jumpSpeed = 0.08;
} else {
    jumpSpeed = 0.065;
}
                    }
                }


                
                // Update power-up timers
                if (shieldActive) {
                    powerUpTimers.shield--;
                    if (powerUpTimers.shield <= 0) {
                        shieldActive = false;
                        if (player.userData.shieldEffect) {
                            player.remove(player.userData.shieldEffect);
                            player.userData.shieldEffect = null;
                        }
                        console.log('Shield deactivated!');
                    }
                }

                if (coinMultiplierActive) {
                    powerUpTimers.coinMultiplier--;
                    if (powerUpTimers.coinMultiplier <= 0) {
                        coinMultiplierActive = false;
                        console.log('Coin multiplier deactivated!');
                    }
                }

                if (magnetActive) {
                    powerUpTimers.magnet--;
                    if (powerUpTimers.magnet <= 0) {
                        magnetActive = false;
                        console.log('Magnet deactivated!');
                    }
                }

// Update the status bars
updatePowerUpStatusBar();
updateAbilityStatusBar();
                
                // Staggered updates for better performance
                if (updateSchedule.weather) updateWeather();
                if (updateSchedule.butterflies) updateButterfliesAndBirds();
                
                // Update water streams
                updateWaterStreams();
                
                // Move ground segments with current speed
groundSegments.forEach(segment => {
    segment.position.z += currentSpeed;
    if (segment.position.z > 55) {
        // Move it to the back
        segment.position.z = -45 * groundSegments.length / 2;
    }
});

// Move side terrain segments with current speed - perfectly synced with ground segments
for (let i = 0; i < groundSegments.length; i++) {
    const groundSegment = groundSegments[i];
    
    // Each ground segment has 4 corresponding side terrain pieces
    const startIndex = i * 4;
    const endIndex = startIndex + 4;
    
    // Sync the 4 side terrain pieces with this ground segment
    for (let j = startIndex; j < endIndex && j < sideTerrainSegments.length; j++) {
        const sideTerrain = sideTerrainSegments[j];
        sideTerrain.position.z = groundSegment.position.z; // Exact sync
    }
}
                
                // Track distance for score
                distanceTraveled += currentSpeed;
                if (Math.floor(distanceTraveled) % 10 === 0) {
                    score++;
                    updateScore();
                }

                // Clean collision cache periodically for performance
if (frameCount % 300 === 0) { // Every 5 seconds
    cleanupCollisionCache(obstacles, 'obstacle');
    cleanupCollisionCache(coins, 'coin');
    cleanupCollisionCache(powerUps, 'powerup');
}
                
                // Spawn obstacles using dynamic spawn rate
                if (frameCount % currentObstacleSpawnRate === 0) {
                    spawnObstacle();
                }

                // Spawn meteors only at Maximum Chaos level (speed level 4+)
if (currentSpeedLevel >= 4) {
    meteorSpawnCounter++;
    
    if (meteorSpawnCounter >= meteorSpawnRate) {
    console.log("METEOR SPAWNING NOW!");
    createMeteor();
    meteorSpawnCounter = 0;
    // Randomize next meteor spawn time (slower)
    meteorSpawnRate = 400 + Math.floor(Math.random() * 400); // 400-800 frames (13-27 seconds)
    console.log(`Next meteor in ${meteorSpawnRate} frames`);
}
    
    // Only log every 30 frames to reduce spam
    if (meteorSpawnCounter % 30 === 0) {
        console.log(`Meteor spawn check - Level: ${currentSpeedLevel}, Counter: ${meteorSpawnCounter}, Rate: ${meteorSpawnRate}`);
    }
}
                
                // Track stream spawning
                streamSpawnCounter++;
                streamCreated = false;
                
                // Spawn streams using dynamic spawn rate (much less frequent)
                if (frameCount % currentStreamSpawnRate === 0) {
                    spawnWaterStream();
                }
                
                // Spawn coins
if (frameCount % coinSpawnRate === 0) {
    // 2% chance of spawning rare coin instead of regular coin //RARECOIN
    if (Math.random() < 0.0075) {
        spawnRareCoin();
    } else {
        spawnCoin();
    }
}

// Spawn power-ups with collision avoidance
if (frameCount % powerUpSpawnRate === 0) {
    // Get available lanes (avoid lanes with recent power-ups)
    const availableLanes = [];
    for (let i = 0; i < 3; i++) {
        let laneBlocked = false;
        // Check if any power-up is in this lane and still close
        for (const powerUp of powerUps) {
            if (Math.abs(powerUp.position.x - lanes[i]) < 0.5 && powerUp.position.z > -20) {
                laneBlocked = true;
                break;
            }
        }
        if (!laneBlocked) {
            availableLanes.push(i);
        }
    }
    
    // Only spawn if we have available lanes
    if (availableLanes.length > 0) {
        const powerUpType = Math.random();
        console.log("Spawning power-up at frame:", frameCount, "Available lanes:", availableLanes);
        
        if (powerUpType < 0.33) {
            spawnShieldPowerUpInLane(availableLanes);
            console.log("Shield power-up spawned");
        } else if (powerUpType < 0.66) {
            spawnCoinMultiplierPowerUpInLane(availableLanes);
            console.log("Coin multiplier power-up spawned");
        } else {
            spawnMagnetPowerUpInLane(availableLanes);
            console.log("Magnet power-up spawned");
        }
    } else {
        console.log("No available lanes for power-up spawn");
    }
}


                
                // Spawn scenery objects (stays constant)
                if (frameCount % scenerySpawnRate === 0) {
                    spawnScenery();
                }
                
                // Move and animate coins with current speed
for (let i = coins.length - 1; i >= 0; i--) {
    const coin = coins[i];
    coin.position.z += currentSpeed;
    
    // Rotate coin for visual appeal
    coin.rotation.y += 0.05;
    
    // Highlight removed - no longer needed
    
    // Animate sparkles only for nearby coins (performance optimization)
if (coin.userData.sparkles && coin.position.distanceTo(player.position) < 10) {
    coin.userData.sparkles.forEach(sparkle => {
        // Orbit around the coin
        sparkle.userData.orbitAngle += sparkle.userData.orbitSpeed;
        sparkle.position.x = Math.cos(sparkle.userData.orbitAngle) * sparkle.userData.orbitRadius;
        sparkle.position.z = Math.sin(sparkle.userData.orbitAngle) * sparkle.userData.orbitRadius;
        
        // Pulse the sparkle size and opacity
        const pulseScale = 0.5 + Math.sin(frameCount * sparkle.userData.pulseSpeed + sparkle.userData.pulsePhase) * 0.5;
        sparkle.scale.set(pulseScale, pulseScale, pulseScale);
        sparkle.material.opacity = 0.6 + Math.sin(frameCount * sparkle.userData.pulseSpeed * 1.5 + sparkle.userData.pulsePhase) * 0.4;
    });
}
                    
                    // Magnet effect - attract coins to player
if (magnetActive) {
    const distance = coin.position.distanceTo(player.position);
    if (distance < 5) { // Magnet range
        const direction = new THREE.Vector3().subVectors(player.position, coin.position).normalize();
        coin.position.add(direction.multiplyScalar(0.2)); // Pull towards player
    }
}

// Check if collected - only if coin is actually near player
const coinDistance = coin.position.distanceTo(player.position);
if (coinDistance < 1.5 && checkCollision(coin)) {
    // Coin collected!
    playCoinSound();
    createSparkle(coin.position.clone());
    scene.remove(coin);
    coins.splice(i, 1);
    
    // Apply coin multiplier to both score and coin balance
    const coinValue = coinMultiplierActive ? 20 : 10; // 2x when multiplier active
    const actualCoins = coinMultiplierActive ? 2 : 1; // 2x coins when multiplier active
    
    score += coinValue;
    totalCoins += actualCoins; // Add coins to balance immediately
    coinsCollectedThisRun += actualCoins; // Track for daily challenges
    
    updateScore();
    updateTotalCoins(); // Update coin display immediately
    

    
    if (coinMultiplierActive) {
        console.log('Coin collected with 2x multiplier!');
    }
}
                    
                    // Remove coins that have passed the player
                    else if (coin.position.z > 5) {
                        scene.remove(coin);
                        coins.splice(i, 1);
                    }
                }

// Move and animate rare coins
                for (let i = rareCoins.length - 1; i >= 0; i--) {
                    const rareCoin = rareCoins[i];
                    rareCoin.position.z += playerSpeed; // Use the existing playerSpeed variable
                    
                    // Rotate rare coin faster for visual appeal
                    rareCoin.rotation.y += rareCoin.userData.rotationSpeed;
                    
                    // Animate sparkles around the rare coin
                    if (rareCoin.userData.sparkles) {
                        rareCoin.userData.sparkles.forEach(sparkle => {
                            // Orbit around the coin
                            sparkle.userData.orbitAngle += sparkle.userData.orbitSpeed;
                            sparkle.position.x = Math.cos(sparkle.userData.orbitAngle) * sparkle.userData.orbitRadius;
                            sparkle.position.z = Math.sin(sparkle.userData.orbitAngle) * sparkle.userData.orbitRadius;
                            
                            // Pulse the sparkle
                            const pulseScale = 0.5 + Math.sin(frameCount * sparkle.userData.pulseSpeed + sparkle.userData.pulsePhase) * 0.5;
                            sparkle.scale.set(pulseScale, pulseScale, pulseScale);
                            sparkle.material.opacity = 0.6 + Math.sin(frameCount * sparkle.userData.pulseSpeed * 1.5 + sparkle.userData.pulsePhase) * 0.4;
                        });
                    }
                    
                    // Magnet effect for rare coins too
if (magnetActive) {
    const distance = rareCoin.position.distanceTo(player.position);
    if (distance < 5) { // Magnet range
        const direction = new THREE.Vector3().subVectors(player.position, rareCoin.position).normalize();
        rareCoin.position.add(direction.multiplyScalar(0.2)); // Pull towards player
    }
}

// Check if collected
if (checkCollision(rareCoin)) {
    // Rare coin collected! Big reward!
    playRareCoinSound(); // Add this line
    createSparkle(rareCoin.position.clone());
    scene.remove(rareCoin);
    rareCoins.splice(i, 1);
    
    // Apply multiplier to rare coins too
    const rareScoreBonus = coinMultiplierActive ? 200 : 100;
    const rareCoinBonus = coinMultiplierActive ? 200 : 100;
    
    score += rareScoreBonus;
    totalCoins += rareCoinBonus;
    updateScore();
    updateTotalCoins();
    // Track coins for daily challenges (count actual coins earned, not just 1)
    coinsCollectedThisRun += rareCoinBonus;
    
    
    console.log(`RARE COIN COLLECTED! +${rareCoinBonus} coins!`);
    if (coinMultiplierActive) {
        console.log('Rare coin got 2x multiplier bonus!');
    }
}
                    
                    // Remove rare coins that have passed the player
                    else if (rareCoin.position.z > 5) {
                        scene.remove(rareCoin);
                        rareCoins.splice(i, 1);
                    }
                }

                // Move and animate power-ups
                for (let i = powerUps.length - 1; i >= 0; i--) {
                    const powerUp = powerUps[i];
                    
                    
                    
                    powerUp.position.z += currentSpeed; // Use same speed as other objects
                    
                    // Rotate power-up for visual appeal
                    powerUp.rotation.y += 0.03;
                    
                    // Animate specific power-up effects
                    if (powerUp.userData.type === 'shield' && powerUp.userData.particles) {
                        // Animate shield particles
                        powerUp.userData.particles.forEach(particle => {
                            particle.userData.orbitAngle += particle.userData.orbitSpeed;
                            particle.position.x = Math.cos(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                            particle.position.y = Math.sin(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                        });
                    } else if (powerUp.userData.type === 'magnet' && powerUp.userData.fieldParticles) {
                        // Animate magnet field particles
                        powerUp.userData.fieldParticles.forEach(particle => {
                            particle.userData.orbitAngle += particle.userData.orbitSpeed;
                            particle.position.x = Math.cos(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                            particle.position.y = Math.sin(particle.userData.orbitAngle) * particle.userData.orbitRadius;
                        });
                    }
                    
                    // Check for collision with player using simple distance
const distance = powerUp.position.distanceTo(player.position);

if (distance < 1.5) { // Simple distance-based collision
    activatePowerUp(powerUp.userData.type);
    scene.remove(powerUp);
    powerUps.splice(i, 1);
    powerupsCollectedThisRun++; // Track for daily challenges
    
}
                    
                    // Remove power-ups that have passed the player
                    else if (powerUp.position.z > 5) {
                        console.log(`Removing power-up ${powerUp.userData.type} that passed player`);
                        scene.remove(powerUp);
                        powerUps.splice(i, 1);
                    }
                }
                
                // Move obstacles with current speed
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    const obstacle = obstacles[i];
                    obstacle.position.z += currentSpeed;
                    
// Check for collision
if (checkCollision(obstacle)) {
    // Collision detected
    
    if (shieldActive) {
        // Shield protects - remove obstacle instead
        scene.remove(obstacle);
        obstacles.splice(i, 1);
        console.log('Shield blocked collision!');
    } else {
        endGame();
    }
}
                    
                    // Remove obstacles that have passed the player
                    if (obstacle.position.z > 5) {
                        scene.remove(obstacle);
                        obstacles.splice(i, 1);
                    }
                }
                
                // Move scenery objects with current speed - only animate nearby objects
for (let i = sceneryObjects.length - 1; i >= 0; i--) {
    const scenery = sceneryObjects[i];
    scenery.position.z += currentSpeed;
    
    // Only run complex animations for nearby scenery
    if (!shouldAnimateObject(scenery, 20)) {
        // Skip animations for distant objects
        if (scenery.position.z > 20) {
            scene.remove(scenery);
            sceneryObjects.splice(i, 1);
        }
        continue;
    }
    
    // Animate forest-specific scenery
    if (currentWorld === 'forest') {
        scenery.children.forEach(child => {
            // Animate ferns swaying
            if (child.userData && child.userData.swaySpeed) {
                child.rotation.z = Math.sin(frameCount * child.userData.swaySpeed + child.userData.swayOffset) * child.userData.swayAmount;
            }
            
            // Animate fireflies floating
            if (child.userData && child.userData.floatSpeed) {
                child.userData.floatAngle += child.userData.floatSpeed;
                const floatX = Math.cos(child.userData.floatAngle) * child.userData.floatRadius;
                const floatY = Math.sin(child.userData.floatAngle * 0.7) * child.userData.floatRadius * 0.5;
                
                child.position.x = child.userData.basePosition.x + floatX;
                child.position.y = child.userData.basePosition.y + floatY;
                
                // Pulse brightness
                const pulse = Math.sin(frameCount * child.userData.pulseSpeed + child.userData.pulsePhase) * 0.5 + 0.5;
                child.material.opacity = 0.4 + pulse * 0.6;
            }
            
            // Animate magical orbs around ancient oaks
            if (child.userData && child.userData.orbitSpeed) {
                child.userData.orbitAngle += child.userData.orbitSpeed;
                child.position.x = Math.cos(child.userData.orbitAngle) * child.userData.orbitRadius;
                child.position.z = Math.sin(child.userData.orbitAngle) * child.userData.orbitRadius;
                
                // Gentle floating motion
                const float = Math.sin(frameCount * child.userData.pulseSpeed) * 0.3;
                child.position.y = child.userData.baseHeight + float;
                
                // Pulse the magical orbs
                const orbPulse = Math.sin(frameCount * child.userData.pulseSpeed) * 0.4 + 0.6;
                child.material.opacity = orbPulse;
                child.scale.setScalar(0.8 + orbPulse * 0.4);
            }
        });
    }
    
    // Remove scenery that has passed the player
    if (scenery.position.z > 20) {
        scene.remove(scenery);
        sceneryObjects.splice(i, 1);
    }
}

// Update meteors
for (let i = meteors.length - 1; i >= 0; i--) {
    const meteor = meteors[i];
    
    
    
    // Move meteor down and sync with player's movement
meteor.position.y -= meteor.userData.fallSpeed;
// Move at exactly the same speed as the game world so it crashes right where player is
meteor.position.z += currentSpeed; // Same speed as scene - will hit player's position

// Keep meteor aligned to its target lane (no drift)
meteor.position.x = lanes[meteor.userData.targetLane];
    
    // Rotate meteor
    meteor.rotation.x += meteor.userData.rotationSpeed;
    meteor.rotation.y += meteor.userData.rotationSpeed * 0.7;
    meteor.rotation.z += meteor.userData.rotationSpeed * 0.5;
    
    // Animate floating chunks
    if (meteor.userData.chunks) {
        meteor.userData.chunks.forEach(chunk => {
            chunk.userData.orbitAngle += chunk.userData.orbitSpeed;
            const newX = Math.cos(chunk.userData.orbitAngle) * chunk.userData.orbitRadius;
            const newZ = Math.sin(chunk.userData.orbitAngle) * chunk.userData.orbitRadius;
            chunk.position.x = newX;
            chunk.position.z = newZ;
        });
    }
    
    // Animate fire trail
    if (meteor.userData.trailParticles) {
        meteor.userData.trailParticles.forEach(particle => {
            const flicker = Math.sin(frameCount * particle.userData.flickerSpeed) * 0.3 + 0.7;
            particle.material.opacity = particle.userData.originalOpacity * flicker;
            particle.scale.setScalar(0.8 + flicker * 0.4);
        });
    }
    
    // Check for collision with player (only if meteor is at ground level and same lane)
const meteorLane = meteor.userData.targetLane;
const playerLane = currentLane;

if (meteorLane === playerLane && meteor.position.y <= 1.0 && checkCollision(meteor)) {
    endGame();
}
    
    // Remove meteor if it hits the ground or goes too far ahead
if (meteor.position.y < -1 || meteor.position.z > player.position.z + 15) {
    // Create impact effect when hitting ground
    if (meteor.position.y < -1) {
        createMeteorImpact(meteor.position);
    }
    
    scene.remove(meteor);
    meteors.splice(i, 1);
}
}
                
                // Update sparkle animations
                updateSparkles();
// Update background music intensity
                updateBackgroundMusic();


            } else if (gameOver) {
                // Update explosion animation if game is over
                updateExplosion();
                // Continue updating sparkles even in game over state
                updateSparkles();
                // Continue updating weather in game over state
                updateWeather();
                updateButterfliesAndBirds();
            }
            

            // Only render the main game scene if we're actually playing
    if (gameState === "playing" || gameState === "paused" || gameState === "gameOver") {
        renderer.render(scene, camera);
    }

    }
        
        // Only render the main game scene if we're in a game state
        if (gameState === "playing" || gameState === "gameOver") {
            renderer.render(scene, camera);
        
        }
        
        // Initialize on load
        document.addEventListener('DOMContentLoaded', init);

        // Add this right after your DOMContentLoaded or where your game initializes
// Make sure this runs AFTER the DOM is loaded
window.addEventListener('load', function() {
    console.log('🎮 Initializing game systems...');
    
    // Initialize daily challenges
    if (!dailyChallenges) {
        console.log('📋 Creating daily challenges system...');
        initializeDailyChallenges();
        
        // Force display update after a short delay
        setTimeout(() => {
            if (dailyChallenges) {
                dailyChallenges.updateChallengeDisplay();
                updateChallengeButton();
            }
        }, 100);
    }
});



        // ==================== AUTOMATIC SAVE SYSTEM ====================
// Save game data when page closes or periodically

// Save every 30 seconds during gameplay
let autoSaveInterval;

function startAutoSave() {
    if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
    }
    
    autoSaveInterval = setInterval(() => {
        if (gameState === "playing" && !gamePaused) {
            console.log('🔄 Auto-saving game progress...');
            saveGameData();
        }
    }, 30000); // Every 30 seconds
}

function stopAutoSave() {
    if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
        autoSaveInterval = null;
    }
}

// Save when page is about to close
window.addEventListener('beforeunload', function(event) {
    console.log('💾 Saving game data before page closes...');
    saveGameData();
});

// Save when page becomes hidden (mobile/tab switching)
document.addEventListener('visibilitychange', function() {
    if (document.hidden) {
        console.log('💾 Saving game data (page hidden)...');
        saveGameData();
    }
});

// Save when window loses focus
window.addEventListener('blur', function() {
    console.log('💾 Saving game data (window lost focus)...');
    saveGameData();
});

// Start auto-save when game starts
startAutoSave();

// ==================== MAIN MENU NAVIGATION ====================
// Navigation functions for the new main menu system

function showMainMenu() {
    console.log('🎮 Transitioning to main menu...');
    
    // Update game state FIRST
    gameState = "mainMenu";
    
    // Hide title screen
    document.getElementById('titleScreen').style.display = 'none';
    document.getElementById('titleScreen').classList.remove('active');
    
    // Hide 3D renderer
    if (renderer && renderer.domElement) {
        renderer.domElement.style.display = 'none';
    }
    
    // Show main menu
    document.getElementById('main-menu').style.display = 'flex';
    document.getElementById('main-menu').classList.add('active');

    
    
    // Move particle canvas inside main menu for proper layering
    let canvas = document.getElementById('particle-canvas');
    const mainMenu = document.getElementById('main-menu');
    
    if (canvas && mainMenu) {
        // Move canvas to be first child of main menu
        if (canvas.parentElement !== mainMenu) {
            mainMenu.insertBefore(canvas, mainMenu.firstChild);
        }
        
        // Update canvas styling for being inside main menu
        canvas.style.cssText = `
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            pointer-events: none !important;
            z-index: 0 !important;
            display: block !important;
            opacity: 1 !important;
            visibility: visible !important;
        `;
    }
    
    // Force canvas to be visible with proper styling
    canvas.style.cssText = `
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
        pointer-events: none !important;
        z-index: 1 !important;
        display: block !important;
        opacity: 1 !important;
        visibility: visible !important;
    `;
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Create or restart particle system
    if (!titleParticleSystem) {
        titleParticleSystem = new TitleParticleSystem();
        titleParticleSystem.init();
    } else if (!titleParticleSystem.animationId) {
        titleParticleSystem.animate();
    } else {
    }
    
    // Update coin display
    updateTotalCoins();
    
    // Debug check
    setTimeout(() => {
        debugParticles();
    }, 100);
    
    console.log('✅ Main menu active');
}

// Force particle system update when switching to main menu
function forceParticleResize() {
    const canvas = document.getElementById('particle-canvas');
    if (canvas && titleParticleSystem) {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Recreate particles for the new canvas size
        if (titleParticleSystem.createParticles) {
            titleParticleSystem.createParticles();
        }
        
    }
}

// Navigation from main menu to other screens
function showCharacterSelectFromMenu() {
    console.log('👤 Transitioning to character select...');
    
    // NUCLEAR PARTICLE CLEANUP
    nuclearParticleCleanup();
    
    // Hide main menu first
    document.getElementById('main-menu').style.display = 'none';
    document.getElementById('main-menu').classList.remove('active');
    
    // Make sure the main renderer stays hidden during character select
    if (renderer && renderer.domElement) {
        renderer.domElement.style.display = 'none';
    }
    
    // Show character select screen
    document.getElementById('characterSelectScreen').style.display = 'flex';
    
    // Small delay for smooth transition
    setTimeout(() => {
        document.getElementById('characterSelectScreen').classList.add('active');
        
        gameState = "characterSelect";
        
        // Set selected index to the current character
        selectedCharacterIndex = characterNames.indexOf(currentCharacter);
        if (selectedCharacterIndex === -1) selectedCharacterIndex = 0;
        
        // Reinitialize character select screen
        initCharacterSelectScreen();
    }, 50);
}

function showWorldSelectFromMenu() {
    console.log('🌍 Transitioning to world select...');
    
    // Keep particles visible during world select
const canvas = document.getElementById('particle-canvas');
if (canvas) {
    canvas.style.display = 'block';
    canvas.style.zIndex = '0'; // Behind world preview
}
    
    // Hide main menu first
    document.getElementById('main-menu').style.display = 'none';
    document.getElementById('main-menu').classList.remove('active');
    
    // Make sure the main renderer stays hidden during world select
    if (renderer && renderer.domElement) {
        renderer.domElement.style.display = 'none';
    }
    
    // Show world select screen
    document.getElementById('worldSelectScreen').style.display = 'flex';
    
    // Small delay for smooth transition
    setTimeout(() => {
        document.getElementById('worldSelectScreen').classList.add('active');
        
        gameState = "worldSelect";
        
        // Reset the selected world index to current world
        selectedWorldIndex = availableWorlds.findIndex(w => w.id === currentWorld);
        if (selectedWorldIndex === -1 || (!unlockedWorlds[availableWorlds[selectedWorldIndex].id] && !modModeEnabled)) {
            // Find first unlocked world
            selectedWorldIndex = availableWorlds.findIndex(w => unlockedWorlds[w.id] || modModeEnabled);
            if (selectedWorldIndex === -1) selectedWorldIndex = 0;
        }
        
        // Initialize world select screen
        initWorldSelectScreen();
    }, 50);
}

function showShopFromMenu() {
    document.getElementById('main-menu').style.display = 'none';
    
    // Ensure particles are visible and animating for shop
    const canvas = document.getElementById('particle-canvas');
    if (canvas) {
        canvas.style.display = 'block';
        ensureParticlesVisible();
    }
    
    // Make sure particle system is running
    if (!titleParticleSystem) {
        createTitleParticles();
    } else if (!titleParticleSystem.animationId) {
        titleParticleSystem.animate();
    }
    
    document.getElementById('shopScreen').style.display = 'flex';
    gameState = "shop";
    
    // Initialize shop display
    initializeShopScreen();

    console.log('🛍️ Shop shown');
setTimeout(() => debugParticleState(), 100);
}

function showSettingsFromMenu() {
    document.getElementById('main-menu').style.display = 'none';
    document.getElementById('settingsScreen').style.display = 'flex';
    document.getElementById('modalOverlay').style.display = 'block';
    gameState = "settings";
    initMainMenuSettings();

    console.log('⚙️ Settings shown');
setTimeout(() => debugParticleState(), 100);
}

// Initialize main menu settings when shown
function initMainMenuSettings() {
    
    // Update mod mode button state
    const modButton = document.getElementById('mainMenuModButton');
    const difficultyOption = document.getElementById('mainMenuDifficultyOption');
    const passwordField = document.getElementById('mainMenuModPassword');
    
    if (modButton) {
        if (modModeEnabled) {
            modButton.textContent = 'Disable';
            modButton.style.background = 'linear-gradient(135deg, #34C759, #32D74B)';
        } else {
            modButton.textContent = 'Enable';
            modButton.style.background = 'linear-gradient(135deg, #1e40af, #3730a3)';
        }
    }
    
    if (difficultyOption) {
        difficultyOption.style.display = modModeEnabled ? 'block' : 'none';
    }
    
    // Reset password field completely
    if (passwordField) {
        passwordField.value = '';
        passwordField.disabled = false;
        passwordField.readOnly = false;
        passwordField.style.opacity = '1';
        passwordField.style.pointerEvents = 'auto';
        
        // Force focus to ensure it's interactive
        setTimeout(() => {
            passwordField.focus();
            passwordField.blur();
        }, 100);
    }
    
    // Set current difficulty override value
    const difficultySelect = document.getElementById('mainMenuDifficultyOverride');
    if (difficultySelect) {
        difficultySelect.value = difficultyOverride.toString();
    }
}

// Toggle mod mode from main menu
function toggleMainMenuModMode() {
    const password = document.getElementById('mainMenuModPassword').value;
    const modButton = document.getElementById('mainMenuModButton');
    const difficultyOption = document.getElementById('mainMenuDifficultyOption');
    
    if (!modModeEnabled && password === MOD_PASSWORD) {
        // Enable mod mode
        modModeEnabled = true;
        modButton.textContent = 'Disable';
        modButton.style.background = 'linear-gradient(135deg, #34C759, #32D74B)';
        difficultyOption.style.display = 'block';
        
        // Clear password
        document.getElementById('mainMenuModPassword').value = '';
        
        alert('🎮 Mod Mode enabled!');
        saveGameData('settings_change');
        
    } else if (modModeEnabled) {
        // Disable mod mode
        modModeEnabled = false;
        modButton.textContent = 'Enable';
        modButton.style.background = 'linear-gradient(135deg, #1e40af, #3730a3)';
        difficultyOption.style.display = 'none';
        difficultyOverride = -1;
        
        alert('🔒 Mod Mode disabled.');
        saveGameData('settings_change');
        
    } else if (!modModeEnabled && password !== MOD_PASSWORD && password !== '') {
        alert('❌ Incorrect password!');
    }
    
    // Always clear password field after attempt
    document.getElementById('mainMenuModPassword').value = '';
}

// Apply difficulty override from main menu
function applyMainMenuDifficultyOverride() {
    const selectedLevel = parseInt(document.getElementById('mainMenuDifficultyOverride').value);
    difficultyOverride = selectedLevel;
    
    if (selectedLevel === -1) {
        alert('✅ Difficulty override disabled. Using normal time-based progression.');
    } else {
        const levelNames = ['Cruise', 'Accelerating', 'Intense', 'Blazing', 'Maximum Chaos'];
        alert(`⚡ Difficulty forced to Level ${selectedLevel + 1}: ${levelNames[selectedLevel]}`);
    }
}

// Placeholder for daily challenges (we'll implement this next)
function showDailyChallenges() {
    console.log('Daily challenges will be added in next step');
    alert('Daily Challenges coming soon! 🏆');
}

// Shop tab switching
function switchShopTab(tab) {
    // Remove active class from all tabs
    document.querySelectorAll('.shop-tab').forEach(t => {
        t.classList.remove('active');
        t.style.background = 'rgba(15, 20, 25, 0.5)';
        t.style.borderColor = 'rgba(79, 172, 254, 0.2)';
        t.style.color = '#e6edf3';
    });
    
    // Hide all content
    document.querySelectorAll('.shop-content').forEach(c => {
        c.style.display = 'none';
    });
    
    // Activate selected tab
    if (tab === 'characters') {
        document.getElementById('shop-characters-tab').classList.add('active');
        document.getElementById('shop-characters-tab').style.background = 'rgba(67, 203, 255, 0.15)';
        document.getElementById('shop-characters-tab').style.borderColor = '#43cbff';
        document.getElementById('shop-characters-tab').style.color = '#43cbff';
        document.getElementById('shop-characters-content').style.display = 'block';
    } else {
        document.getElementById('shop-worlds-tab').classList.add('active');
        document.getElementById('shop-worlds-tab').style.background = 'rgba(67, 203, 255, 0.15)';
        document.getElementById('shop-worlds-tab').style.borderColor = '#43cbff';
        document.getElementById('shop-worlds-tab').style.color = '#43cbff';
        document.getElementById('shop-worlds-content').style.display = 'block';
    }
}

// Initialize shop screen
function initializeShopScreen() {
    // Update coin display
    document.getElementById('shop-coin-count').textContent = totalCoins;
    
    // Populate character shop
    populateCharacterShop();
    
    // Populate world shop
    populateWorldShop();
}

// Populate character shop using game data
function populateCharacterShop() {
    const grid = document.getElementById('shop-characters-grid');
    grid.innerHTML = '';
    
    // Character data with costs from your game
    const characterData = {
        apple: { name: 'Apple', cost: 0, icon: '🍎', description: 'Classic runner' },
        carrot: { name: 'Carrot', cost: 200, icon: '🥕', description: 'Fast lane changes' },
        pumpkin: { name: 'Pumpkin', cost: 500, icon: '🎃', description: 'Higher jumps' },
        happyface: { name: 'Happy Face', cost: 1000, icon: '😊', description: 'Bouncy and cheerful' },
        monster: { name: 'Monster', cost: 5000, icon: '👹', description: 'Ominous and fast' },
        atom: { name: 'Atom', cost: 10000, icon: '⚛️', description: 'Glowing nucleus' },
        slime: { name: 'Slime', cost: 15000, icon: '🟢', description: 'Oozing and creepy' },
        ufo: { name: 'UFO', cost: 20000, icon: '🛸', description: 'Alien technology' },
        robot: { name: 'Robot', cost: 25000, icon: '🤖', description: 'Electromagnetic shield' },
        dragon: { name: 'Dragon', cost: 30000, icon: '🐉', description: 'Fire breath destroyer' },
        ghost: { name: 'Ghost', cost: 40000, icon: '👻', description: 'Phase through obstacles' },
        creature: { name: 'Creature', cost: 50000, icon: '🌀', description: 'Otherworldly cosmic entity' }
    };
    
    characterNames.forEach(charKey => {
        const char = characterData[charKey];
        if (!char) return;
        
        // FIXED: Check actual unlock status without fallback to modModeEnabled
        const isUnlocked = unlockedCharacters[charKey];
        const isSelected = currentCharacter === charKey;
        
        if (char.cost === 0) return; // Skip free characters in shop
        
        
        const item = document.createElement('div');
        item.style.cssText = `
            background: rgba(15, 20, 25, 0.5);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(79, 172, 254, 0.2);
            border-radius: 15px;
            padding: 1.5rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 8px 25px rgba(15, 20, 25, 0.6), inset 0 1px 0 rgba(79, 172, 254, 0.1);
            ${isUnlocked ? 'border-color: rgba(67, 203, 255, 0.4); background: rgba(67, 203, 255, 0.1);' : ''}
        `;
        
        item.innerHTML = `
            <div style="font-size: 3rem; margin-bottom: 1rem;">${char.icon}</div>
            <h3 style="color: #43cbff; margin-bottom: 0.5rem; font-size: 1.2rem;">${char.name}</h3>
            <p style="color: #b3c7e6; font-size: 0.9rem; margin-bottom: 1rem; opacity: 0.8;">${char.description}</p>
            ${isUnlocked ? 
                `<div style="background: linear-gradient(135deg, #34C759, #32D74B); color: white; padding: 0.5rem 1rem; border-radius: 20px; font-weight: bold; margin-top: 1rem;">✅ OWNED</div>` :
                `<button onclick="tryBuyCharacter('${charKey}')" style="background: linear-gradient(135deg, #1e40af, #3730a3); border: 1px solid rgba(79, 172, 254, 0.3); color: #e6edf3; padding: 0.8rem 1.5rem; border-radius: 25px; cursor: pointer; font-weight: bold; transition: all 0.3s ease; width: 100%;">${char.cost} 🪙 BUY</button>`
            }
        `;
        
        // Add hover effects
        if (!isUnlocked) {
            item.addEventListener('mouseenter', () => {
                item.style.transform = 'translateY(-5px)';
                item.style.background = 'rgba(15, 20, 25, 0.7)';
                item.style.borderColor = 'rgba(79, 172, 254, 0.4)';
                item.style.boxShadow = '0 15px 35px rgba(15, 20, 25, 0.8), 0 0 20px rgba(79, 172, 254, 0.2)';
            });
            
            item.addEventListener('mouseleave', () => {
                item.style.transform = 'translateY(0)';
                item.style.background = 'rgba(15, 20, 25, 0.5)';
                item.style.borderColor = 'rgba(79, 172, 254, 0.2)';
                item.style.boxShadow = '0 8px 25px rgba(15, 20, 25, 0.6), inset 0 1px 0 rgba(79, 172, 254, 0.1)';
            });
        }
        
        grid.appendChild(item);
    });
}

// Populate world shop using game data
function populateWorldShop() {
    const grid = document.getElementById('shop-worlds-grid');
    grid.innerHTML = '';
    
    availableWorlds.forEach(world => {
        const isUnlocked = unlockedWorlds[world.id];
        const isSelected = currentWorld === world.id;
        
        if (world.cost === 0) return; // Skip free worlds in shop
        
        const item = document.createElement('div');
        item.style.cssText = `
            background: rgba(15, 20, 25, 0.5);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(79, 172, 254, 0.2);
            border-radius: 15px;
            padding: 1.5rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 8px 25px rgba(15, 20, 25, 0.6), inset 0 1px 0 rgba(79, 172, 254, 0.1);
            ${isUnlocked ? 'border-color: rgba(67, 203, 255, 0.4); background: rgba(67, 203, 255, 0.1);' : ''}
        `;
        
        // Get world icon
        let worldIcon = '🌍';
        if (world.id === 'forest') worldIcon = '🌲';
        else if (world.id === 'desert') worldIcon = '🏜️';
        
        item.innerHTML = `
            <div style="font-size: 3rem; margin-bottom: 1rem;">${worldIcon}</div>
            <h3 style="color: #43cbff; margin-bottom: 0.5rem; font-size: 1.2rem;">${world.name}</h3>
            <p style="color: #b3c7e6; font-size: 0.9rem; margin-bottom: 1rem; opacity: 0.8;">${world.description}</p>
            ${isUnlocked ? 
                `<div style="background: linear-gradient(135deg, #34C759, #32D74B); color: white; padding: 0.5rem 1rem; border-radius: 20px; font-weight: bold; margin-top: 1rem;">✅ OWNED</div>` :
                `<button onclick="tryBuyWorld('${world.id}')" style="background: linear-gradient(135deg, #1e40af, #3730a3); border: 1px solid rgba(79, 172, 254, 0.3); color: #e6edf3; padding: 0.8rem 1.5rem; border-radius: 25px; cursor: pointer; font-weight: bold; transition: all 0.3s ease; width: 100%;">${world.cost} 🪙 BUY</button>`
            }
        `;
        
        // Add hover effects
        if (!isUnlocked) {
            item.addEventListener('mouseenter', () => {
                item.style.transform = 'translateY(-5px)';
                item.style.background = 'rgba(15, 20, 25, 0.7)';
                item.style.borderColor = 'rgba(79, 172, 254, 0.4)';
                item.style.boxShadow = '0 15px 35px rgba(15, 20, 25, 0.8), 0 0 20px rgba(79, 172, 254, 0.2)';
            });
            
            item.addEventListener('mouseleave', () => {
                item.style.transform = 'translateY(0)';
                item.style.background = 'rgba(15, 20, 25, 0.5)';
                item.style.borderColor = 'rgba(79, 172, 254, 0.2)';
                item.style.boxShadow = '0 8px 25px rgba(15, 20, 25, 0.6), inset 0 1px 0 rgba(79, 172, 254, 0.1)';
            });
        }
        
        grid.appendChild(item);
    });
}

// Try to buy character
function tryBuyCharacter(characterKey) {
    const cost = characterCosts[characterKey];
    
    if (totalCoins >= cost) {
        // Player can afford it
        if (confirm(`Purchase ${characterKey.charAt(0).toUpperCase() + characterKey.slice(1)} for ${cost} coins?`)) {
            totalCoins -= cost;
            unlockedCharacters[characterKey] = true;
            
            // CRITICAL: Update the profile's unlockedCharacters directly
            if (currentProfile) {
                if (!currentProfile.unlockedCharacters) {
                    currentProfile.unlockedCharacters = {};
                }
                currentProfile.unlockedCharacters[characterKey] = true;
                currentProfile.totalCoins = totalCoins;
            }
            
            // Update displays
            updateTotalCoins();
            document.getElementById('shop-coin-count').textContent = totalCoins;
            
            // Refresh shop display
            populateCharacterShop();
            
            // Force sync before saving
            syncGameStateToProfile();
            
            // Save progress with character purchase reason
            saveGameData('character_purchase');
            
            // Show success message
            alert(`🎉 ${characterKey.charAt(0).toUpperCase() + characterKey.slice(1)} unlocked! You can now select this character.`);
        }
    } else {
        const needed = cost - totalCoins;
        alert(`❌ Not enough coins! You need ${needed} more coins to buy this character.`);
    }
}

// Try to buy world
function tryBuyWorld(worldId) {
    const world = availableWorlds.find(w => w.id === worldId);
    if (!world) return;
    
    const cost = world.cost;
    
    if (totalCoins >= cost) {
        // Player can afford it
        if (confirm(`Purchase ${world.name} for ${cost} coins?`)) {
            // Deduct coins
            totalCoins -= cost;
            
            // Unlock the world
            unlockedWorlds[worldId] = true;
            
            // CRITICAL: Update the profile's unlockedWorlds directly
            if (currentProfile) {
                if (!currentProfile.unlockedWorlds) {
                    currentProfile.unlockedWorlds = {};
                }
                currentProfile.unlockedWorlds[worldId] = true;
                currentProfile.totalCoins = totalCoins;
            }
            
            // Update displays
            updateTotalCoins();
            document.getElementById('shop-coin-count').textContent = totalCoins;
            
            // Refresh shop display
            populateWorldShop();
            
            // Force sync before saving
            syncGameStateToProfile();
            
            // Save progress with world purchase reason
            saveGameData('world_purchase');
            
            // Show success message
            alert(`🎉 ${world.name} unlocked! You can now play in this world.`);
            

        }
    } else {
        const needed = cost - totalCoins;
        alert(`❌ Not enough coins! You need ${needed} more coins to buy this world.`);
    }
}

// Back to main menu functions
function backToMainMenu() {
    // Hide all other screens
    document.getElementById('characterSelectScreen').style.display = 'none';
    document.getElementById('worldSelectScreen').style.display = 'none';
    document.getElementById('settingsScreen').style.display = 'none';
    document.getElementById('modalOverlay').style.display = 'none';
    document.getElementById('shopScreen').style.display = 'none';
    
    // Hide 3D renderer
    if (renderer && renderer.domElement) {
        renderer.domElement.style.display = 'none';
    }

    // Hide the game renderer
if (renderer && renderer.domElement) {
    renderer.domElement.style.display = 'none';
}
    
    // Check if particles need to be restarted (don't destroy them)
console.log('🔄 Checking particle system...');

const existingCanvas = document.getElementById('particle-canvas');

// If canvas exists but is hidden, just show it
if (existingCanvas) {
    existingCanvas.style.display = 'block';
    existingCanvas.style.visibility = 'visible';
    existingCanvas.style.opacity = '1';
    
    // Make sure it's in the body
    if (existingCanvas.parentElement !== document.body) {
        document.body.appendChild(existingCanvas);
    }
    
    // Restart animation if needed
    if (titleParticleSystem && !titleParticleSystem.animationId) {
        titleParticleSystem.animate();
    }
    
    console.log('✅ Particles reactivated');
} else {
    // Only create new if canvas doesn't exist
    console.log('🆕 Creating new particle system...');
}
    
    // Create fresh canvas
    const canvas = document.createElement('canvas');
    canvas.id = 'particle-canvas';
    canvas.style.cssText = `
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
        pointer-events: none !important;
        z-index: 1 !important;
        display: block !important;
        opacity: 1 !important;
        visibility: visible !important;
    `;
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Add to document
    document.body.appendChild(canvas);
    
    // Create new particle system
    titleParticleSystem = new TitleParticleSystem();
    titleParticleSystem.init();

    
    
    // Show main menu
    document.getElementById('main-menu').style.display = 'flex';
    document.getElementById('main-menu').classList.add('active');
    gameState = "mainMenu";
    
    // Update coin display
    updateTotalCoins();
    
    console.log('✅ Main menu restored with fresh particle system');

    console.log('🏠 Back to main menu');
setTimeout(() => debugParticleState(), 100);

// Debug to track particle state
console.log('🏠 Back to main menu');
setTimeout(() => {
    const canvas = document.getElementById('particle-canvas');
    console.log('Main menu particle check:', {
        canvas: !!canvas,
        display: canvas?.style.display,
        parent: canvas?.parentElement?.id
    });
}, 100);

}

function showSettingsFromMenu() {
    console.log('⚙️ Transitioning to settings...');
    
    // Hide main menu
    document.getElementById('main-menu').style.display = 'none';
    
    // Hide the 3D renderer
    if (renderer && renderer.domElement) {
        renderer.domElement.style.display = 'none';
    }
    
    // Show particles for settings
    const canvas = document.getElementById('particle-canvas');
    if (canvas) {
        canvas.style.display = 'block';
        ensureParticlesVisible();
    }
    
    // Show the settings screen with the .active class
    const settingsDiv = document.getElementById('settings');
    if (settingsDiv) {
        settingsDiv.style.display = 'flex';
        // Add active class after a tiny delay to trigger animation
        setTimeout(() => {
            settingsDiv.classList.add('active');
        }, 10);
    }
    
    // Update game state
    gameState = "settings";

    // Debug to track particle state
console.log('⚙️ Settings shown');
setTimeout(() => {
    const canvas = document.getElementById('particle-canvas');
    console.log('Settings particle check:', {
        canvas: !!canvas,
        display: canvas?.style.display,
        parent: canvas?.parentElement?.id
    });
}, 100);
}

function backFromSettings() {
    console.log('⬅️ Returning from settings to main menu...');
    
    // Hide settings with animation
    const settingsDiv = document.getElementById('settings');
    if (settingsDiv) {
        settingsDiv.classList.remove('active');
        // Wait for animation before hiding
        setTimeout(() => {
            settingsDiv.style.display = 'none';
        }, 300);
    }
    
    // Show main menu
    backToMainMenu();
}

// Debug function to check particle system status
function checkParticleStatus() {
    console.log('🔍 Particle System Status:', {
        titleParticleSystem: !!titleParticleSystem,
        animationId: titleParticleSystem?.animationId,
        canvas: !!document.getElementById('particle-canvas'),
        canvasDisplay: document.getElementById('particle-canvas')?.style.display,
        gameState: gameState
    });
}

// Handle playTrack calls from jukebox buttons
function playTrack(trackName) {
    console.log(`🎵 Playing track: ${trackName}`);
    
    // Map the simple track names to your actual track IDs
    const trackMap = {
        'theme': 'medieval',
        'action': 'electronic', 
        'chill': 'ambient'
    };
    
    const actualTrackId = trackMap[trackName] || trackName;
    
    // Select and preview the track
    selectTrack(actualTrackId);
    previewSelectedTrack();
}

// Daily Challenges System
class DailyChallenges {
    constructor() {
        this.challenges = [];
        this.completedToday = [];
        this.lastResetDate = null;
        
        this.challengeTypes = [
    {
        type: 'distance',
        title: 'Distance Runner',
        description: 'Run {target} meters in a single run',
        rewards: { coins: 100 },
        targets: [1000, 2000, 5000, 10000]
    },
    {
        type: 'coins',
        title: 'Coin Collector',
        description: 'Collect {target} coins in a single run',
        rewards: { coins: 150 },
        targets: [50, 100, 200, 500]
    },
    {
        type: 'jumps',
        title: 'Jumping Jack',
        description: 'Jump {target} times in a single run',
        rewards: { coins: 75 },
        targets: [20, 50, 100, 200]
    },
    {
        type: 'powerups',
        title: 'Power Player',
        description: 'Collect {target} power-ups in a single run',
        rewards: { coins: 125 },
        targets: [5, 10, 20, 30]
    },
    {
        type: 'speed',
        title: 'Speed Demon',
        description: 'Reach speed level {target}',
        rewards: { coins: 175 },
        targets: [3, 5, 7, 10]
    },
    {
        type: 'laneChanges',
        title: 'Lane Dancer',
        description: 'Change lanes {target} times in a single run',
        rewards: { coins: 100 },
        targets: [30, 50, 100, 200]
    },
    {
        type: 'survivalTime',
        title: 'Survivor',
        description: 'Survive for {target} seconds',
        rewards: { coins: 150 },
        targets: [30, 60, 120, 300]
    },
    {
        type: 'nearMisses',
        title: 'Daredevil',
        description: 'Have {target} near misses with obstacles',
        rewards: { coins: 125 },
        targets: [10, 25, 50, 100]
    }
];
        
        this.loadChallenges();
    }

    generateDailyChallenges() {
        const today = new Date().toDateString();
        
        // Check if we need to reset challenges
        if (this.lastResetDate !== today) {
            this.challenges = [];
            this.completedToday = [];
            this.lastResetDate = today;
            
            // Generate 3 random challenges
            const shuffledTypes = [...this.challengeTypes].sort(() => Math.random() - 0.5);
            
            for (let i = 0; i < 3; i++) {
                const challengeType = shuffledTypes[i];
                const targetIndex = Math.floor(Math.random() * challengeType.targets.length);
                
                this.challenges.push({
                    id: `daily_${i}_${Date.now()}`,
                    type: challengeType.type,
                    title: challengeType.title,
                    description: challengeType.description.replace('{target}', challengeType.targets[targetIndex]),
                    target: challengeType.targets[targetIndex],
                    progress: 0,
                    completed: false,
                    rewards: challengeType.rewards
                });
            }
            
            this.saveChallenges();
        }
    }

    updateProgress(type, value) {
        this.challenges.forEach(challenge => {
            if (challenge.type === type && !challenge.completed) {
                if (type === 'perfectRun') {
                    challenge.progress = value ? 1 : 0;
                } else {
                    challenge.progress = Math.max(challenge.progress, value);
                }
                
                if (challenge.progress >= challenge.target) {
                    this.completeChallenge(challenge);
                }
            }
        });
        
        this.updateChallengeDisplay();
        updateChallengeButton();
    } catch (error) {
        console.error('Error updating challenge progress:', error);
        // Don't let challenge errors break the game
    }


    completeChallenge(challenge) {
    try {
        challenge.completed = true;
        this.completedToday.push(challenge.id);
        
        // Award rewards - use your game's coin system
        totalCoins += challenge.rewards.coins;
        
        // Update the coin display if it exists
        const coinDisplay = document.getElementById('coin-count');
        if (coinDisplay) {
            coinDisplay.textContent = totalCoins;
        }
        
        // Show completion notification
        this.showChallengeComplete(challenge);
        
        // Play success sound if available
        if (typeof playCoinSound === 'function') {
            playCoinSound(); // Use your game's coin sound
        }
        
        this.saveChallenges();
        
        // Save game data if function exists
        if (typeof saveGameData === 'function') {
            saveGameData('challenge_complete');
        }
    } catch (error) {
        console.error('Error completing challenge:', error);
        // Don't let this error break other challenges
    }
}

    showChallengeComplete(challenge) {
        const notification = document.createElement('div');
        notification.className = 'challenge-complete-notification';
        notification.innerHTML = `
            <div class="challenge-complete-content">
                <div class="challenge-complete-icon">🏆</div>
                <div class="challenge-complete-text">
                    <div class="challenge-complete-title">CHALLENGE COMPLETED!</div>
                    <div class="challenge-complete-name">${challenge.title}</div>
                    <div class="challenge-complete-reward">+${challenge.rewards.coins} 🪙</div>
                </div>
            </div>
        `;
        
        document.body.appendChild(notification);
        
        setTimeout(() => notification.classList.add('show'), 100);
        setTimeout(() => {
            notification.classList.remove('show');
            setTimeout(() => document.body.removeChild(notification), 500);
        }, 4000);
    }

    

    getChallenges() {
        return this.challenges;
    }

    updateChallengeDisplay() {
        const container = document.getElementById('daily-challenges-container');
        if (!container) return;
        
        container.innerHTML = '';
        
        this.challenges.forEach(challenge => {
            const div = document.createElement('div');
            div.className = `challenge-item ${challenge.completed ? 'completed' : ''}`;
            
            const progressPercent = Math.min((challenge.progress / challenge.target) * 100, 100);
            
            div.innerHTML = `
                <div class="challenge-header">
                    <div class="challenge-title">${challenge.title}</div>
                    <div class="challenge-reward">🪙 ${challenge.rewards.coins}</div>
                </div>
                <div class="challenge-description">${challenge.description}</div>
                <div class="challenge-progress">
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${progressPercent}%"></div>
                    </div>
                    <div class="progress-text">${challenge.progress}/${challenge.target}</div>
                </div>
                ${challenge.completed ? '<div class="challenge-complete-badge">✓ COMPLETED</div>' : ''}
            `;
            
            container.appendChild(div);
        });
    }

    saveChallenges() {
        const data = {
            challenges: this.challenges,
            completedToday: this.completedToday,
            lastResetDate: this.lastResetDate
        };
        localStorage.setItem('dashBlitzDailyChallenges', JSON.stringify(data));
    }

    loadChallenges() {
        const saved = localStorage.getItem('dashBlitzDailyChallenges');
        if (saved) {
            const data = JSON.parse(saved);
            this.challenges = data.challenges || [];
            this.completedToday = data.completedToday || [];
            this.lastResetDate = data.lastResetDate;
        }
        
        this.generateDailyChallenges(); // This will reset if needed

    

    }
}

// Global instance
let dailyChallenges;

// Initialize daily challenges
function initializeDailyChallenges() {
    dailyChallenges = new DailyChallenges();
    updateChallengeButton();
}

// Replace the placeholder function with this working version
function showDailyChallenges() {
    console.log('📋 Opening daily challenges modal...');
    
    const modal = document.getElementById('daily-challenges-modal');
    if (!modal) {
        console.error('❌ Daily challenges modal not found!');
        return;
    }
    
    modal.classList.add('active');
    
    // Make sure challenges exist
    if (!dailyChallenges) {
        console.error('❌ Daily challenges not initialized!');
        initializeDailyChallenges();
    }
    
    // Update challenges display when modal opens
    if (dailyChallenges) {
        console.log('✅ Updating challenge display...');
        dailyChallenges.updateChallengeDisplay();
        
        // Debug info
        debugDailyChallenges();
    }
}

function closeDailyChallenges() {
    const modal = document.getElementById('daily-challenges-modal');
    modal.classList.remove('active');
}

// Update challenge button display
function updateChallengeButton() {
    if (!dailyChallenges) return;
    
    const challenges = dailyChallenges.getChallenges();
    const completedCount = challenges.filter(c => c.completed).length;
    const totalCount = challenges.length;
    
    const progressText = document.getElementById('challenges-progress-text');
    const completionBadge = document.getElementById('challenges-completion-badge');
    const completedCountSpan = document.getElementById('completed-count');
    
    if (progressText) {
        if (completedCount === totalCount) {
            progressText.textContent = 'All challenges completed!';
            progressText.style.color = '#00f2fe';
        } else {
            progressText.textContent = `${totalCount - completedCount} challenges remaining`;
            progressText.style.color = '#b3c7e6';
        }
    }
    
    if (completionBadge && completedCountSpan) {
        completedCountSpan.textContent = completedCount;
        
        if (completedCount > 0) {
            completionBadge.style.display = 'block';
            
            if (completedCount === totalCount) {
                completionBadge.style.background = 'linear-gradient(135deg, #00f2fe, #43cbff)';
                completionBadge.style.animation = 'challengeComplete 2s ease-in-out infinite alternate';
            }
        } else {
            completionBadge.style.display = 'none';
        }
    }
}

// Debug function to check daily challenges state
function debugDailyChallenges() {
    console.log('🔍 Daily Challenges Debug:');
    console.log('  - Instance exists:', !!dailyChallenges);
    if (dailyChallenges) {
        console.log('  - Challenges:', dailyChallenges.challenges);
        console.log('  - Completed today:', dailyChallenges.completedToday);
        console.log('  - Last reset date:', dailyChallenges.lastResetDate);
    }
    
    // Check if container exists
    const container = document.getElementById('daily-challenges-container');
    console.log('  - Container exists:', !!container);
    if (container) {
        console.log('  - Container HTML:', container.innerHTML);
    }
}

// Function to reset daily challenges (for debugging)
function resetDailyChallenges() {
    console.log('🔄 Resetting daily challenges...');
    localStorage.removeItem('dashBlitzDailyChallenges');
    dailyChallenges = null;
    initializeDailyChallenges();
    console.log('✅ Daily challenges reset complete');
}

// Temporary test function
function testChallengesModal() {
    const modal = document.getElementById('daily-challenges-modal');
    const container = document.getElementById('daily-challenges-container');
    
    console.log('Modal element:', modal);
    console.log('Container element:', container);
    
    if (container) {
        container.innerHTML = '<div style="color: white; padding: 20px;">TEST: If you see this, the container is working!</div>';
    }
}

// Force disable mod mode (emergency reset)
function forceDisableModMode() {
    modModeEnabled = false;
    difficultyOverride = -1;
    
    // Update main menu settings UI if visible
    const modButton = document.getElementById('mainMenuModButton');
    if (modButton) {
        modButton.textContent = 'Enable';
        modButton.style.background = 'linear-gradient(135deg, #1e40af, #3730a3)';
    }
    
    const difficultyOption = document.getElementById('mainMenuDifficultyOption');
    if (difficultyOption) {
        difficultyOption.style.display = 'none';
    }
    
    // Clear password field
    const passwordField = document.getElementById('mainMenuModPassword');
    if (passwordField) {
        passwordField.value = '';
    }
    
    // Save state
    saveGameData('mod_mode_reset');
    console.log('🔒 Mod mode force disabled');
}

function debugWorldNavigation() {
    console.log('🔧 Setting up world navigation debug...');
    
    const prevBtn = document.getElementById('prevWorldBtn');
    const nextBtn = document.getElementById('nextWorldBtn');
    
    if (!prevBtn || !nextBtn) {
        console.error('Buttons not found!');
        return;
    }
    
    // Remove any existing listeners by cloning
    const newPrevBtn = prevBtn.cloneNode(true);
    const newNextBtn = nextBtn.cloneNode(true);
    
    prevBtn.parentNode.replaceChild(newPrevBtn, prevBtn);
    nextBtn.parentNode.replaceChild(newNextBtn, nextBtn);
    
    // Add simple test listeners
    document.getElementById('prevWorldBtn').onclick = function() {
        console.log('✅ PREV CLICKED - Current index:', selectedWorldIndex);
        selectedWorldIndex = (selectedWorldIndex - 1 + availableWorlds.length) % availableWorlds.length;
        console.log('New index:', selectedWorldIndex);
        updateWorldDisplay();
    };
    
    document.getElementById('nextWorldBtn').onclick = function() {
        console.log('✅ NEXT CLICKED - Current index:', selectedWorldIndex);
        selectedWorldIndex = (selectedWorldIndex + 1) % availableWorlds.length;
        console.log('New index:', selectedWorldIndex);
        updateWorldDisplay();
    };
    
    console.log('✅ Debug navigation set up!');
}

// Run this from console
debugWorldNavigation();

    </script>
</body>
</html>